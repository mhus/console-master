<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/copilot-instructions.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/copilot-instructions.md" />
              <option name="originalContent" value="# Copilot Instructions for Java Development&#10;&#10;## General Guidelines&#10;&#10;- the Base Package is 'com.consolemaster'&#10;- Use Java 21 or higher.&#10;- Use english for all code, comments and documentation.&#10;&#10;## Project Structure&#10;&#10;Multi-module Maven project with clear separation of concerns:&#10;- **Parent POM** (`console-master`): Manages dependencies and plugin versions&#10;- **Core Module** (`console-master-core`): Framework implementation with all core classes and tests&#10;- **Demo Module** (`console-master-demo`): Example applications demonstrating framework features&#10;- **Graphic3D Module** (`console-master-graphic3d`): 3D graphics extension for rendering 3D content in console&#10;- **Raycasting Module** (`console-master-raycasting`): Advanced 3D rendering using raycasting technique&#10;&#10;## Libraries and Frameworks&#10;&#10;- Use lombok for boilerplate code reduction.&#10;- Use JUnit 5 for unit testing.&#10;- Use Mockito for mocking dependencies in tests.&#10;&#10;## Project&#10;&#10;The project is a console framework to visualize game content in a console application.&#10;The base class is a Canvas that contains text/graphics and can be rendered to the console.&#10;The Canvas can use paint() method to draw content.&#10;A Composite Canvas can contain multiple Canvases that can be rendered together.&#10;&#10;The Screen Composite Canvas is the main entry point for the application.&#10;&#10;There is a minimum size of the console. If the console is smaller than the minimum size, &#10;a warning Canvas is displayed instead of the actual content.&#10;&#10;## Current Framework Implementation Status&#10;&#10;### Core Canvas System&#10;- **Canvas**: Abstract base class for all drawable elements with position (x,y), size (width,height), visibility&#10;- **Composite**: Container for multiple child canvases with automatic layout management&#10;- **ScreenCanvas**: Main entry point that manages terminal and minimum size validation&#10;- **TextCanvas**: Simple text display implementation (legacy)&#10;- **Text**: Modern text component with advanced styling&#10;- **Box**: Specialized canvas with border support and single child containment&#10;- **Scroller**: Scrollable container for content larger than viewport&#10;&#10;### Graphics and Rendering System&#10;- **Graphics (Abstract Base Class)**: Unified abstract base class for all graphics contexts&#10;- **GeneralGraphics**: Enhanced graphics implementation using Linux/Mac Terminal for superior ANSI support&#10;- **LegacyGraphics**: Backward-compatible implementation using StyledChar buffer&#10;- **ClippingGraphics**: Graphics wrapper that clips drawing operations to specified bounds&#10;- **AnsiColor**: Enum for ANSI foreground/background colors (standard + bright variants)&#10;- **AnsiFormat**: Enum for ANSI text formatting (bold, italic, underline, strikethrough, dim, reverse, blink)&#10;&#10;### 3D Graphics System (graphic3d module)&#10;- **Point3D**: 3D point representation with mathematical operations (addition, subtraction, normalization, distance calculation)&#10;- **Matrix4x4**: 4x4 transformation matrix supporting:&#10;  - Translation, rotation (X/Y/Z axes), and scaling transformations&#10;  - Perspective projection matrix generation&#10;  - Matrix multiplication and point transformation&#10;  - View and projection matrix calculations&#10;- **Mesh3D**: 3D mesh objects with triangular faces supporting:&#10;  - Vertex and face management&#10;  - Built-in primitive creation (cube, pyramid)&#10;  - Mesh transformation using matrices&#10;  - Normal vector calculation for lighting&#10;- **Camera3D**: 3D camera system with:&#10;  - Position and rotation (Euler angles) management&#10;  - Movement functions (forward, right, up movement)&#10;  - View matrix and projection matrix generation&#10;  - Look-at functionality for target-based camera positioning&#10;- **Graphic3DCanvas**: Main 3D rendering canvas extending base Canvas with:&#10;  - Three rendering modes: WIREFRAME, FILLED, BOTH&#10;  - Depth testing with Z-buffer for correct depth rendering&#10;  - Backface culling for performance optimization&#10;  - Configurable characters and colors for wireframe and fill rendering&#10;  - Bresenham line algorithm for precise edge rendering&#10;  - Scanline triangle filling for solid surfaces&#10;  - ASCII-based 3D rendering optimized for console output&#10;&#10;### Raycasting System (raycasting module)&#10;- **RaycastingCanvas**: Advanced 3D rendering canvas using raycasting technique for first-person perspective&#10;  - DDA (Digital Differential Analyzer) algorithm for precise ray casting&#10;  - Fish-eye correction for realistic perspective rendering&#10;  - Distance-based wall shading for depth perception&#10;  - Configurable field of view (FOV) and rendering parameters&#10;  - Wall edge detection with configurable threshold and styling&#10;  - Multiple wall characters and colors for visual variety&#10;  - Player movement system with collision detection (forward/backward, strafing, rotation)&#10;  - Support for complex 2D map layouts represented as string arrays&#10;  - Automatic safe player positioning when changing maps&#10;&#10;### Layout System&#10;- **Layout**: Interface for automatic component arrangement&#10;- **NoLayout**: Default layout that preserves manual positioning&#10;- **FlowLayout**: Arranges components in rows with automatic wrapping&#10;- **BorderLayout**: Arranges components in 5 regions (NORTH, SOUTH, EAST, WEST, CENTER)&#10;&#10;### Layout Constraints&#10;- **LayoutConstraint**: Interface for positioning hints to layouts&#10;- **PositionConstraint**: Constraint for predefined positions (TOP_LEFT, CENTER, etc.) or absolute coordinates&#10;- **SizeConstraint**: Constraint for sizing (FIXED, PERCENTAGE, FILL, PREFERRED)&#10;&#10;### Border System&#10;- **Border**: Interface for drawing borders around components&#10;- **DefaultBorder**: Basic border with single-line characters&#10;- **BorderStyle**: Enum defining different border styles (SINGLE, DOUBLE, THICK, ROUNDED, etc.)&#10;&#10;### Focus Management System&#10;- **Focus Support**: Canvas components can receive and manage focus&#10;- **FocusManager**: Central focus management for ScreenCanvas with automatic traversal&#10;- **Focus Navigation**: TAB/SHIFT+TAB for component navigation, arrow keys for directional focus&#10;- **Focus Events**: `onFocusChanged(boolean)` callback for visual feedback&#10;&#10;### Size Management and Pack System&#10;- **Canvas Constraints**: minWidth/maxWidth and minHeight/maxHeight with automatic validation&#10;- **Pack System**: `pack()` method for automatic size calculation based on content&#10;&#10;### Process Loop and Event System&#10;- **ProcessLoop**: Main processing loop for continuous rendering and non-blocking input handling&#10;- **Event System**: Complete event-driven architecture with keyboard and mouse input processing&#10;- **KeyEvent**: Comprehensive keyboard event handling with special keys, modifiers, and shortcuts&#10;- **MouseEvent**: Complete mouse event handling with buttons, actions, coordinates&#10;- **EventHandler Interface**: Components can implement to receive keyboard and mouse events&#10;&#10;### Output Capture System&#10;- **OutputCapture**: Thread-safe stdout/stderr stream redirection system&#10;- **ConsoleOutput Canvas**: Specialized canvas for displaying captured console output with multiple display modes&#10;- **ProcessLoop Integration**: Built-in output capture management&#10;&#10;### Terminal Integration&#10;- ANSI color and formatting support&#10;- Automatic terminal size detection&#10;- Cross-platform terminal compatibility&#10;&#10;### Demo Applications&#10;- **ConsoleMasterDemo**: Basic framework demonstration&#10;- **GraphicsDemo**: Graphics system showcase&#10;- **LayoutDemo**: FlowLayout demonstration with modern components&#10;- **BorderLayoutDemo**: BorderLayout with 5 regions&#10;- **BoxDemo**: Border and Box component showcase&#10;- **FocusDemo**: Focus management system demonstration&#10;- **ProcessLoopDemo**: Interactive ProcessLoop system demonstration&#10;- **OutputCaptureDemo**: Output capture system demonstration&#10;- **MouseDemo**: Mouse event handling demonstration&#10;- **TextDemo**: Text component features demonstration&#10;- **ClippingGraphicsDemo**: Graphics clipping demonstration&#10;- **BeautifulBorderDemo**: Advanced border styling showcase&#10;- **BorderStyleDemo**: Different border styles demonstration&#10;- **ScrollerDemo**: Scrollable content demonstration&#10;- **ConsoleInputDemo**: Console input handling demonstration&#10;- **NativeTerminalDemo**: Native terminal features demonstration&#10;- **Graphic3DDemo**: 3D graphics system demonstration with various 3D objects and rendering modes&#10;- **RaycastingDemo**: Interactive first-person 3D raycasting demonstration with multiple complex maps&#10;&#10;### 3D Graphics Usage Examples&#10;&#10;```java&#10;// Create a 3D canvas&#10;Graphic3DCanvas canvas3D = new Graphic3DCanvas(&quot;3D Scene&quot;, 80, 40);&#10;&#10;// Configure rendering mode&#10;canvas3D.setRenderMode(Graphic3DCanvas.RenderMode.WIREFRAME);&#10;canvas3D.setWireframeChar('*');&#10;canvas3D.setWireframeColor(AnsiColor.CYAN);&#10;&#10;// Position camera&#10;canvas3D.getCamera().setPosition(new Point3D(0, 0, 5));&#10;canvas3D.getCamera().lookAt(new Point3D(0, 0, 0));&#10;&#10;// Create and add 3D objects&#10;Mesh3D cube = Mesh3D.createCube(2.0);&#10;canvas3D.addMesh(cube);&#10;&#10;// Apply transformations&#10;Matrix4x4 rotation = Matrix4x4.rotationY(Math.PI / 4);&#10;Mesh3D rotatedCube = cube.transform(rotation);&#10;canvas3D.addMesh(rotatedCube);&#10;```&#10;&#10;### Raycasting Usage Examples&#10;&#10;```java&#10;// Create a raycasting canvas&#10;RaycastingCanvas raycastingCanvas = new RaycastingCanvas(&quot;3D World&quot;, 80, 25);&#10;&#10;// Configure rendering parameters&#10;raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;raycastingCanvas.setDrawWallEdges(true);&#10;raycastingCanvas.setWallEdgeThreshold(0.3);&#10;&#10;// Set custom map&#10;String[] customMap = {&#10;    &quot;########&quot;,&#10;    &quot;#      #&quot;,&#10;    &quot;#  ##  #&quot;,&#10;    &quot;#      #&quot;,&#10;    &quot;########&quot;&#10;};&#10;raycastingCanvas.setMap(customMap);&#10;&#10;// Position player&#10;raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;raycastingCanvas.setPlayerAngle(0.0);&#10;&#10;// Player movement&#10;raycastingCanvas.movePlayer(0.1);           // Move forward&#10;raycastingCanvas.strafePlayer(-0.1);        // Strafe left&#10;raycastingCanvas.rotatePlayer(Math.PI/6);   // Rotate 30 degrees&#10;```&#10;&#10;### Development Guidelines&#10;&#10;- Use unified `paint(Graphics graphics)` method for all components&#10;- Leverage polymorphic Graphics design for maximum compatibility&#10;- Implement EventHandler interface for interactive components&#10;- Use pack() system for automatic size calculation&#10;- Prefer composition over inheritance for complex components&#10;- For 3D development, use the graphic3d module with proper depth testing and matrix transformations&#10;- 3D objects should be created using Mesh3D and positioned using Matrix4x4 transformations&#10;- Camera management should use Camera3D for proper view and projection setup&#10;- Core framework development happens in the `core` module&#10;- 3D graphics development happens in the `graphic3d` module with dependency on core&#10;- Demo applications are developed in the `demo` module with dependency on core and graphic3d as needed&#10;- For raycasting development, use the raycasting module with proper DDA algorithm implementation and map handling&#10;" />
              <option name="updatedContent" value="# Copilot Instructions for Java Development&#10;&#10;## General Guidelines&#10;&#10;- the Base Package is 'com.consolemaster'&#10;- Use Java 21 or higher.&#10;- Use english for all code, comments and documentation.&#10;&#10;## Project Structure&#10;&#10;Multi-module Maven project with clear separation of concerns:&#10;- **Parent POM** (`console-master`): Manages dependencies and plugin versions&#10;- **Core Module** (`console-master-core`): Framework implementation with all core classes and tests&#10;- **Demo Module** (`console-master-demo`): Example applications demonstrating framework features&#10;- **Graphic3D Module** (`console-master-graphic3d`): 3D graphics extension for rendering 3D content in console&#10;- **Raycasting Module** (`console-master-raycasting`): Advanced 3D rendering using raycasting technique&#10;&#10;## Libraries and Frameworks&#10;&#10;- Use lombok for boilerplate code reduction.&#10;- Use JUnit 5 for unit testing.&#10;- Use Mockito for mocking dependencies in tests.&#10;&#10;## Project&#10;&#10;The project is a console framework to visualize game content in a console application.&#10;The base class is a Canvas that contains text/graphics and can be rendered to the console.&#10;The Canvas can use paint() method to draw content.&#10;A Composite Canvas can contain multiple Canvases that can be rendered together.&#10;&#10;The Screen Composite Canvas is the main entry point for the application.&#10;&#10;There is a minimum size of the console. If the console is smaller than the minimum size, &#10;a warning Canvas is displayed instead of the actual content.&#10;&#10;## Current Framework Implementation Status&#10;&#10;### Core Canvas System&#10;- **Canvas**: Abstract base class for all drawable elements with position (x,y), size (width,height), visibility&#10;- **Composite**: Container for multiple child canvases with automatic layout management&#10;- **ScreenCanvas**: Main entry point that manages terminal and minimum size validation&#10;- **TextCanvas**: Simple text display implementation (legacy)&#10;- **Text**: Modern text component with advanced styling&#10;- **Box**: Specialized canvas with border support and single child containment&#10;- **Scroller**: Scrollable container for content larger than viewport&#10;&#10;### Graphics and Rendering System&#10;- **Graphics (Abstract Base Class)**: Unified abstract base class for all graphics contexts&#10;- **GeneralGraphics**: Enhanced graphics implementation using Linux/Mac Terminal for superior ANSI support&#10;- **LegacyGraphics**: Backward-compatible implementation using StyledChar buffer&#10;- **ClippingGraphics**: Graphics wrapper that clips drawing operations to specified bounds&#10;- **AnsiColor**: Enum for ANSI foreground/background colors (standard + bright variants)&#10;- **AnsiFormat**: Enum for ANSI text formatting (bold, italic, underline, strikethrough, dim, reverse, blink)&#10;&#10;### 3D Graphics System (graphic3d module)&#10;- **Point3D**: 3D point representation with mathematical operations (addition, subtraction, normalization, distance calculation)&#10;- **Matrix4x4**: 4x4 transformation matrix supporting:&#10;  - Translation, rotation (X/Y/Z axes), and scaling transformations&#10;  - Perspective projection matrix generation&#10;  - Matrix multiplication and point transformation&#10;  - View and projection matrix calculations&#10;- **Mesh3D**: 3D mesh objects with triangular faces supporting:&#10;  - Vertex and face management&#10;  - Built-in primitive creation (cube, pyramid)&#10;  - Mesh transformation using matrices&#10;  - Normal vector calculation for lighting&#10;- **Camera3D**: 3D camera system with:&#10;  - Position and rotation (Euler angles) management&#10;  - Movement functions (forward, right, up movement)&#10;  - View matrix and projection matrix generation&#10;  - Look-at functionality for target-based camera positioning&#10;- **Graphic3DCanvas**: Main 3D rendering canvas extending base Canvas with:&#10;  - Three rendering modes: WIREFRAME, FILLED, BOTH&#10;  - Depth testing with Z-buffer for correct depth rendering&#10;  - Backface culling for performance optimization&#10;  - Configurable characters and colors for wireframe and fill rendering&#10;  - Bresenham line algorithm for precise edge rendering&#10;  - Scanline triangle filling for solid surfaces&#10;  - ASCII-based 3D rendering optimized for console output&#10;&#10;### Raycasting System (raycasting module)&#10;- **RaycastingCanvas**: Advanced 3D rendering canvas using raycasting technique for first-person perspective&#10;  - DDA (Digital Differential Analyzer) algorithm for precise ray casting&#10;  - Fish-eye correction for realistic perspective rendering&#10;  - Distance-based wall shading for depth perception&#10;  - Configurable field of view (FOV) and rendering parameters&#10;  - Wall edge detection with configurable threshold and styling&#10;  - Multiple wall characters and colors for visual variety&#10;  - Player movement system with collision detection (forward/backward, strafing, rotation)&#10;  - Support for complex 2D map layouts represented as string arrays&#10;  - Automatic safe player positioning when changing maps&#10;- **MapProvider Interface**: Flexible map data abstraction for dynamic map systems&#10;  - `getEntry(x, y)`: Returns EntryInfo objects for each map position&#10;  - `getWidth()`, `getHeight()`, `getName()`: Map metadata access&#10;  - Support for both static and dynamic map generation&#10;- **DefaultMapProvider**: Standard implementation supporting string arrays and EntryInfo maps&#10;  - Automatic conversion from legacy string maps to EntryInfo objects&#10;  - Backward compatibility with existing map formats&#10;- **EntryInfo System**: Comprehensive map entry description with advanced properties&#10;  - `isWall`, `isFallthrough`, `isTransparent`: Collision and visibility properties&#10;  - `colorLight`, `colorDark`: Dual-color system for realistic lighting (vertical/horizontal walls)&#10;  - `character`, `name`, `height`: Visual and descriptive properties&#10;  - `texture`: Future texture mapping support&#10;  - Predefined entry types: Wall, Floor, Glass, Stone, Brick, Metal, Tree&#10;  - Dynamic floor rendering with EntryInfo-based colors and materials&#10;  - Automatic orientation-based color selection (light for vertical, dark for horizontal walls)&#10;&#10;### Layout System&#10;- **Layout**: Interface for automatic component arrangement&#10;- **NoLayout**: Default layout that preserves manual positioning&#10;- **FlowLayout**: Arranges components in rows with automatic wrapping&#10;- **BorderLayout**: Arranges components in 5 regions (NORTH, SOUTH, EAST, WEST, CENTER)&#10;&#10;### Layout Constraints&#10;- **LayoutConstraint**: Interface for positioning hints to layouts&#10;- **PositionConstraint**: Constraint for predefined positions (TOP_LEFT, CENTER, etc.) or absolute coordinates&#10;- **SizeConstraint**: Constraint for sizing (FIXED, PERCENTAGE, FILL, PREFERRED)&#10;&#10;### Border System&#10;- **Border**: Interface for drawing borders around components&#10;- **DefaultBorder**: Basic border with single-line characters&#10;- **BorderStyle**: Enum defining different border styles (SINGLE, DOUBLE, THICK, ROUNDED, etc.)&#10;&#10;### Focus Management System&#10;- **Focus Support**: Canvas components can receive and manage focus&#10;- **FocusManager**: Central focus management for ScreenCanvas with automatic traversal&#10;- **Focus Navigation**: TAB/SHIFT+TAB for component navigation, arrow keys for directional focus&#10;- **Focus Events**: `onFocusChanged(boolean)` callback for visual feedback&#10;&#10;### Size Management and Pack System&#10;- **Canvas Constraints**: minWidth/maxWidth and minHeight/maxHeight with automatic validation&#10;- **Pack System**: `pack()` method for automatic size calculation based on content&#10;&#10;### Process Loop and Event System&#10;- **ProcessLoop**: Main processing loop for continuous rendering and non-blocking input handling&#10;- **Event System**: Complete event-driven architecture with keyboard and mouse input processing&#10;- **KeyEvent**: Comprehensive keyboard event handling with special keys, modifiers, and shortcuts&#10;- **MouseEvent**: Complete mouse event handling with buttons, actions, coordinates&#10;- **EventHandler Interface**: Components can implement to receive keyboard and mouse events&#10;&#10;### Output Capture System&#10;- **OutputCapture**: Thread-safe stdout/stderr stream redirection system&#10;- **ConsoleOutput Canvas**: Specialized canvas for displaying captured console output with multiple display modes&#10;- **ProcessLoop Integration**: Built-in output capture management&#10;&#10;### Terminal Integration&#10;- ANSI color and formatting support&#10;- Automatic terminal size detection&#10;- Cross-platform terminal compatibility&#10;&#10;### Demo Applications&#10;- **ConsoleMasterDemo**: Basic framework demonstration&#10;- **GraphicsDemo**: Graphics system showcase&#10;- **LayoutDemo**: FlowLayout demonstration with modern components&#10;- **BorderLayoutDemo**: BorderLayout with 5 regions&#10;- **BoxDemo**: Border and Box component showcase&#10;- **FocusDemo**: Focus management system demonstration&#10;- **ProcessLoopDemo**: Interactive ProcessLoop system demonstration&#10;- **OutputCaptureDemo**: Output capture system demonstration&#10;- **MouseDemo**: Mouse event handling demonstration&#10;- **TextDemo**: Text component features demonstration&#10;- **ClippingGraphicsDemo**: Graphics clipping demonstration&#10;- **BeautifulBorderDemo**: Advanced border styling showcase&#10;- **BorderStyleDemo**: Different border styles demonstration&#10;- **ScrollerDemo**: Scrollable content demonstration&#10;- **ConsoleInputDemo**: Console input handling demonstration&#10;- **NativeTerminalDemo**: Native terminal features demonstration&#10;- **Graphic3DDemo**: 3D graphics system demonstration with various 3D objects and rendering modes&#10;- **RaycastingDemo**: Interactive first-person 3D raycasting demonstration with multiple complex maps&#10;&#10;### 3D Graphics Usage Examples&#10;&#10;```java&#10;// Create a 3D canvas&#10;Graphic3DCanvas canvas3D = new Graphic3DCanvas(&quot;3D Scene&quot;, 80, 40);&#10;&#10;// Configure rendering mode&#10;canvas3D.setRenderMode(Graphic3DCanvas.RenderMode.WIREFRAME);&#10;canvas3D.setWireframeChar('*');&#10;canvas3D.setWireframeColor(AnsiColor.CYAN);&#10;&#10;// Position camera&#10;canvas3D.getCamera().setPosition(new Point3D(0, 0, 5));&#10;canvas3D.getCamera().lookAt(new Point3D(0, 0, 0));&#10;&#10;// Create and add 3D objects&#10;Mesh3D cube = Mesh3D.createCube(2.0);&#10;canvas3D.addMesh(cube);&#10;&#10;// Apply transformations&#10;Matrix4x4 rotation = Matrix4x4.rotationY(Math.PI / 4);&#10;Mesh3D rotatedCube = cube.transform(rotation);&#10;canvas3D.addMesh(rotatedCube);&#10;```&#10;&#10;### Raycasting Usage Examples&#10;&#10;```java&#10;// Create a raycasting canvas&#10;RaycastingCanvas raycastingCanvas = new RaycastingCanvas(&quot;3D World&quot;, 80, 25);&#10;&#10;// Configure rendering parameters&#10;raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;raycastingCanvas.setDrawWallEdges(true);&#10;raycastingCanvas.setWallEdgeThreshold(0.3);&#10;&#10;// Set custom map&#10;String[] customMap = {&#10;    &quot;########&quot;,&#10;    &quot;#      #&quot;,&#10;    &quot;#  ##  #&quot;,&#10;    &quot;#      #&quot;,&#10;    &quot;########&quot;&#10;};&#10;raycastingCanvas.setMap(customMap);&#10;&#10;// Position player&#10;raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;raycastingCanvas.setPlayerAngle(0.0);&#10;&#10;// Player movement&#10;raycastingCanvas.movePlayer(0.1);           // Move forward&#10;raycastingCanvas.strafePlayer(-0.1);        // Strafe left&#10;raycastingCanvas.rotatePlayer(Math.PI/6);   // Rotate 30 degrees&#10;```&#10;&#10;### Development Guidelines&#10;&#10;- Use unified `paint(Graphics graphics)` method for all components&#10;- Leverage polymorphic Graphics design for maximum compatibility&#10;- Implement EventHandler interface for interactive components&#10;- Use pack() system for automatic size calculation&#10;- Prefer composition over inheritance for complex components&#10;- For 3D development, use the graphic3d module with proper depth testing and matrix transformations&#10;- 3D objects should be created using Mesh3D and positioned using Matrix4x4 transformations&#10;- Camera management should use Camera3D for proper view and projection setup&#10;- Core framework development happens in the `core` module&#10;- 3D graphics development happens in the `graphic3d` module with dependency on core&#10;- Demo applications are developed in the `demo` module with dependency on core and graphic3d as needed&#10;- For raycasting development, use the raycasting module with proper DDA algorithm implementation and map handling" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>