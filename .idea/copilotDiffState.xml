<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/RaycastingDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/RaycastingDemo.java" />
              <option name="originalContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.BorderLayout;&#10;import com.consolemaster.Box;&#10;import com.consolemaster.Composite;&#10;import com.consolemaster.DefaultBorder;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.PositionConstraint;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.Text;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.DefaultMapProvider;&#10;import com.consolemaster.raycasting.MapProvider;&#10;import com.consolemaster.raycasting.EntryInfo;&#10;import com.consolemaster.raycasting.PictureTextureProvider;&#10;import com.consolemaster.raycasting.RegistryTextureProvider;&#10;import com.consolemaster.raycasting.TilingTextureProvider;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive raycasting demo showcasing first-person 3D perspective in a 2D world.&#10; * Features player movement, rotation, and different map environments using MapProvider.&#10; */&#10;@Slf4j&#10;public class RaycastingDemo {&#10;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static RaycastingCanvas raycastingCanvas;&#10;    private static int currentMapIndex = 0;&#10;    private static final char[] wallEdgeStyles = {'│', '#', '*', '+'};&#10;    private static int currentWallEdgeStyleIndex = 0;&#10;&#10;    // Different map providers to showcase&#10;    private static final MapProvider[] MAP_PROVIDERS = {&#10;        // Simple map with basic walls and floors&#10;        new DefaultMapProvider(&quot;Simple Maze&quot;, new String[]{&#10;            &quot;########&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;#  ##  #&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;########&quot;&#10;        }),&#10;&#10;        // Advanced map with different EntryInfo types&#10;        createAdvancedMapProvider(),&#10;&#10;        // Textured map with various textures&#10;        createTexturedMapProvider(),&#10;&#10;        // Tiling texture demonstration map&#10;        createTilingTextureMapProvider(),&#10;&#10;        // Complex maze map&#10;        new DefaultMapProvider(&quot;Complex Maze&quot;, new String[]{&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# #### ## #### #&quot;,&#10;            &quot;#    #    #    #&quot;,&#10;            &quot;#### # ## # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# ## #### ## # #&quot;,&#10;            &quot;#  #      #  # #&quot;,&#10;            &quot;## # #### # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        }),&#10;&#10;        // Natural landscape with water and grass&#10;        createNaturalLandscapeProvider(),&#10;&#10;        // Castle dungeon with mixed entry types&#10;        createCastleMapProvider(),&#10;&#10;        // Floor texture demonstration map&#10;        createFloorTextureMapProvider(),&#10;&#10;        // Checkerboard floor pattern map&#10;        createCheckerboardFloorMapProvider(),&#10;&#10;        // Background color demonstration map&#10;        createBackgroundColorDemoMapProvider(),&#10;&#10;        // Wall height demonstration map&#10;        createWallHeightDemoMapProvider()&#10;    };&#10;&#10;    /**&#10;     * Creates an advanced map provider showcasing different EntryInfo features.&#10;     */&#10;    private static MapProvider createAdvancedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[8][12];&#10;&#10;        // Initialize with different floor types&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 3 == 0) {&#10;                    // Stone floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else if ((x + y) % 3 == 1) {&#10;                    // Grass floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else {&#10;                    // Sand floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('°')&#10;                            .name(&quot;Sand Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                            .colorDark(AnsiColor.YELLOW)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create walls around the border using stone walls&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some glass walls (transparent but blocking)&#10;        map[2][3] = EntryInfo.createGlass();&#10;        map[2][4] = EntryInfo.createGlass();&#10;        map[2][5] = EntryInfo.createGlass();&#10;&#10;        // Add low walls (half height)&#10;        map[4][2] = EntryInfo.createLowWall();&#10;        map[4][3] = EntryInfo.createLowWall();&#10;        map[5][2] = EntryInfo.createLowWall();&#10;        map[5][3] = EntryInfo.createLowWall();&#10;&#10;        // Add brick walls with proper light/dark colors&#10;        map[3][7] = EntryInfo.createBrickWall();&#10;        map[3][8] = EntryInfo.createBrickWall();&#10;        map[4][7] = EntryInfo.createBrickWall();&#10;        map[4][8] = EntryInfo.createBrickWall();&#10;&#10;        // Add metal walls&#10;        map[6][7] = EntryInfo.createMetalWall();&#10;        map[6][8] = EntryInfo.createMetalWall();&#10;&#10;        // Add custom colored walls with specific light/dark combinations&#10;        EntryInfo greenWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Green Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo purpleWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Purple Wall&quot;)&#10;                .colorLight(AnsiColor.MAGENTA)&#10;                .colorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        map[6][4] = greenWall;&#10;        map[6][5] = greenWall;&#10;        map[5][9] = purpleWall;&#10;        map[6][9] = purpleWall;&#10;&#10;        // Add water area (blue floor)&#10;        EntryInfo water = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isWalkThrough(true)&#10;                .isTransparent(true)&#10;                .character('~')&#10;                .name(&quot;Water&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(0.0)&#10;                .build();&#10;&#10;        map[3][9] = water;&#10;        map[3][10] = water;&#10;        map[4][9] = water;&#10;        map[4][10] = water;&#10;&#10;        return new DefaultMapProvider(&quot;Advanced Features&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a castle map with various EntryInfo types.&#10;     */&#10;    private static MapProvider createCastleMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with floors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create outer walls with stone&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add castle features with enhanced colors&#10;        EntryInfo tower = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('♦')&#10;                .name(&quot;Tower&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        EntryInfo gate = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isWalkThrough(true)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Gate&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo courtyard = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Courtyard Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        // Place towers&#10;        map[2][2] = tower;&#10;        map[2][13] = tower;&#10;        map[9][2] = tower;&#10;        map[9][13] = tower;&#10;&#10;        // Create gates&#10;        map[5][0] = gate;&#10;        map[6][0] = gate;&#10;&#10;        // Add interior walls with different materials&#10;        for (int x = 4; x &lt; 12; x++) {&#10;            if (x != 7 &amp;&amp; x != 8) { // Leave doorway&#10;                if (x &lt; 8) {&#10;                    map[5][x] = EntryInfo.createBrickWall();&#10;                } else {&#10;                    map[5][x] = EntryInfo.createMetalWall();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add courtyard walls&#10;        map[7][3] = courtyard;&#10;        map[8][3] = courtyard;&#10;        map[7][12] = courtyard;&#10;        map[8][12] = courtyard;&#10;&#10;        return new DefaultMapProvider(&quot;Castle&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a natural landscape map with water and grass.&#10;     */&#10;    private static MapProvider createNaturalLandscapeProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][14];&#10;&#10;        // Initialize with grass floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass Floor&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create water areas&#10;        for (int y = 2; y &lt;= 3; y++) {&#10;            for (int x = 4; x &lt;= 9; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create island with trees&#10;        for (int y = 1; y &lt;= 8; y++) {&#10;            for (int x = 1; x &lt;= 12; x++) {&#10;                if (x == 1 || x == 12 || y == 1 || y == 8) {&#10;                    map[y][x] = EntryInfo.createStoneWall();&#10;                } else if ((x + y) % 4 == 0) {&#10;                    map[y][x] = EntryInfo.createTree();&#10;                }&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Natural Landscape&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a textured map provider showcasing various textures.&#10;     */&#10;    private static MapProvider createTexturedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some wooden walls&#10;        for (int i = 2; i &lt; 8; i++) {&#10;            map[i][3] = EntryInfo.createWoodenWall();&#10;            map[i][6] = EntryInfo.createWoodenWall();&#10;        }&#10;&#10;        // Add a water area&#10;        for (int y = 4; y &lt;= 5; y++) {&#10;            for (int x = 1; x &lt;= 8; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Textured Map&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a tiling texture map provider showcasing various tiling textures.&#10;     */&#10;    private static MapProvider createTilingTextureMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][12];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Create different sections to showcase tiling textures&#10;&#10;        // Left section: Tiling brick walls&#10;        for (int y = 2; y &lt;= 5; y++) {&#10;            map[y][3] = EntryInfo.createTilingBrickWall();&#10;        }&#10;&#10;        // Right section: Dotted walls&#10;        for (int y = 2; y &lt;= 5; y++) {&#10;            map[y][8] = EntryInfo.createDottedWall();&#10;        }&#10;&#10;        // Center section: Hash pattern walls&#10;        for (int x = 4; x &lt;= 7; x++) {&#10;            map[3][x] = EntryInfo.createHashWall();&#10;        }&#10;&#10;        // Bottom section: Wave pattern walls&#10;        for (int x = 4; x &lt;= 7; x++) {&#10;            map[8][x] = EntryInfo.createWaveWall();&#10;        }&#10;&#10;        // Add some traditional scaling textured walls for comparison&#10;        map[6][3] = EntryInfo.createWoodenWall(); // Uses scaling texture&#10;        map[6][8] = EntryInfo.createBrickWall();  // Uses scaling texture&#10;&#10;        return new DefaultMapProvider(&quot;Tiling Texture Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Sets up the texture provider for the raycasting canvas.&#10;     */&#10;    private static void setupTextureProvider(RaycastingCanvas canvas) {&#10;        // Create a picture texture provider with various textures (scaling)&#10;        PictureTextureProvider pictureProvider = new PictureTextureProvider();&#10;&#10;        // Create a tiling texture provider with repeating patterns&#10;        TilingTextureProvider tilingProvider = new TilingTextureProvider();&#10;&#10;        // Add wood texture (scaling)&#10;        String[] woodTexture = {&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood&quot;, woodTexture);&#10;&#10;        // Add brick texture (scaling)&#10;        String[] brickTexture = {&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;brick&quot;, brickTexture);&#10;&#10;        // Add stone texture (scaling)&#10;        String[] stoneTexture = {&#10;            &quot;█▓▒░░▒▓█&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;░      ░&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;█▓▒░░▒▓█&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone&quot;, stoneTexture);&#10;&#10;        // Add metal texture (scaling)&#10;        String[] metalTexture = {&#10;            &quot;========&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;--------&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;========&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;metal&quot;, metalTexture);&#10;&#10;        // ===== FLOOR TEXTURES =====&#10;&#10;        // Add simple floor texture pattern&#10;        String[] floorTexture = {&#10;            &quot;░░▒▒░░&quot;,&#10;            &quot;░▒▓▓▒░&quot;,&#10;            &quot;▒▓██▓▒&quot;,&#10;            &quot;▒▓██▓▒&quot;,&#10;            &quot;░▒▓▓▒░&quot;,&#10;            &quot;░░▒▒░░&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;floor&quot;, floorTexture);&#10;&#10;        // Add stone floor texture&#10;        String[] stoneFloorTexture = {&#10;            &quot;▓▓░░▓▓&quot;,&#10;            &quot;▓░  ░▓&quot;,&#10;            &quot;░    ░&quot;,&#10;            &quot;░    ░&quot;,&#10;            &quot;▓░  ░▓&quot;,&#10;            &quot;▓▓░░▓▓&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone_floor&quot;, stoneFloorTexture);&#10;&#10;        // Add wooden floor texture&#10;        String[] woodFloorTexture = {&#10;            &quot;|||||||&quot;,&#10;            &quot;-------&quot;,&#10;            &quot;|||||||&quot;,&#10;            &quot;-------&quot;,&#10;            &quot;|||||||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood_floor&quot;, woodFloorTexture);&#10;&#10;        // Add tiling patterns that look better when repeated&#10;        String[] tilingBrickPattern = {&#10;            &quot;██  ██&quot;,&#10;            &quot;  ██  &quot;,&#10;            &quot;██  ██&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;tiling_brick&quot;, tilingBrickPattern);&#10;&#10;        String[] dotPattern = {&#10;            &quot; ● &quot;,&#10;            &quot;   &quot;,&#10;            &quot; ● &quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;dots&quot;, dotPattern);&#10;&#10;        String[] hashPattern = {&#10;            &quot;###&quot;,&#10;            &quot;# #&quot;,&#10;            &quot;###&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;hash&quot;, hashPattern);&#10;&#10;        String[] wavePattern = {&#10;            &quot;~~~&quot;,&#10;            &quot;   &quot;,&#10;            &quot;~~~&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;wave&quot;, wavePattern);&#10;&#10;        // Floor tiling patterns&#10;        String[] tilingFloorPattern = {&#10;            &quot;▓▓▓&quot;,&#10;            &quot;▓░▓&quot;,&#10;            &quot;▓▓▓&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;tiling_floor&quot;, tilingFloorPattern);&#10;&#10;        String[] checkerFloorPattern = {&#10;            &quot;██&quot;,&#10;            &quot;  &quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;checker_floor&quot;, checkerFloorPattern);&#10;&#10;        String[] grassFloorPattern = {&#10;            &quot;,,'&quot;,&#10;            &quot;',,&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;grass_floor&quot;, grassFloorPattern);&#10;&#10;        // Create a combined registry texture provider&#10;        RegistryTextureProvider registryProvider = new RegistryTextureProvider();&#10;&#10;        // Register picture textures (scaling)&#10;        registryProvider.addProvider(pictureProvider);&#10;&#10;        // Register tiling textures (repeating)&#10;        registryProvider.addProvider(tilingProvider);&#10;&#10;        // Set the combined provider&#10;        canvas.setTextureProvider(registryProvider);&#10;    }&#10;&#10;    /**&#10;     * Creates a floor texture demonstration map.&#10;     */&#10;    private static MapProvider createFloorTextureMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with different floor texture areas&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if (x &lt; 4) {&#10;                    // Stone floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .texture(&quot;stone_floor&quot;)&#10;                            .build();&#10;                } else if (x &lt; 8) {&#10;                    // Wooden floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('=')&#10;                            .name(&quot;Wood Floor&quot;)&#10;                            .colorLight(AnsiColor.YELLOW)&#10;                            .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                            .height(0.0)&#10;                            .texture(&quot;wood_floor&quot;)&#10;                            .build();&#10;                } else if (x &lt; 12) {&#10;                    // Tiled floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('▓')&#10;                            .name(&quot;Tiled Floor&quot;)&#10;                            .colorLight(AnsiColor.CYAN)&#10;                            .colorDark(AnsiColor.BLUE)&#10;                            .height(0.0)&#10;                            .texture(&quot;tiling_floor&quot;)&#10;                            .build();&#10;                } else {&#10;                    // Grass floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .texture(&quot;grass_floor&quot;)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some interior walls to showcase floor textures better&#10;        for (int y = 3; y &lt;= 8; y++) {&#10;            map[y][4] = EntryInfo.createWoodenWall();&#10;            map[y][8] = EntryInfo.createBrickWall();&#10;            map[y][12] = EntryInfo.createMetalWall();&#10;        }&#10;&#10;        // Add doorways&#10;        map[5][4] = EntryInfo.createFloor();&#10;        map[6][4] = EntryInfo.createFloor();&#10;        map[5][8] = EntryInfo.createFloor();&#10;        map[6][8] = EntryInfo.createFloor();&#10;        map[5][12] = EntryInfo.createFloor();&#10;        map[6][12] = EntryInfo.createFloor();&#10;&#10;        return new DefaultMapProvider(&quot;Floor Textures Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a checkerboard floor pattern map.&#10;     */&#10;    private static MapProvider createCheckerboardFloorMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Create checkerboard pattern&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 2 == 0) {&#10;                    // White squares&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('~')&#10;                            .name(&quot;White Tile&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                            .colorDark(AnsiColor.WHITE)&#10;                            .height(0.0)&#10;                            .texture(&quot;wave&quot;)&#10;                            .build();&#10;                } else {&#10;                    // Black squares&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Black Tile&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_BLACK)&#10;                            .colorDark(AnsiColor.BLACK)&#10;                            .height(0.0)&#10;                            .texture(&quot;checker_floor&quot;)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add a few interior walls&#10;        map[3][3] = EntryInfo.createBrickWall();&#10;        map[3][4] = EntryInfo.createBrickWall();&#10;        map[3][5] = EntryInfo.createBrickWall();&#10;        map[6][3] = EntryInfo.createWoodenWall();&#10;        map[6][4] = EntryInfo.createWoodenWall();&#10;        map[6][5] = EntryInfo.createWoodenWall();&#10;&#10;        return new DefaultMapProvider(&quot;Checkerboard Floor&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a map provider to demonstrate background colors.&#10;     */&#10;    private static MapProvider createBackgroundColorDemoMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][12];&#10;&#10;        // Initialize with floors having different background colors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if (x == 0 || x == map[y].length - 1 || y == 0 || y == map.length - 1) {&#10;                    // Border walls with background colors&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(true)&#10;                            .isWalkThrough(false)&#10;                            .isTransparent(false)&#10;                            .character('█')&#10;                            .name(&quot;Background Wall&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .backgroundColorLight(AnsiColor.BLUE)&#10;                            .backgroundColorDark(AnsiColor.CYAN)&#10;                            .height(1.0)&#10;                            .build();&#10;                } else {&#10;                    // Floor with different background color patterns&#10;                    AnsiColor bgColor = switch ((x + y) % 6) {&#10;                        case 0 -&gt; AnsiColor.RED;&#10;                        case 1 -&gt; AnsiColor.GREEN;&#10;                        case 2 -&gt; AnsiColor.BLUE;&#10;                        case 3 -&gt; AnsiColor.YELLOW;&#10;                        case 4 -&gt; AnsiColor.MAGENTA;&#10;                        default -&gt; AnsiColor.CYAN;&#10;                    };&#10;&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('·')&#10;                            .name(&quot;Colored Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_WHITE)&#10;                            .backgroundColorLight(bgColor)&#10;                            .backgroundColorDark(bgColor)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add some special walls with different background colors&#10;        EntryInfo redBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Red Background Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                .colorDark(AnsiColor.YELLOW)&#10;                .backgroundColorLight(AnsiColor.RED)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_RED)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo greenBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Green Background Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .backgroundColorLight(AnsiColor.GREEN)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_GREEN)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        EntryInfo purpleBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('░')&#10;                .name(&quot;Purple Background Wall&quot;)&#10;                .colorLight(AnsiColor.BLACK)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .backgroundColorLight(AnsiColor.MAGENTA)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        // Place special background walls&#10;        map[3][3] = redBgWall;&#10;        map[3][4] = redBgWall;&#10;        map[6][8] = greenBgWall;&#10;        map[7][8] = greenBgWall;&#10;        map[5][5] = purpleBgWall;&#10;        map[5][6] = purpleBgWall;&#10;&#10;        // Add glass walls with background colors&#10;        EntryInfo glassBg = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Colored Glass&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .backgroundColorLight(AnsiColor.BLUE)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_BLUE)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        map[2][7] = glassBg;&#10;        map[2][8] = glassBg;&#10;        map[8][3] = glassBg;&#10;        map[8][4] = glassBg;&#10;&#10;        return new DefaultMapProvider(&quot;Background Colors Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a map provider to demonstrate wall heights.&#10;     */&#10;    private static MapProvider createWallHeightDemoMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][12];&#10;&#10;        // Initialize with stone floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create border walls with standard height (1.0)&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Create walls with different heights to demonstrate the height feature&#10;&#10;        // Column 1: Low walls (minimum height 0.5)&#10;        EntryInfo lowWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▄')&#10;                .name(&quot;Low Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_BLACK)&#10;                .colorDark(AnsiColor.BLACK)&#10;                .height(EntryInfo.MIN_HEIGHT) // Uses minimum height constant&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][2] = lowWall;&#10;        }&#10;&#10;        // Column 2: Medium walls (0.7)&#10;        EntryInfo mediumWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Medium Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][4] = mediumWall;&#10;        }&#10;&#10;        // Column 3: Standard walls (1.0)&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][6] = EntryInfo.createStoneWall(); // Default height 1.0&#10;        }&#10;&#10;        // Column 4: Tall walls (1.5)&#10;        EntryInfo tallWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Tall Wall&quot;)&#10;                .colorLight(AnsiColor.RED)&#10;                .colorDark(AnsiColor.BRIGHT_RED)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][8] = tallWall;&#10;        }&#10;&#10;        // Column 5: Very tall walls (2.0)&#10;        EntryInfo veryTallWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Very Tall Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_MAGENTA)&#10;                .colorDark(AnsiColor.MAGENTA)&#10;                .height(2.0)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][10] = veryTallWall;&#10;        }&#10;&#10;        // Add some test walls with below-minimum height (should be clamped to MIN_HEIGHT)&#10;        EntryInfo belowMinWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('░')&#10;                .name(&quot;Below Min Wall&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.2) // Below minimum, should be clamped to 0.5&#10;                .build();&#10;&#10;        map[3][3] = belowMinWall;&#10;        map[3][5] = belowMinWall;&#10;&#10;        // Add trees with their natural height (1.3)&#10;        map[5][3] = EntryInfo.createTree();&#10;        map[5][5] = EntryInfo.createTree();&#10;        map[5][7] = EntryInfo.createTree();&#10;        map[5][9] = EntryInfo.createTree();&#10;&#10;        // Add mixed height walls for interesting visual effect&#10;        EntryInfo mixedWall1 = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Mixed Wall 1&quot;)&#10;                .colorLight(AnsiColor.GREEN)&#10;                .colorDark(AnsiColor.BRIGHT_GREEN)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo mixedWall2 = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Mixed Wall 2&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(1.3)&#10;                .build();&#10;&#10;        // Create a zigzag pattern with alternating heights&#10;        map[7][3] = mixedWall1;&#10;        map[7][4] = mixedWall2;&#10;        map[7][5] = mixedWall1;&#10;        map[7][6] = mixedWall2;&#10;        map[7][7] = mixedWall1;&#10;        map[7][8] = mixedWall2;&#10;        map[7][9] = mixedWall1;&#10;&#10;        return new DefaultMapProvider(&quot;Wall Heights Demo&quot;, map);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(80, 25);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 4,&#10;                    screen.getHeight() - 4,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 5, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0,&#10;                &quot;Raycasting Demo - First Person 3D World (MapProvider)\n&quot; +&#10;                &quot;WASD: Move | Arrows: Rotate/Fine Move | M: Change Map | R: Reset\n&quot; +&#10;                &quot;E: Toggle Wall Edges | T: Edge Threshold | C: Edge Style | Q/ESC: Exit&quot;,&#10;                Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setContent(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create raycasting canvas with MapProvider&#10;            raycastingCanvas = new RaycastingCanvas(&quot;Raycasting World&quot;, 0, 0, MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;            raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;            raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;            raycastingCanvas.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Setup texture provider&#10;            setupTextureProvider(raycastingCanvas);&#10;&#10;            // Create status panel&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.LEFT);&#10;            statusText.setForegroundColor(AnsiColor.WHITE);&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 3, new DefaultBorder());&#10;            statusBox.setContent(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add all components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(raycastingCanvas);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Position the main container&#10;            screen.setContent(mainContainer);&#10;&#10;            // Register keyboard shortcuts&#10;            registerKeyboardControls(screen);&#10;&#10;            // Create and start the process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                // Update status text with MapProvider information&#10;                statusText.setText(String.format(&#10;                    &quot;Position: (%.1f, %.1f) | Angle: %.0f° | %s | Map: %s (%d/%d)&quot;,&#10;                    raycastingCanvas.getPlayerX(),&#10;                    raycastingCanvas.getPlayerY(),&#10;                    Math.toDegrees(raycastingCanvas.getPlayerAngle()),&#10;                    lastAction,&#10;                    raycastingCanvas.getMapProvider().getName(),&#10;                    currentMapIndex + 1,&#10;                    MAP_PROVIDERS.length&#10;                ));&#10;            });&#10;&#10;            log.info(&quot;Starting Raycasting Demo with MapProvider...&quot;);&#10;            processLoop.start();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error initializing Raycasting Demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    private static void registerKeyboardControls(ScreenCanvas screen) {&#10;        double moveSpeed = 0.1;&#10;        double rotateSpeed = 0.1;&#10;&#10;        // Movement controls&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed);&#10;            lastAction = &quot;Move Forward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;S&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed);&#10;            lastAction = &quot;Move Backward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-moveSpeed);&#10;            lastAction = &quot;Strafe Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(moveSpeed);&#10;            lastAction = &quot;Strafe Right&quot;;&#10;        });&#10;&#10;        // Rotation controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-rotateSpeed);&#10;            lastAction = &quot;Rotate Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(rotateSpeed);&#10;            lastAction = &quot;Rotate Right&quot;;&#10;        });&#10;&#10;        // Wall edge controls&#10;        screen.registerShortcut(&quot;E&quot;, () -&gt; {&#10;            raycastingCanvas.setDrawWallEdges(!raycastingCanvas.isDrawWallEdges());&#10;            lastAction = &quot;Wall Edges toggled&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            raycastingCanvas.setWallEdgeThreshold(&#10;                raycastingCanvas.getWallEdgeThreshold() + 0.1 &gt; 1.0 ? 0.0 : raycastingCanvas.getWallEdgeThreshold() + 0.1&#10;            );&#10;            lastAction = &quot;Edge Threshold changed&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            currentWallEdgeStyleIndex = (currentWallEdgeStyleIndex + 1) % wallEdgeStyles.length;&#10;            raycastingCanvas.setWallEdgeChar(wallEdgeStyles[currentWallEdgeStyleIndex]);&#10;            lastAction = &quot;Edge Character changed&quot;;&#10;        });&#10;&#10;        // Map change - now uses MapProvider&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            currentMapIndex = (currentMapIndex + 1) % MAP_PROVIDERS.length;&#10;            raycastingCanvas.setMapProvider(MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            lastAction = &quot;Changed to &quot; + MAP_PROVIDERS[currentMapIndex].getName();&#10;        });&#10;&#10;        // Reset player&#10;        screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setPlayerAngle(0.0);&#10;            lastAction = &quot;Player Reset&quot;;&#10;        });&#10;&#10;        // Fine movement controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed * 0.5);&#10;            lastAction = &quot;Move Forward (Slow)&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed * 0.5);&#10;            lastAction = &quot;Move Backward (Slow)&quot;;&#10;        });&#10;&#10;        // Exit&#10;        screen.registerShortcut(&quot;Q&quot;, () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESCAPE.name(), () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;    }&#10;&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Text buttonText = new Text(&quot;buttonText&quot;, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        buttonText.setBold(true);&#10;&#10;        Box button = new Box(&quot;button&quot;, 12, 3, new DefaultBorder());&#10;        button.setContent(buttonText);&#10;&#10;        return button;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.BorderLayout;&#10;import com.consolemaster.Box;&#10;import com.consolemaster.Composite;&#10;import com.consolemaster.DefaultBorder;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.PositionConstraint;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.Text;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.DefaultMapProvider;&#10;import com.consolemaster.raycasting.MapProvider;&#10;import com.consolemaster.raycasting.EntryInfo;&#10;import com.consolemaster.raycasting.PictureTextureProvider;&#10;import com.consolemaster.raycasting.RegistryTextureProvider;&#10;import com.consolemaster.raycasting.TilingTextureProvider;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive raycasting demo showcasing first-person 3D perspective in a 2D world.&#10; * Features player movement, rotation, and different map environments using MapProvider.&#10; */&#10;@Slf4j&#10;public class RaycastingDemo {&#10;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static RaycastingCanvas raycastingCanvas;&#10;    private static int currentMapIndex = 0;&#10;    private static final char[] wallEdgeStyles = {'│', '#', '*', '+'};&#10;    private static int currentWallEdgeStyleIndex = 0;&#10;&#10;    // Different map providers to showcase&#10;    private static final MapProvider[] MAP_PROVIDERS = {&#10;        // Simple map with basic walls and floors&#10;        new DefaultMapProvider(&quot;Simple Maze&quot;, new String[]{&#10;            &quot;########&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;#  ##  #&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;########&quot;&#10;        }),&#10;&#10;        // Advanced map with different EntryInfo types&#10;        createAdvancedMapProvider(),&#10;&#10;        // Textured map with various textures&#10;        createTexturedMapProvider(),&#10;&#10;        // Tiling texture demonstration map&#10;        createTilingTextureMapProvider(),&#10;&#10;        // Complex maze map&#10;        new DefaultMapProvider(&quot;Complex Maze&quot;, new String[]{&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# #### ## #### #&quot;,&#10;            &quot;#    #    #    #&quot;,&#10;            &quot;#### # ## # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# ## #### ## # #&quot;,&#10;            &quot;#  #      #  # #&quot;,&#10;            &quot;## # #### # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        }),&#10;&#10;        // Natural landscape with water and grass&#10;        createNaturalLandscapeProvider(),&#10;&#10;        // Castle dungeon with mixed entry types&#10;        createCastleMapProvider(),&#10;&#10;        // Floor texture demonstration map&#10;        createFloorTextureMapProvider(),&#10;&#10;        // Checkerboard floor pattern map&#10;        createCheckerboardFloorMapProvider(),&#10;&#10;        // Background color demonstration map&#10;        createBackgroundColorDemoMapProvider(),&#10;&#10;        // Wall height demonstration map&#10;        createWallHeightDemoMapProvider(),&#10;&#10;        // Large area with ascending wall heights in center&#10;        createLargeAreaWithAscendingHeightsMapProvider()&#10;    };&#10;&#10;    /**&#10;     * Creates an advanced map provider showcasing different EntryInfo features.&#10;     */&#10;    private static MapProvider createAdvancedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[8][12];&#10;&#10;        // Initialize with different floor types&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 3 == 0) {&#10;                    // Stone floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else if ((x + y) % 3 == 1) {&#10;                    // Grass floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else {&#10;                    // Sand floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('°')&#10;                            .name(&quot;Sand Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                            .colorDark(AnsiColor.YELLOW)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create walls around the border using stone walls&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some glass walls (transparent but blocking)&#10;        map[2][3] = EntryInfo.createGlass();&#10;        map[2][4] = EntryInfo.createGlass();&#10;        map[2][5] = EntryInfo.createGlass();&#10;&#10;        // Add low walls (half height)&#10;        map[4][2] = EntryInfo.createLowWall();&#10;        map[4][3] = EntryInfo.createLowWall();&#10;        map[5][2] = EntryInfo.createLowWall();&#10;        map[5][3] = EntryInfo.createLowWall();&#10;&#10;        // Add brick walls with proper light/dark colors&#10;        map[3][7] = EntryInfo.createBrickWall();&#10;        map[3][8] = EntryInfo.createBrickWall();&#10;        map[4][7] = EntryInfo.createBrickWall();&#10;        map[4][8] = EntryInfo.createBrickWall();&#10;&#10;        // Add metal walls&#10;        map[6][7] = EntryInfo.createMetalWall();&#10;        map[6][8] = EntryInfo.createMetalWall();&#10;&#10;        // Add custom colored walls with specific light/dark combinations&#10;        EntryInfo greenWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Green Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo purpleWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Purple Wall&quot;)&#10;                .colorLight(AnsiColor.MAGENTA)&#10;                .colorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        map[6][4] = greenWall;&#10;        map[6][5] = greenWall;&#10;        map[5][9] = purpleWall;&#10;        map[6][9] = purpleWall;&#10;&#10;        // Add water area (blue floor)&#10;        EntryInfo water = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isWalkThrough(true)&#10;                .isTransparent(true)&#10;                .character('~')&#10;                .name(&quot;Water&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(0.0)&#10;                .build();&#10;&#10;        map[3][9] = water;&#10;        map[3][10] = water;&#10;        map[4][9] = water;&#10;        map[4][10] = water;&#10;&#10;        return new DefaultMapProvider(&quot;Advanced Features&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a castle map with various EntryInfo types.&#10;     */&#10;    private static MapProvider createCastleMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with floors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create outer walls with stone&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add castle features with enhanced colors&#10;        EntryInfo tower = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('♦')&#10;                .name(&quot;Tower&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        EntryInfo gate = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isWalkThrough(true)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Gate&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo courtyard = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Courtyard Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        // Place towers&#10;        map[2][2] = tower;&#10;        map[2][13] = tower;&#10;        map[9][2] = tower;&#10;        map[9][13] = tower;&#10;&#10;        // Create gates&#10;        map[5][0] = gate;&#10;        map[6][0] = gate;&#10;&#10;        // Add interior walls with different materials&#10;        for (int x = 4; x &lt; 12; x++) {&#10;            if (x != 7 &amp;&amp; x != 8) { // Leave doorway&#10;                if (x &lt; 8) {&#10;                    map[5][x] = EntryInfo.createBrickWall();&#10;                } else {&#10;                    map[5][x] = EntryInfo.createMetalWall();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add courtyard walls&#10;        map[7][3] = courtyard;&#10;        map[8][3] = courtyard;&#10;        map[7][12] = courtyard;&#10;        map[8][12] = courtyard;&#10;&#10;        return new DefaultMapProvider(&quot;Castle&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a natural landscape map with water and grass.&#10;     */&#10;    private static MapProvider createNaturalLandscapeProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][14];&#10;&#10;        // Initialize with grass floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass Floor&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create water areas&#10;        for (int y = 2; y &lt;= 3; y++) {&#10;            for (int x = 4; x &lt;= 9; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create island with trees&#10;        for (int y = 1; y &lt;= 8; y++) {&#10;            for (int x = 1; x &lt;= 12; x++) {&#10;                if (x == 1 || x == 12 || y == 1 || y == 8) {&#10;                    map[y][x] = EntryInfo.createStoneWall();&#10;                } else if ((x + y) % 4 == 0) {&#10;                    map[y][x] = EntryInfo.createTree();&#10;                }&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Natural Landscape&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a textured map provider showcasing various textures.&#10;     */&#10;    private static MapProvider createTexturedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some wooden walls&#10;        for (int i = 2; i &lt; 8; i++) {&#10;            map[i][3] = EntryInfo.createWoodenWall();&#10;            map[i][6] = EntryInfo.createWoodenWall();&#10;        }&#10;&#10;        // Add a water area&#10;        for (int y = 4; y &lt;= 5; y++) {&#10;            for (int x = 1; x &lt;= 8; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Textured Map&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a tiling texture map provider showcasing various tiling textures.&#10;     */&#10;    private static MapProvider createTilingTextureMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][12];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isWalkThrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Create different sections to showcase tiling textures&#10;&#10;        // Left section: Tiling brick walls&#10;        for (int y = 2; y &lt;= 5; y++) {&#10;            map[y][3] = EntryInfo.createTilingBrickWall();&#10;        }&#10;&#10;        // Right section: Dotted walls&#10;        for (int y = 2; y &lt;= 5; y++) {&#10;            map[y][8] = EntryInfo.createDottedWall();&#10;        }&#10;&#10;        // Center section: Hash pattern walls&#10;        for (int x = 4; x &lt;= 7; x++) {&#10;            map[3][x] = EntryInfo.createHashWall();&#10;        }&#10;&#10;        // Bottom section: Wave pattern walls&#10;        for (int x = 4; x &lt;= 7; x++) {&#10;            map[8][x] = EntryInfo.createWaveWall();&#10;        }&#10;&#10;        // Add some traditional scaling textured walls for comparison&#10;        map[6][3] = EntryInfo.createWoodenWall(); // Uses scaling texture&#10;        map[6][8] = EntryInfo.createBrickWall();  // Uses scaling texture&#10;&#10;        return new DefaultMapProvider(&quot;Tiling Texture Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Sets up the texture provider for the raycasting canvas.&#10;     */&#10;    private static void setupTextureProvider(RaycastingCanvas canvas) {&#10;        // Create a picture texture provider with various textures (scaling)&#10;        PictureTextureProvider pictureProvider = new PictureTextureProvider();&#10;&#10;        // Create a tiling texture provider with repeating patterns&#10;        TilingTextureProvider tilingProvider = new TilingTextureProvider();&#10;&#10;        // Add wood texture (scaling)&#10;        String[] woodTexture = {&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood&quot;, woodTexture);&#10;&#10;        // Add brick texture (scaling)&#10;        String[] brickTexture = {&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;brick&quot;, brickTexture);&#10;&#10;        // Add stone texture (scaling)&#10;        String[] stoneTexture = {&#10;            &quot;█▓▒░░▒▓█&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;░      ░&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;█▓▒░░▒▓█&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone&quot;, stoneTexture);&#10;&#10;        // Add metal texture (scaling)&#10;        String[] metalTexture = {&#10;            &quot;========&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;--------&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;========&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;metal&quot;, metalTexture);&#10;&#10;        // ===== FLOOR TEXTURES =====&#10;&#10;        // Add simple floor texture pattern&#10;        String[] floorTexture = {&#10;            &quot;░░▒▒░░&quot;,&#10;            &quot;░▒▓▓▒░&quot;,&#10;            &quot;▒▓██▓▒&quot;,&#10;            &quot;▒▓██▓▒&quot;,&#10;            &quot;░▒▓▓▒░&quot;,&#10;            &quot;░░▒▒░░&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;floor&quot;, floorTexture);&#10;&#10;        // Add stone floor texture&#10;        String[] stoneFloorTexture = {&#10;            &quot;▓▓░░▓▓&quot;,&#10;            &quot;▓░  ░▓&quot;,&#10;            &quot;░    ░&quot;,&#10;            &quot;░    ░&quot;,&#10;            &quot;▓░  ░▓&quot;,&#10;            &quot;▓▓░░▓▓&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone_floor&quot;, stoneFloorTexture);&#10;&#10;        // Add wooden floor texture&#10;        String[] woodFloorTexture = {&#10;            &quot;|||||||&quot;,&#10;            &quot;-------&quot;,&#10;            &quot;|||||||&quot;,&#10;            &quot;-------&quot;,&#10;            &quot;|||||||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood_floor&quot;, woodFloorTexture);&#10;&#10;        // Add tiling patterns that look better when repeated&#10;        String[] tilingBrickPattern = {&#10;            &quot;██  ██&quot;,&#10;            &quot;  ██  &quot;,&#10;            &quot;██  ██&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;tiling_brick&quot;, tilingBrickPattern);&#10;&#10;        String[] dotPattern = {&#10;            &quot; ● &quot;,&#10;            &quot;   &quot;,&#10;            &quot; ● &quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;dots&quot;, dotPattern);&#10;&#10;        String[] hashPattern = {&#10;            &quot;###&quot;,&#10;            &quot;# #&quot;,&#10;            &quot;###&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;hash&quot;, hashPattern);&#10;&#10;        String[] wavePattern = {&#10;            &quot;~~~&quot;,&#10;            &quot;   &quot;,&#10;            &quot;~~~&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;wave&quot;, wavePattern);&#10;&#10;        // Floor tiling patterns&#10;        String[] tilingFloorPattern = {&#10;            &quot;▓▓▓&quot;,&#10;            &quot;▓░▓&quot;,&#10;            &quot;▓▓▓&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;tiling_floor&quot;, tilingFloorPattern);&#10;&#10;        String[] checkerFloorPattern = {&#10;            &quot;██&quot;,&#10;            &quot;  &quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;checker_floor&quot;, checkerFloorPattern);&#10;&#10;        String[] grassFloorPattern = {&#10;            &quot;,,'&quot;,&#10;            &quot;',,&quot;&#10;        };&#10;        tilingProvider.addTexture(&quot;grass_floor&quot;, grassFloorPattern);&#10;&#10;        // Create a combined registry texture provider&#10;        RegistryTextureProvider registryProvider = new RegistryTextureProvider();&#10;&#10;        // Register picture textures (scaling)&#10;        registryProvider.addProvider(pictureProvider);&#10;&#10;        // Register tiling textures (repeating)&#10;        registryProvider.addProvider(tilingProvider);&#10;&#10;        // Set the combined provider&#10;        canvas.setTextureProvider(registryProvider);&#10;    }&#10;&#10;    /**&#10;     * Creates a floor texture demonstration map.&#10;     */&#10;    private static MapProvider createFloorTextureMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with different floor texture areas&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if (x &lt; 4) {&#10;                    // Stone floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .texture(&quot;stone_floor&quot;)&#10;                            .build();&#10;                } else if (x &lt; 8) {&#10;                    // Wooden floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('=')&#10;                            .name(&quot;Wood Floor&quot;)&#10;                            .colorLight(AnsiColor.YELLOW)&#10;                            .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                            .height(0.0)&#10;                            .texture(&quot;wood_floor&quot;)&#10;                            .build();&#10;                } else if (x &lt; 12) {&#10;                    // Tiled floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('▓')&#10;                            .name(&quot;Tiled Floor&quot;)&#10;                            .colorLight(AnsiColor.CYAN)&#10;                            .colorDark(AnsiColor.BLUE)&#10;                            .height(0.0)&#10;                            .texture(&quot;tiling_floor&quot;)&#10;                            .build();&#10;                } else {&#10;                    // Grass floor area&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .texture(&quot;grass_floor&quot;)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some interior walls to showcase floor textures better&#10;        for (int y = 3; y &lt;= 8; y++) {&#10;            map[y][4] = EntryInfo.createWoodenWall();&#10;            map[y][8] = EntryInfo.createBrickWall();&#10;            map[y][12] = EntryInfo.createMetalWall();&#10;        }&#10;&#10;        // Add doorways&#10;        map[5][4] = EntryInfo.createFloor();&#10;        map[6][4] = EntryInfo.createFloor();&#10;        map[5][8] = EntryInfo.createFloor();&#10;        map[6][8] = EntryInfo.createFloor();&#10;        map[5][12] = EntryInfo.createFloor();&#10;        map[6][12] = EntryInfo.createFloor();&#10;&#10;        return new DefaultMapProvider(&quot;Floor Textures Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a checkerboard floor pattern map.&#10;     */&#10;    private static MapProvider createCheckerboardFloorMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Create checkerboard pattern&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 2 == 0) {&#10;                    // White squares&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('~')&#10;                            .name(&quot;White Tile&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                            .colorDark(AnsiColor.WHITE)&#10;                            .height(0.0)&#10;                            .texture(&quot;wave&quot;)&#10;                            .build();&#10;                } else {&#10;                    // Black squares&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Black Tile&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_BLACK)&#10;                            .colorDark(AnsiColor.BLACK)&#10;                            .height(0.0)&#10;                            .texture(&quot;checker_floor&quot;)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add a few interior walls&#10;        map[3][3] = EntryInfo.createBrickWall();&#10;        map[3][4] = EntryInfo.createBrickWall();&#10;        map[3][5] = EntryInfo.createBrickWall();&#10;        map[6][3] = EntryInfo.createWoodenWall();&#10;        map[6][4] = EntryInfo.createWoodenWall();&#10;        map[6][5] = EntryInfo.createWoodenWall();&#10;&#10;        return new DefaultMapProvider(&quot;Checkerboard Floor&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a map provider to demonstrate background colors.&#10;     */&#10;    private static MapProvider createBackgroundColorDemoMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][12];&#10;&#10;        // Initialize with floors having different background colors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if (x == 0 || x == map[y].length - 1 || y == 0 || y == map.length - 1) {&#10;                    // Border walls with background colors&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(true)&#10;                            .isWalkThrough(false)&#10;                            .isTransparent(false)&#10;                            .character('█')&#10;                            .name(&quot;Background Wall&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .backgroundColorLight(AnsiColor.BLUE)&#10;                            .backgroundColorDark(AnsiColor.CYAN)&#10;                            .height(1.0)&#10;                            .build();&#10;                } else {&#10;                    // Floor with different background color patterns&#10;                    AnsiColor bgColor = switch ((x + y) % 6) {&#10;                        case 0 -&gt; AnsiColor.RED;&#10;                        case 1 -&gt; AnsiColor.GREEN;&#10;                        case 2 -&gt; AnsiColor.BLUE;&#10;                        case 3 -&gt; AnsiColor.YELLOW;&#10;                        case 4 -&gt; AnsiColor.MAGENTA;&#10;                        default -&gt; AnsiColor.CYAN;&#10;                    };&#10;&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isWalkThrough(true)&#10;                            .isTransparent(true)&#10;                            .character('·')&#10;                            .name(&quot;Colored Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_WHITE)&#10;                            .backgroundColorLight(bgColor)&#10;                            .backgroundColorDark(bgColor)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add some special walls with different background colors&#10;        EntryInfo redBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Red Background Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                .colorDark(AnsiColor.YELLOW)&#10;                .backgroundColorLight(AnsiColor.RED)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_RED)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo greenBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Green Background Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .backgroundColorLight(AnsiColor.GREEN)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_GREEN)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        EntryInfo purpleBgWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('░')&#10;                .name(&quot;Purple Background Wall&quot;)&#10;                .colorLight(AnsiColor.BLACK)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .backgroundColorLight(AnsiColor.MAGENTA)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        // Place special background walls&#10;        map[3][3] = redBgWall;&#10;        map[3][4] = redBgWall;&#10;        map[6][8] = greenBgWall;&#10;        map[7][8] = greenBgWall;&#10;        map[5][5] = purpleBgWall;&#10;        map[5][6] = purpleBgWall;&#10;&#10;        // Add glass walls with background colors&#10;        EntryInfo glassBg = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Colored Glass&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .backgroundColorLight(AnsiColor.BLUE)&#10;                .backgroundColorDark(AnsiColor.BRIGHT_BLUE)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        map[2][7] = glassBg;&#10;        map[2][8] = glassBg;&#10;        map[8][3] = glassBg;&#10;        map[8][4] = glassBg;&#10;&#10;        return new DefaultMapProvider(&quot;Background Colors Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a map provider to demonstrate wall heights.&#10;     */&#10;    private static MapProvider createWallHeightDemoMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][12];&#10;&#10;        // Initialize with stone floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create border walls with standard height (1.0)&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Create walls with different heights to demonstrate the height feature&#10;&#10;        // Column 1: Low walls (minimum height 0.5)&#10;        EntryInfo lowWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▄')&#10;                .name(&quot;Low Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_BLACK)&#10;                .colorDark(AnsiColor.BLACK)&#10;                .height(EntryInfo.MIN_HEIGHT) // Uses minimum height constant&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][2] = lowWall;&#10;        }&#10;&#10;        // Column 2: Medium walls (0.7)&#10;        EntryInfo mediumWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Medium Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][4] = mediumWall;&#10;        }&#10;&#10;        // Column 3: Standard walls (1.0)&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][6] = EntryInfo.createStoneWall(); // Default height 1.0&#10;        }&#10;&#10;        // Column 4: Tall walls (1.5)&#10;        EntryInfo tallWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Tall Wall&quot;)&#10;                .colorLight(AnsiColor.RED)&#10;                .colorDark(AnsiColor.BRIGHT_RED)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][8] = tallWall;&#10;        }&#10;&#10;        // Column 5: Very tall walls (2.0)&#10;        EntryInfo veryTallWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Very Tall Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_MAGENTA)&#10;                .colorDark(AnsiColor.MAGENTA)&#10;                .height(2.0)&#10;                .build();&#10;&#10;        for (int y = 2; y &lt;= 7; y++) {&#10;            map[y][10] = veryTallWall;&#10;        }&#10;&#10;        // Add some test walls with below-minimum height (should be clamped to MIN_HEIGHT)&#10;        EntryInfo belowMinWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('░')&#10;                .name(&quot;Below Min Wall&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.2) // Below minimum, should be clamped to 0.5&#10;                .build();&#10;&#10;        map[3][3] = belowMinWall;&#10;        map[3][5] = belowMinWall;&#10;&#10;        // Add trees with their natural height (1.3)&#10;        map[5][3] = EntryInfo.createTree();&#10;        map[5][5] = EntryInfo.createTree();&#10;        map[5][7] = EntryInfo.createTree();&#10;        map[5][9] = EntryInfo.createTree();&#10;&#10;        // Add mixed height walls for interesting visual effect&#10;        EntryInfo mixedWall1 = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Mixed Wall 1&quot;)&#10;                .colorLight(AnsiColor.GREEN)&#10;                .colorDark(AnsiColor.BRIGHT_GREEN)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo mixedWall2 = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Mixed Wall 2&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(1.3)&#10;                .build();&#10;&#10;        // Create a zigzag pattern with alternating heights&#10;        map[7][3] = mixedWall1;&#10;        map[7][4] = mixedWall2;&#10;        map[7][5] = mixedWall1;&#10;        map[7][6] = mixedWall2;&#10;        map[7][7] = mixedWall1;&#10;        map[7][8] = mixedWall2;&#10;        map[7][9] = mixedWall1;&#10;&#10;        return new DefaultMapProvider(&quot;Wall Heights Demo&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a map provider with a large area and ascending wall heights.&#10;     */&#10;    private static MapProvider createLargeAreaWithAscendingHeightsMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[15][20];&#10;&#10;        // Initialize with stone floor for the entire area&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create very tall border walls (height 5.0) around the entire perimeter&#10;        EntryInfo tallBorderWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Tall Border Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .height(5.0)&#10;                .build();&#10;&#10;        // Top and bottom borders&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = tallBorderWall;&#10;            map[map.length - 1][x] = tallBorderWall;&#10;        }&#10;        // Left and right borders&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = tallBorderWall;&#10;            map[y][map[0].length - 1] = tallBorderWall;&#10;        }&#10;&#10;        // Create 3x3 grid of walls in the center with ascending heights&#10;        int centerX = map[0].length / 2 - 1; // Start position for 3x3 grid&#10;        int centerY = map.length / 2 - 1;&#10;&#10;        // Heights for the 3x3 grid (ascending from 0.6 to 3.0)&#10;        double[][] heights = {&#10;            {0.6, 0.8, 1.0},&#10;            {1.2, 1.5, 1.8},&#10;            {2.1, 2.5, 3.0}&#10;        };&#10;&#10;        // Colors for visual variety&#10;        AnsiColor[][] colors = {&#10;            {AnsiColor.YELLOW, AnsiColor.BRIGHT_YELLOW, AnsiColor.GREEN},&#10;            {AnsiColor.BRIGHT_GREEN, AnsiColor.CYAN, AnsiColor.BRIGHT_CYAN},&#10;            {AnsiColor.BLUE, AnsiColor.MAGENTA, AnsiColor.BRIGHT_MAGENTA}&#10;        };&#10;&#10;        // Characters for visual variety&#10;        char[][] characters = {&#10;            {'▄', '▓', '█'},&#10;            {'▒', '█', '▓'},&#10;            {'█', '▓', '█'}&#10;        };&#10;&#10;        // Place the 3x3 ascending height walls&#10;        for (int gridY = 0; gridY &lt; 3; gridY++) {&#10;            for (int gridX = 0; gridX &lt; 3; gridX++) {&#10;                int mapX = centerX + gridX;&#10;                int mapY = centerY + gridY;&#10;&#10;                map[mapY][mapX] = EntryInfo.builder()&#10;                        .isWall(true)&#10;                        .isWalkThrough(false)&#10;                        .isTransparent(false)&#10;                        .character(characters[gridY][gridX])&#10;                        .name(&quot;Ascending Wall &quot; + (gridY * 3 + gridX + 1))&#10;                        .colorLight(colors[gridY][gridX])&#10;                        .colorDark(colors[gridY][gridX])&#10;                        .height(heights[gridY][gridX])&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add some decorative elements around the center for better spatial orientation&#10;        &#10;        // Add trees in corners of the large area&#10;        EntryInfo decorativeTree = EntryInfo.createTree();&#10;        map[3][3] = decorativeTree;&#10;        map[3][map[0].length - 4] = decorativeTree;&#10;        map[map.length - 4][3] = decorativeTree;&#10;        map[map.length - 4][map[0].length - 4] = decorativeTree;&#10;&#10;        // Add low walls to create pathways&#10;        EntryInfo lowPathWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isWalkThrough(false)&#10;                .isTransparent(false)&#10;                .character('▄')&#10;                .name(&quot;Path Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_BLACK)&#10;                .colorDark(AnsiColor.BLACK)&#10;                .height(0.5)&#10;                .build();&#10;&#10;        // Create cross-shaped pathways leading to the center&#10;        for (int x = centerX - 2; x &lt;= centerX + 4; x++) {&#10;            if (x &gt;= 2 &amp;&amp; x &lt; map[0].length - 2 &amp;&amp; &#10;                (x &lt; centerX || x &gt; centerX + 2)) { // Don't block the 3x3 center&#10;                map[centerY + 1][x] = lowPathWall;&#10;            }&#10;        }&#10;        for (int y = centerY - 2; y &lt;= centerY + 4; y++) {&#10;            if (y &gt;= 2 &amp;&amp; y &lt; map.length - 2 &amp;&amp; &#10;                (y &lt; centerY || y &gt; centerY + 2)) { // Don't block the 3x3 center&#10;                map[y][centerX + 1] = lowPathWall;&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Large Area with Ascending Heights&quot;, map);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(80, 25);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 4,&#10;                    screen.getHeight() - 4,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 5, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0,&#10;                &quot;Raycasting Demo - First Person 3D World (MapProvider)\n&quot; +&#10;                &quot;WASD: Move | Arrows: Rotate/Fine Move | M: Change Map | R: Reset\n&quot; +&#10;                &quot;E: Toggle Wall Edges | T: Edge Threshold | C: Edge Style | Q/ESC: Exit&quot;,&#10;                Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setContent(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create raycasting canvas with MapProvider&#10;            raycastingCanvas = new RaycastingCanvas(&quot;Raycasting World&quot;, 0, 0, MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;            raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;            raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;            raycastingCanvas.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Setup texture provider&#10;            setupTextureProvider(raycastingCanvas);&#10;&#10;            // Create status panel&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.LEFT);&#10;            statusText.setForegroundColor(AnsiColor.WHITE);&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 3, new DefaultBorder());&#10;            statusBox.setContent(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add all components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(raycastingCanvas);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Position the main container&#10;            screen.setContent(mainContainer);&#10;&#10;            // Register keyboard shortcuts&#10;            registerKeyboardControls(screen);&#10;&#10;            // Create and start the process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                // Update status text with MapProvider information&#10;                statusText.setText(String.format(&#10;                    &quot;Position: (%.1f, %.1f) | Angle: %.0f° | %s | Map: %s (%d/%d)&quot;,&#10;                    raycastingCanvas.getPlayerX(),&#10;                    raycastingCanvas.getPlayerY(),&#10;                    Math.toDegrees(raycastingCanvas.getPlayerAngle()),&#10;                    lastAction,&#10;                    raycastingCanvas.getMapProvider().getName(),&#10;                    currentMapIndex + 1,&#10;                    MAP_PROVIDERS.length&#10;                ));&#10;            });&#10;&#10;            log.info(&quot;Starting Raycasting Demo with MapProvider...&quot;);&#10;            processLoop.start();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error initializing Raycasting Demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    private static void registerKeyboardControls(ScreenCanvas screen) {&#10;        double moveSpeed = 0.1;&#10;        double rotateSpeed = 0.1;&#10;&#10;        // Movement controls&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed);&#10;            lastAction = &quot;Move Forward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;S&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed);&#10;            lastAction = &quot;Move Backward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-moveSpeed);&#10;            lastAction = &quot;Strafe Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(moveSpeed);&#10;            lastAction = &quot;Strafe Right&quot;;&#10;        });&#10;&#10;        // Rotation controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-rotateSpeed);&#10;            lastAction = &quot;Rotate Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(rotateSpeed);&#10;            lastAction = &quot;Rotate Right&quot;;&#10;        });&#10;&#10;        // Wall edge controls&#10;        screen.registerShortcut(&quot;E&quot;, () -&gt; {&#10;            raycastingCanvas.setDrawWallEdges(!raycastingCanvas.isDrawWallEdges());&#10;            lastAction = &quot;Wall Edges toggled&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            raycastingCanvas.setWallEdgeThreshold(&#10;                raycastingCanvas.getWallEdgeThreshold() + 0.1 &gt; 1.0 ? 0.0 : raycastingCanvas.getWallEdgeThreshold() + 0.1&#10;            );&#10;            lastAction = &quot;Edge Threshold changed&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            currentWallEdgeStyleIndex = (currentWallEdgeStyleIndex + 1) % wallEdgeStyles.length;&#10;            raycastingCanvas.setWallEdgeChar(wallEdgeStyles[currentWallEdgeStyleIndex]);&#10;            lastAction = &quot;Edge Character changed&quot;;&#10;        });&#10;&#10;        // Map change - now uses MapProvider&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            currentMapIndex = (currentMapIndex + 1) % MAP_PROVIDERS.length;&#10;            raycastingCanvas.setMapProvider(MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            lastAction = &quot;Changed to &quot; + MAP_PROVIDERS[currentMapIndex].getName();&#10;        });&#10;&#10;        // Reset player&#10;        screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setPlayerAngle(0.0);&#10;            lastAction = &quot;Player Reset&quot;;&#10;        });&#10;&#10;        // Fine movement controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed * 0.5);&#10;            lastAction = &quot;Move Forward (Slow)&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed * 0.5);&#10;            lastAction = &quot;Move Backward (Slow)&quot;;&#10;        });&#10;&#10;        // Exit&#10;        screen.registerShortcut(&quot;Q&quot;, () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESCAPE.name(), () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;    }&#10;&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Text buttonText = new Text(&quot;buttonText&quot;, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        buttonText.setBold(true);&#10;&#10;        Box button = new Box(&quot;button&quot;, 12, 3, new DefaultBorder());&#10;        button.setContent(buttonText);&#10;&#10;        return button;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/TilingTextureProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/TilingTextureProvider.java" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * A texture provider that manages tiling textures from string arrays.&#10; * Instead of scaling textures to fit dimensions, this provider tiles/repeats patterns.&#10; * Acts as a transformator that creates tiling textures with specified dimensions and parameters.&#10; */&#10;public class TilingTextureProvider implements TextureProvider {&#10;&#10;    private final Map&lt;String, String[]&gt; textureDataMap = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Adds a texture to this provider.&#10;     * &#10;     * @param path the path/name for the texture&#10;     * @param textureData the string array representing the texture pattern&#10;     */&#10;    public void addTexture(String path, String[] textureData) {&#10;        if (path != null &amp;&amp; textureData != null) {&#10;            textureDataMap.put(path, textureData.clone());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Texture getTexture(String path, int width, int height, EntryInfo entry, boolean light) {&#10;        String[] textureData = textureDataMap.get(path);&#10;        if (textureData == null) {&#10;            return null;&#10;        }&#10;        &#10;        return new TilingTexture(path, textureData, width, height, entry, light);&#10;    }&#10;&#10;    /**&#10;     * Removes a texture from this provider.&#10;     * &#10;     * @param path the path of the texture to remove&#10;     * @return true if the texture was removed, false if not found&#10;     */&#10;    public boolean removeTexture(String path) {&#10;        return textureDataMap.remove(path) != null;&#10;    }&#10;&#10;    /**&#10;     * Checks if this provider has a texture with the given path.&#10;     * &#10;     * @param path the path to check&#10;     * @return true if the texture exists&#10;     */&#10;    public boolean hasTexture(String path) {&#10;        return textureDataMap.containsKey(path);&#10;    }&#10;&#10;    /**&#10;     * Gets all texture paths managed by this provider.&#10;     * &#10;     * @return array of texture paths&#10;     */&#10;    public String[] getTexturePaths() {&#10;        return textureDataMap.keySet().toArray(new String[0]);&#10;    }&#10;&#10;    /**&#10;     * Clears all textures from this provider.&#10;     */&#10;    public void clear() {&#10;        textureDataMap.clear();&#10;    }&#10;&#10;    /**&#10;     * Gets the source dimensions of a texture pattern.&#10;     * &#10;     * @param path the texture path&#10;     * @return array with [width, height] or null if texture not found&#10;     */&#10;    public int[] getSourceDimensions(String path) {&#10;        String[] textureData = textureDataMap.get(path);&#10;        if (textureData == null || textureData.length == 0) {&#10;            return null;&#10;        }&#10;        &#10;        int height = textureData.length;&#10;        int width = textureData[0].length();&#10;        return new int[]{width, height};&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>