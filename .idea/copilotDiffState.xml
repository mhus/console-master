<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/ScreenCanvas.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/ScreenCanvas.java" />
              <option name="originalContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;import org.jline.terminal.Terminal;&#10;import org.jline.terminal.TerminalBuilder;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * The main entry point canvas for the console application.&#10; * Manages the console terminal and handles minimum size requirements.&#10; */&#10;@Getter&#10;@Setter&#10;public class ScreenCanvas extends CompositeCanvas {&#10;&#10;    private static final int DEFAULT_MIN_WIDTH = 80;&#10;    private static final int DEFAULT_MIN_HEIGHT = 24;&#10;&#10;    private final Terminal terminal;&#10;    private final int minWidth;&#10;    private final int minHeight;&#10;    private Canvas warningCanvas;&#10;    private Canvas contentCanvas;&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with default minimum size requirements.&#10;     */&#10;    public ScreenCanvas() throws IOException {&#10;        this(DEFAULT_MIN_WIDTH, DEFAULT_MIN_HEIGHT);&#10;    }&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with specified minimum size requirements.&#10;     */&#10;    public ScreenCanvas(int minWidth, int minHeight) throws IOException {&#10;        super(0, 0, 0, 0);&#10;        this.minWidth = minWidth;&#10;        this.minHeight = minHeight;&#10;        this.terminal = TerminalBuilder.builder().system(true).build();&#10;&#10;        // Initialize screen dimensions&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;&#10;        // Create warning canvas&#10;        createWarningCanvas();&#10;        updateDisplay();&#10;    }&#10;&#10;    public void setContentCanvas(Canvas contentCanvas) {&#10;        if (this.contentCanvas != null) {&#10;            removeChild(this.contentCanvas);&#10;        }&#10;        this.contentCanvas = contentCanvas;&#10;        updateDisplay();&#10;    }&#10;&#10;    public void updateSize() {&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;        updateDisplay();&#10;    }&#10;&#10;    public void render() {&#10;        JLineGraphics graphics = new JLineGraphics(getWidth(), getHeight());&#10;        graphics.clear();&#10;        paint(graphics);&#10;&#10;        // Use JLine's efficient AttributedString output&#10;        terminal.writer().print(&quot;\033[2J\033[H&quot;); // Clear screen and move cursor to top&#10;        terminal.writer().print(graphics.toAttributedString().toAnsi(terminal));&#10;        terminal.flush();&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        terminal.close();&#10;    }&#10;&#10;    public boolean meetsMinimumSize() {&#10;        return getWidth() &gt;= minWidth &amp;&amp; getHeight() &gt;= minHeight;&#10;    }&#10;&#10;    private void createWarningCanvas() {&#10;        warningCanvas = new Canvas(0, 0, getWidth(), getHeight()) {&#10;            @Override&#10;            public void paint(Graphics graphics) {&#10;                String message = &quot;Console too small!&quot;;&#10;                String requirement = String.format(&quot;Required: %dx%d&quot;, minWidth, minHeight);&#10;                String current = String.format(&quot;Current: %dx%d&quot;, getWidth(), getHeight());&#10;&#10;                if (getWidth() &gt; 10 &amp;&amp; getHeight() &gt; 5) {&#10;                    int centerX = getWidth() / 2;&#10;                    int centerY = getHeight() / 2;&#10;&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;                    graphics.drawString(Math.max(1, centerX - message.length() / 2), centerY - 1, message);&#10;                    graphics.drawString(Math.max(1, centerX - requirement.length() / 2), centerY, requirement);&#10;                    graphics.drawString(Math.max(1, centerX - current.length() / 2), centerY + 1, current);&#10;                } else {&#10;                    graphics.fillRect(0, 0, getWidth(), getHeight(), '!');&#10;                }&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateDisplay() {&#10;        removeAllChildren();&#10;&#10;        if (warningCanvas != null) {&#10;            warningCanvas.setWidth(getWidth());&#10;            warningCanvas.setHeight(getHeight());&#10;        }&#10;&#10;        if (meetsMinimumSize() &amp;&amp; contentCanvas != null) {&#10;            addChild(contentCanvas);&#10;        } else if (warningCanvas != null) {&#10;            addChild(warningCanvas);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;import org.jline.terminal.Terminal;&#10;import org.jline.terminal.TerminalBuilder;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * The main entry point canvas for the console application.&#10; * Manages the console terminal and handles minimum size requirements.&#10; */&#10;@Getter&#10;@Setter&#10;public class ScreenCanvas extends CompositeCanvas {&#10;&#10;    private static final int DEFAULT_MIN_WIDTH = 80;&#10;    private static final int DEFAULT_MIN_HEIGHT = 24;&#10;&#10;    private final Terminal terminal;&#10;    private final int minWidth;&#10;    private final int minHeight;&#10;    private Canvas warningCanvas;&#10;    private Canvas contentCanvas;&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with default minimum size requirements.&#10;     */&#10;    public ScreenCanvas() throws IOException {&#10;        this(DEFAULT_MIN_WIDTH, DEFAULT_MIN_HEIGHT);&#10;    }&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with specified minimum size requirements.&#10;     */&#10;    public ScreenCanvas(int minWidth, int minHeight) throws IOException {&#10;        super(0, 0, 0, 0);&#10;        this.minWidth = minWidth;&#10;        this.minHeight = minHeight;&#10;        this.terminal = TerminalBuilder.builder().system(true).build();&#10;&#10;        // Initialize screen dimensions&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;&#10;        // Create warning canvas&#10;        createWarningCanvas();&#10;        updateDisplay();&#10;    }&#10;&#10;    public void setContentCanvas(Canvas contentCanvas) {&#10;        if (this.contentCanvas != null) {&#10;            removeChild(this.contentCanvas);&#10;        }&#10;        this.contentCanvas = contentCanvas;&#10;        updateDisplay();&#10;    }&#10;&#10;    public void updateSize() {&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;        updateDisplay();&#10;    }&#10;&#10;    public void render() {&#10;        JLineGraphics graphics = new JLineGraphics(getWidth(), getHeight());&#10;        graphics.clear();&#10;        paint(graphics);&#10;&#10;        // Use JLine's efficient AttributedString output&#10;        terminal.writer().print(&quot;\033[2J\033[H&quot;); // Clear screen and move cursor to top&#10;        terminal.writer().print(graphics.toAttributedString().toAnsi(terminal));&#10;        terminal.flush();&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        terminal.close();&#10;    }&#10;&#10;    public boolean meetsMinimumSize() {&#10;        return getWidth() &gt;= minWidth &amp;&amp; getHeight() &gt;= minHeight;&#10;    }&#10;&#10;    private void createWarningCanvas() {&#10;        warningCanvas = new Canvas(0, 0, getWidth(), getHeight()) {&#10;            @Override&#10;            public void paint(Graphics graphics) {&#10;                String message = &quot;Console too small!&quot;;&#10;                String requirement = String.format(&quot;Required: %dx%d&quot;, minWidth, minHeight);&#10;                String current = String.format(&quot;Current: %dx%d&quot;, getWidth(), getHeight());&#10;&#10;                if (getWidth() &gt; 10 &amp;&amp; getHeight() &gt; 5) {&#10;                    int centerX = getWidth() / 2;&#10;                    int centerY = getHeight() / 2;&#10;&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;                    graphics.drawString(Math.max(1, centerX - message.length() / 2), centerY - 1, message);&#10;                    graphics.drawString(Math.max(1, centerX - requirement.length() / 2), centerY, requirement);&#10;                    graphics.drawString(Math.max(1, centerX - current.length() / 2), centerY + 1, current);&#10;                } else {&#10;                    graphics.fillRect(0, 0, getWidth(), getHeight(), '!');&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void paint(JLineGraphics graphics) {&#10;                String message = &quot;Console too small!&quot;;&#10;                String requirement = String.format(&quot;Required: %dx%d&quot;, minWidth, minHeight);&#10;                String current = String.format(&quot;Current: %dx%d&quot;, getWidth(), getHeight());&#10;&#10;                if (getWidth() &gt; 10 &amp;&amp; getHeight() &gt; 5) {&#10;                    int centerX = getWidth() / 2;&#10;                    int centerY = getHeight() / 2;&#10;&#10;                    // Draw border with red color for warning&#10;                    graphics.setStyle(org.jline.utils.AttributedStyle.DEFAULT&#10;                        .foreground(org.jline.utils.AttributedStyle.RED)&#10;                        .bold());&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;&#10;                    // Draw warning message in bright red&#10;                    graphics.setStyle(org.jline.utils.AttributedStyle.DEFAULT&#10;                        .foreground(org.jline.utils.AttributedStyle.BRIGHT + org.jline.utils.AttributedStyle.RED)&#10;                        .bold());&#10;                    graphics.drawString(Math.max(1, centerX - message.length() / 2), centerY - 1, message);&#10;&#10;                    // Draw requirement in yellow&#10;                    graphics.setStyle(org.jline.utils.AttributedStyle.DEFAULT&#10;                        .foreground(org.jline.utils.AttributedStyle.YELLOW));&#10;                    graphics.drawString(Math.max(1, centerX - requirement.length() / 2), centerY, requirement);&#10;&#10;                    // Draw current size in white&#10;                    graphics.setStyle(org.jline.utils.AttributedStyle.DEFAULT&#10;                        .foreground(org.jline.utils.AttributedStyle.WHITE));&#10;                    graphics.drawString(Math.max(1, centerX - current.length() / 2), centerY + 1, current);&#10;                } else {&#10;                    // For very small terminals, fill with warning character&#10;                    graphics.setStyle(org.jline.utils.AttributedStyle.DEFAULT&#10;                        .foreground(org.jline.utils.AttributedStyle.BRIGHT + org.jline.utils.AttributedStyle.RED)&#10;                        .bold());&#10;                    graphics.fillRect(0, 0, getWidth(), getHeight(), '!');&#10;                }&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateDisplay() {&#10;        removeAllChildren();&#10;&#10;        if (warningCanvas != null) {&#10;            warningCanvas.setWidth(getWidth());&#10;            warningCanvas.setHeight(getHeight());&#10;        }&#10;&#10;        if (meetsMinimumSize() &amp;&amp; contentCanvas != null) {&#10;            addChild(contentCanvas);&#10;        } else if (warningCanvas != null) {&#10;            addChild(warningCanvas);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>