<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/BackgroundDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/BackgroundDemo.java" />
              <option name="originalContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnimationThrottle;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationManager;&#10;import com.consolemaster.EventHandler;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.BackgroundProvider;&#10;import com.consolemaster.raycasting.SolidColorBackgroundProvider;&#10;import com.consolemaster.raycasting.CloudsBackgroundProvider;&#10;import com.consolemaster.raycasting.StarfieldBackgroundProvider;&#10;import com.consolemaster.raycasting.ConstellationBackgroundProvider;&#10;import com.consolemaster.raycasting.DayNightCycleBackgroundProvider;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application showcasing the different BackgroundProvider implementations&#10; * for RaycastingCanvas. Users can switch between solid color, clouds, and starfield&#10; * backgrounds using keyboard shortcuts.&#10; */&#10;public class BackgroundDemo {&#10;&#10;    private ScreenCanvas screen;&#10;    private RaycastingCanvas raycastingCanvas;&#10;    private ProcessLoop processLoop;&#10;&#10;    // Background providers&#10;    private SolidColorBackgroundProvider solidBackground;&#10;    private CloudsBackgroundProvider cloudsBackground;&#10;    private StarfieldBackgroundProvider starfieldBackground;&#10;    private ConstellationBackgroundProvider constellationBackground;&#10;    private DayNightCycleBackgroundProvider dayNightBackground;&#10;    private AnimationThrottle startfieldThrottle;&#10;&#10;    // Current background type&#10;    private BackgroundType currentBackground = BackgroundType.SOLID;&#10;&#10;    private enum BackgroundType {&#10;        SOLID(&quot;Solid Color Background&quot;),&#10;        CLOUDS(&quot;Animated Clouds Background&quot;),&#10;        STARFIELD(&quot;Animated Starfield Background&quot;),&#10;        CONSTELLATION(&quot;Constellation Background&quot;),&#10;        DAY_NIGHT_CYCLE(&quot;Day-Night Cycle with Weather&quot;);&#10;&#10;        private final String description;&#10;&#10;        BackgroundType(String description) {&#10;            this.description = description;&#10;        }&#10;&#10;        public String getDescription() {&#10;            return description;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws IOException {&#10;        new BackgroundDemo().run();&#10;    }&#10;&#10;    public void run() throws IOException {&#10;        setupComponents();&#10;        setupBackgrounds();&#10;        setupMap();&#10;        setupScreen();&#10;&#10;        // Start with solid background&#10;        setBackground(BackgroundType.SOLID);&#10;&#10;        // Start the process loop&#10;        processLoop = new ProcessLoop(screen);&#10;        processLoop.start();&#10;    }&#10;&#10;    private void setupComponents() throws IOException {&#10;        screen = new ScreenCanvas(80, 25);&#10;&#10;        // Create raycasting canvas&#10;        raycastingCanvas = new RaycastingCanvas(&quot;Background Demo&quot;, 80, 25);&#10;        raycastingCanvas.setPosition(0, 0);&#10;        raycastingCanvas.setVisible(true);&#10;&#10;        // Configure raycasting appearance&#10;        raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;        raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;        raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;        raycastingCanvas.setDrawWallEdges(true);&#10;        raycastingCanvas.setWallEdgeThreshold(0.3);&#10;        raycastingCanvas.setRenderCeilings(false); // Disable ceiling to show background better&#10;&#10;        // Set player position&#10;        raycastingCanvas.setPlayerPosition(4.5, 4.5);&#10;        raycastingCanvas.setPlayerAngle(0.0);&#10;    }&#10;&#10;    private void setupBackgrounds() {&#10;        // Create solid color background&#10;        solidBackground = new SolidColorBackgroundProvider(AnsiColor.BLUE);&#10;&#10;        // Create animated clouds background&#10;        cloudsBackground = new CloudsBackgroundProvider(0.03, 0.04, 0.4);&#10;        cloudsBackground.setSkyColor(AnsiColor.CYAN);&#10;        cloudsBackground.setCloudColorLight(AnsiColor.WHITE);&#10;        cloudsBackground.setCloudColorDark(AnsiColor.BRIGHT_BLACK);&#10;&#10;        // Create animated starfield background&#10;        starfieldBackground = new StarfieldBackgroundProvider(80, 25);&#10;        starfieldBackground.setRotationSpeed(0.3);&#10;        starfieldBackground.setNumStars(150);&#10;        starfieldBackground.setSkyColor(AnsiColor.BLACK);&#10;        startfieldThrottle = AnimationThrottle.withDelaySeconds(starfieldBackground, 1);&#10;&#10;        // Create animated constellation background&#10;        constellationBackground = new ConstellationBackgroundProvider(80, 25);&#10;        constellationBackground.setDriftSpeed(0.01);&#10;        constellationBackground.setTwinkleIntensity(0.3);&#10;        constellationBackground.setShowConstellationLines(true);&#10;        constellationBackground.setSkyColor(AnsiColor.BLACK);&#10;&#10;        // Create day-night cycle background&#10;        dayNightBackground = new DayNightCycleBackgroundProvider(80, 25);&#10;        dayNightBackground.setTimeSpeed(0.0001); // Slightly faster for demo&#10;        dayNightBackground.setAutomaticWeather(true);&#10;        dayNightBackground.setShowCelestialBodies(true);&#10;        dayNightBackground.setCurrentTime(0.5); // Start at noon&#10;    }&#10;&#10;    private void setupMap() {&#10;        // Create a simple map with open areas to show the background&#10;        String[] map = {&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ####    ##  #&quot;,&#10;            &quot;#    ##        #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#     ##       #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ##    ####  #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#      ##      #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        };&#10;        raycastingCanvas.setMap(map);&#10;    }&#10;&#10;    private void setupScreen() {&#10;        screen.setContent(raycastingCanvas);&#10;&#10;        // Register keyboard shortcuts&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESC.name(), () -&gt; {&#10;            try {&#10;                processLoop.stop();&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;&#10;        screen.registerShortcut(&quot;1&quot;, () -&gt; {&#10;            setBackground(BackgroundType.SOLID);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;2&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CLOUDS);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;3&quot;, () -&gt; {&#10;            setBackground(BackgroundType.STARFIELD);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;4&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CONSTELLATION);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;5&quot;, () -&gt; {&#10;            setBackground(BackgroundType.DAY_NIGHT_CYCLE);&#10;        });&#10;&#10;        // Day-Night cycle specific controls&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            toggleTimeSpeed();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            cycleWeather();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;N&quot;, () -&gt; {&#10;            setTimeToNight();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            setTimeToMidday();&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut( KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            toggleCeilings();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;H&quot;, () -&gt; {&#10;            showHelp();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;    }&#10;&#10;    private void setBackground(BackgroundType backgroundType) {&#10;        // Remove current background from animation manager&#10;        if (currentBackground == BackgroundType.CLOUDS) {&#10;            processLoop.removeAnimationTicker(cloudsBackground);&#10;        } else if (currentBackground == BackgroundType.STARFIELD) {&#10;            processLoop.removeAnimationTicker(startfieldThrottle);&#10;        } else if (currentBackground == BackgroundType.CONSTELLATION) {&#10;            processLoop.removeAnimationTicker(constellationBackground);&#10;        } else if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            processLoop.removeAnimationTicker(dayNightBackground);&#10;        }&#10;&#10;        // Set new background&#10;        currentBackground = backgroundType;&#10;        BackgroundProvider provider;&#10;&#10;        switch (backgroundType) {&#10;            case SOLID:&#10;                provider = solidBackground;&#10;                break;&#10;            case CLOUDS:&#10;                provider = cloudsBackground;&#10;                processLoop.addAnimationTicker(cloudsBackground);&#10;                break;&#10;            case STARFIELD:&#10;                provider = starfieldBackground;&#10;                processLoop.addAnimationTicker(startfieldThrottle);&#10;                break;&#10;            case CONSTELLATION:&#10;                provider = constellationBackground;&#10;                processLoop.addAnimationTicker(constellationBackground);&#10;                break;&#10;            case DAY_NIGHT_CYCLE:&#10;                provider = dayNightBackground;&#10;                processLoop.addAnimationTicker(dayNightBackground);&#10;                break;&#10;            default:&#10;                provider = solidBackground;&#10;        }&#10;&#10;        raycastingCanvas.setBackgroundProvider(provider);&#10;        System.out.println(&quot;Switched to: &quot; + backgroundType.getDescription());&#10;    }&#10;&#10;    private void toggleCeilings() {&#10;        boolean currentState = raycastingCanvas.isRenderCeilings();&#10;        raycastingCanvas.setRenderCeilings(!currentState);&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (currentState ? &quot;OFF&quot; : &quot;ON&quot;));&#10;    }&#10;&#10;    private void showHelp() {&#10;        System.out.println(&quot;\n=== Background Demo Controls ===&quot;);&#10;        System.out.println(&quot;Movement:&quot;);&#10;        System.out.println(&quot;  ↑/↓      - Move forward/backward&quot;);&#10;        System.out.println(&quot;  A/D      - Strafe left/right&quot;);&#10;        System.out.println(&quot;  ←/→      - Turn left/right&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Backgrounds:&quot;);&#10;        System.out.println(&quot;  1        - Solid color background&quot;);&#10;        System.out.println(&quot;  2        - Animated clouds background&quot;);&#10;        System.out.println(&quot;  3        - Animated starfield background&quot;);&#10;        System.out.println(&quot;  4        - Constellation background&quot;);&#10;        System.out.println(&quot;  5        - Day-Night cycle background&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Day-Night Cycle Controls (when active):&quot;);&#10;        System.out.println(&quot;  T        - Toggle time speed (slow/fast)&quot;);&#10;        System.out.println(&quot;  W        - Cycle weather (sunny→cloudy→rainy→stormy)&quot;);&#10;        System.out.println(&quot;  B        - Adjust sunny weather bias (low→med→high→very high)&quot;);&#10;        System.out.println(&quot;  N        - Set time to night (midnight)&quot;);&#10;        System.out.println(&quot;  M        - Set time to midday (noon)&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Options:&quot;);&#10;        System.out.println(&quot;  C        - Toggle ceiling rendering&quot;);&#10;        System.out.println(&quot;  H        - Show this help&quot;);&#10;        System.out.println(&quot;  ESC      - Exit demo&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Current background: &quot; + currentBackground.getDescription());&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (raycastingCanvas.isRenderCeilings() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;&#10;        // Show additional info for Day-Night cycle&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            System.out.println();&#10;            System.out.println(&quot;Day-Night Cycle Status:&quot;);&#10;            System.out.println(&quot;  Time: &quot; + dayNightBackground.getTimeString());&#10;            System.out.println(&quot;  Weather: &quot; + dayNightBackground.getCurrentWeatherString());&#10;            System.out.println(&quot;  Auto Weather: &quot; + (dayNightBackground.isAutomaticWeather() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;        }&#10;&#10;        System.out.println(&quot;===============================\n&quot;);&#10;    }&#10;&#10;    private void toggleTimeSpeed() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentSpeed = dayNightBackground.getTimeSpeed();&#10;            double newSpeed = currentSpeed &lt;= 0.0001 ? 0.001 : 0.0001; // Toggle between slow and fast&#10;            dayNightBackground.setTimeSpeed(newSpeed);&#10;            System.out.println(&quot;Time speed: &quot; + (newSpeed &gt; 0.0001 ? &quot;FAST&quot; : &quot;SLOW&quot;));&#10;        }&#10;    }&#10;&#10;    private void cycleWeather() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            DayNightCycleBackgroundProvider.WeatherType[] weathers =&#10;                DayNightCycleBackgroundProvider.WeatherType.values();&#10;            DayNightCycleBackgroundProvider.WeatherType current = dayNightBackground.getCurrentWeather();&#10;&#10;            // Find next weather type&#10;            int currentIndex = 0;&#10;            for (int i = 0; i &lt; weathers.length; i++) {&#10;                if (weathers[i] == current) {&#10;                    currentIndex = i;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            DayNightCycleBackgroundProvider.WeatherType nextWeather =&#10;                weathers[(currentIndex + 1) % weathers.length];&#10;            dayNightBackground.setWeather(nextWeather);&#10;            System.out.println(&quot;Weather: &quot; + nextWeather.getName());&#10;        }&#10;    }&#10;&#10;    private void setTimeToNight() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.0); // Midnight&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Night)&quot;);&#10;        }&#10;    }&#10;&#10;    private void setTimeToMidday() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.5); // Noon&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Midday)&quot;);&#10;        }&#10;    }&#10;&#10;    private void adjustSunnyBias() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentBias = dayNightBackground.getSunnyWeatherBias();&#10;            // Cycle through different bias levels: 0.3 -&gt; 0.5 -&gt; 0.7 -&gt; 0.9 -&gt; 0.3&#10;            double newBias;&#10;            if (currentBias &lt; 0.4) {&#10;                newBias = 0.5; // Low -&gt; Medium&#10;            } else if (currentBias &lt; 0.6) {&#10;                newBias = 0.7; // Medium -&gt; High&#10;            } else if (currentBias &lt; 0.8) {&#10;                newBias = 0.9; // High -&gt; Very High&#10;            } else {&#10;                newBias = 0.3; // Very High -&gt; Low&#10;            }&#10;&#10;            dayNightBackground.setSunnyWeatherBias(newBias);&#10;            String biasLevel = getBiasLevelName(newBias);&#10;            System.out.println(&quot;Sunny weather bias: &quot; + biasLevel + &quot; (&quot; + Math.round(newBias * 100) + &quot;%)&quot;);&#10;        }&#10;    }&#10;&#10;    private String getBiasLevelName(double bias) {&#10;        if (bias &lt; 0.4) return &quot;LOW&quot;;&#10;        if (bias &lt; 0.6) return &quot;MEDIUM&quot;;&#10;        if (bias &lt; 0.8) return &quot;HIGH&quot;;&#10;        return &quot;VERY HIGH&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnimationThrottle;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationManager;&#10;import com.consolemaster.EventHandler;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.BackgroundProvider;&#10;import com.consolemaster.raycasting.SolidColorBackgroundProvider;&#10;import com.consolemaster.raycasting.CloudsBackgroundProvider;&#10;import com.consolemaster.raycasting.StarfieldBackgroundProvider;&#10;import com.consolemaster.raycasting.ConstellationBackgroundProvider;&#10;import com.consolemaster.raycasting.DayNightCycleBackgroundProvider;&#10;import com.consolemaster.raycasting.AlienPlanetBackgroundProvider;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application showcasing the different BackgroundProvider implementations&#10; * for RaycastingCanvas. Users can switch between solid color, clouds, and starfield&#10; * backgrounds using keyboard shortcuts.&#10; */&#10;public class BackgroundDemo {&#10;&#10;    private ScreenCanvas screen;&#10;    private RaycastingCanvas raycastingCanvas;&#10;    private ProcessLoop processLoop;&#10;&#10;    // Background providers&#10;    private SolidColorBackgroundProvider solidBackground;&#10;    private CloudsBackgroundProvider cloudsBackground;&#10;    private StarfieldBackgroundProvider starfieldBackground;&#10;    private ConstellationBackgroundProvider constellationBackground;&#10;    private DayNightCycleBackgroundProvider dayNightBackground;&#10;    private AlienPlanetBackgroundProvider alienPlanetBackground;&#10;    private AnimationThrottle startfieldThrottle;&#10;&#10;    // Current background type&#10;    private BackgroundType currentBackground = BackgroundType.SOLID;&#10;&#10;    private enum BackgroundType {&#10;        SOLID(&quot;Solid Color Background&quot;),&#10;        CLOUDS(&quot;Animated Clouds Background&quot;),&#10;        STARFIELD(&quot;Animated Starfield Background&quot;),&#10;        CONSTELLATION(&quot;Constellation Background&quot;),&#10;        DAY_NIGHT_CYCLE(&quot;Day-Night Cycle with Weather&quot;),&#10;        ALIEN_PLANET(&quot;Alien Planet Environment&quot;);&#10;&#10;        private final String description;&#10;&#10;        BackgroundType(String description) {&#10;            this.description = description;&#10;        }&#10;&#10;        public String getDescription() {&#10;            return description;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws IOException {&#10;        new BackgroundDemo().run();&#10;    }&#10;&#10;    public void run() throws IOException {&#10;        setupComponents();&#10;        setupBackgrounds();&#10;        setupMap();&#10;        setupScreen();&#10;&#10;        // Start with solid background&#10;        setBackground(BackgroundType.SOLID);&#10;&#10;        // Start the process loop&#10;        processLoop = new ProcessLoop(screen);&#10;        processLoop.start();&#10;    }&#10;&#10;    private void setupComponents() throws IOException {&#10;        screen = new ScreenCanvas(80, 25);&#10;&#10;        // Create raycasting canvas&#10;        raycastingCanvas = new RaycastingCanvas(&quot;Background Demo&quot;, 80, 25);&#10;        raycastingCanvas.setPosition(0, 0);&#10;        raycastingCanvas.setVisible(true);&#10;&#10;        // Configure raycasting appearance&#10;        raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;        raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;        raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;        raycastingCanvas.setDrawWallEdges(true);&#10;        raycastingCanvas.setWallEdgeThreshold(0.3);&#10;        raycastingCanvas.setRenderCeilings(false); // Disable ceiling to show background better&#10;&#10;        // Set player position&#10;        raycastingCanvas.setPlayerPosition(4.5, 4.5);&#10;        raycastingCanvas.setPlayerAngle(0.0);&#10;    }&#10;&#10;    private void setupBackgrounds() {&#10;        // Create solid color background&#10;        solidBackground = new SolidColorBackgroundProvider(AnsiColor.BLUE);&#10;&#10;        // Create animated clouds background&#10;        cloudsBackground = new CloudsBackgroundProvider(0.03, 0.04, 0.4);&#10;        cloudsBackground.setSkyColor(AnsiColor.CYAN);&#10;        cloudsBackground.setCloudColorLight(AnsiColor.WHITE);&#10;        cloudsBackground.setCloudColorDark(AnsiColor.BRIGHT_BLACK);&#10;&#10;        // Create animated starfield background&#10;        starfieldBackground = new StarfieldBackgroundProvider(80, 25);&#10;        starfieldBackground.setRotationSpeed(0.3);&#10;        starfieldBackground.setNumStars(150);&#10;        starfieldBackground.setSkyColor(AnsiColor.BLACK);&#10;        startfieldThrottle = AnimationThrottle.withDelaySeconds(starfieldBackground, 1);&#10;&#10;        // Create animated constellation background&#10;        constellationBackground = new ConstellationBackgroundProvider(80, 25);&#10;        constellationBackground.setDriftSpeed(0.01);&#10;        constellationBackground.setTwinkleIntensity(0.3);&#10;        constellationBackground.setShowConstellationLines(true);&#10;        constellationBackground.setSkyColor(AnsiColor.BLACK);&#10;&#10;        // Create day-night cycle background&#10;        dayNightBackground = new DayNightCycleBackgroundProvider(80, 25);&#10;        dayNightBackground.setTimeSpeed(0.0001); // Slightly faster for demo&#10;        dayNightBackground.setAutomaticWeather(true);&#10;        dayNightBackground.setShowCelestialBodies(true);&#10;        dayNightBackground.setCurrentTime(0.5); // Start at noon&#10;&#10;        // Create alien planet background (newly added)&#10;        alienPlanetBackground = new AlienPlanetBackgroundProvider(80, 25);&#10;        alienPlanetBackground.setAnimationSpeed(0.02);&#10;        alienPlanetBackground.setParticleDensity(0.8);&#10;        alienPlanetBackground.setAuroraBrightness(0.7);&#10;        alienPlanetBackground.setShowMoons(true);&#10;        alienPlanetBackground.setShowAurora(true);&#10;        alienPlanetBackground.setShowParticles(true);&#10;        alienPlanetBackground.setShowPulsar(true);&#10;    }&#10;&#10;    private void setupMap() {&#10;        // Create a simple map with open areas to show the background&#10;        String[] map = {&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ####    ##  #&quot;,&#10;            &quot;#    ##        #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#     ##       #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ##    ####  #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#      ##      #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        };&#10;        raycastingCanvas.setMap(map);&#10;    }&#10;&#10;    private void setupScreen() {&#10;        screen.setContent(raycastingCanvas);&#10;&#10;        // Register keyboard shortcuts&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESC.name(), () -&gt; {&#10;            try {&#10;                processLoop.stop();&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;&#10;        screen.registerShortcut(&quot;1&quot;, () -&gt; {&#10;            setBackground(BackgroundType.SOLID);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;2&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CLOUDS);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;3&quot;, () -&gt; {&#10;            setBackground(BackgroundType.STARFIELD);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;4&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CONSTELLATION);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;5&quot;, () -&gt; {&#10;            setBackground(BackgroundType.DAY_NIGHT_CYCLE);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;6&quot;, () -&gt; {&#10;            setBackground(BackgroundType.ALIEN_PLANET);&#10;        });&#10;&#10;        // Day-Night cycle specific controls&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            toggleTimeSpeed();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            cycleWeather();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;N&quot;, () -&gt; {&#10;            setTimeToNight();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            setTimeToMidday();&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut( KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            toggleCeilings();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;H&quot;, () -&gt; {&#10;            showHelp();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;    }&#10;&#10;    private void setBackground(BackgroundType backgroundType) {&#10;        // Remove current background from animation manager&#10;        if (currentBackground == BackgroundType.CLOUDS) {&#10;            processLoop.removeAnimationTicker(cloudsBackground);&#10;        } else if (currentBackground == BackgroundType.STARFIELD) {&#10;            processLoop.removeAnimationTicker(startfieldThrottle);&#10;        } else if (currentBackground == BackgroundType.CONSTELLATION) {&#10;            processLoop.removeAnimationTicker(constellationBackground);&#10;        } else if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            processLoop.removeAnimationTicker(dayNightBackground);&#10;        } else if (currentBackground == BackgroundType.ALIEN_PLANET) {&#10;            processLoop.removeAnimationTicker(alienPlanetBackground);&#10;        }&#10;&#10;        // Set new background&#10;        currentBackground = backgroundType;&#10;        BackgroundProvider provider;&#10;&#10;        switch (backgroundType) {&#10;            case SOLID:&#10;                provider = solidBackground;&#10;                break;&#10;            case CLOUDS:&#10;                provider = cloudsBackground;&#10;                processLoop.addAnimationTicker(cloudsBackground);&#10;                break;&#10;            case STARFIELD:&#10;                provider = starfieldBackground;&#10;                processLoop.addAnimationTicker(startfieldThrottle);&#10;                break;&#10;            case CONSTELLATION:&#10;                provider = constellationBackground;&#10;                processLoop.addAnimationTicker(constellationBackground);&#10;                break;&#10;            case DAY_NIGHT_CYCLE:&#10;                provider = dayNightBackground;&#10;                processLoop.addAnimationTicker(dayNightBackground);&#10;                break;&#10;            case ALIEN_PLANET:&#10;                provider = alienPlanetBackground;&#10;                processLoop.addAnimationTicker(alienPlanetBackground);&#10;                break;&#10;            default:&#10;                provider = solidBackground;&#10;        }&#10;&#10;        raycastingCanvas.setBackgroundProvider(provider);&#10;        System.out.println(&quot;Switched to: &quot; + backgroundType.getDescription());&#10;    }&#10;&#10;    private void toggleCeilings() {&#10;        boolean currentState = raycastingCanvas.isRenderCeilings();&#10;        raycastingCanvas.setRenderCeilings(!currentState);&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (currentState ? &quot;OFF&quot; : &quot;ON&quot;));&#10;    }&#10;&#10;    private void showHelp() {&#10;        System.out.println(&quot;\n=== Background Demo Controls ===&quot;);&#10;        System.out.println(&quot;Movement:&quot;);&#10;        System.out.println(&quot;  ↑/↓      - Move forward/backward&quot;);&#10;        System.out.println(&quot;  A/D      - Strafe left/right&quot;);&#10;        System.out.println(&quot;  ←/→      - Turn left/right&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Backgrounds:&quot;);&#10;        System.out.println(&quot;  1        - Solid color background&quot;);&#10;        System.out.println(&quot;  2        - Animated clouds background&quot;);&#10;        System.out.println(&quot;  3        - Animated starfield background&quot;);&#10;        System.out.println(&quot;  4        - Constellation background&quot;);&#10;        System.out.println(&quot;  5        - Day-Night cycle background&quot;);&#10;        System.out.println(&quot;  6        - Alien planet background&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Day-Night Cycle Controls (when active):&quot;);&#10;        System.out.println(&quot;  T        - Toggle time speed (slow/fast)&quot;);&#10;        System.out.println(&quot;  W        - Cycle weather (sunny→cloudy→rainy→stormy)&quot;);&#10;        System.out.println(&quot;  B        - Adjust sunny weather bias (low→med→high→very high)&quot;);&#10;        System.out.println(&quot;  N        - Set time to night (midnight)&quot;);&#10;        System.out.println(&quot;  M        - Set time to midday (noon)&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Options:&quot;);&#10;        System.out.println(&quot;  C        - Toggle ceiling rendering&quot;);&#10;        System.out.println(&quot;  H        - Show this help&quot;);&#10;        System.out.println(&quot;  ESC      - Exit demo&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Current background: &quot; + currentBackground.getDescription());&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (raycastingCanvas.isRenderCeilings() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;&#10;        // Show additional info for Day-Night cycle&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            System.out.println();&#10;            System.out.println(&quot;Day-Night Cycle Status:&quot;);&#10;            System.out.println(&quot;  Time: &quot; + dayNightBackground.getTimeString());&#10;            System.out.println(&quot;  Weather: &quot; + dayNightBackground.getCurrentWeatherString());&#10;            System.out.println(&quot;  Auto Weather: &quot; + (dayNightBackground.isAutomaticWeather() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;        }&#10;&#10;        System.out.println(&quot;===============================\n&quot;);&#10;    }&#10;&#10;    private void toggleTimeSpeed() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentSpeed = dayNightBackground.getTimeSpeed();&#10;            double newSpeed = currentSpeed &lt;= 0.0001 ? 0.001 : 0.0001; // Toggle between slow and fast&#10;            dayNightBackground.setTimeSpeed(newSpeed);&#10;            System.out.println(&quot;Time speed: &quot; + (newSpeed &gt; 0.0001 ? &quot;FAST&quot; : &quot;SLOW&quot;));&#10;        }&#10;    }&#10;&#10;    private void cycleWeather() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            DayNightCycleBackgroundProvider.WeatherType[] weathers =&#10;                DayNightCycleBackgroundProvider.WeatherType.values();&#10;            DayNightCycleBackgroundProvider.WeatherType current = dayNightBackground.getCurrentWeather();&#10;&#10;            // Find next weather type&#10;            int currentIndex = 0;&#10;            for (int i = 0; i &lt; weathers.length; i++) {&#10;                if (weathers[i] == current) {&#10;                    currentIndex = i;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            DayNightCycleBackgroundProvider.WeatherType nextWeather =&#10;                weathers[(currentIndex + 1) % weathers.length];&#10;            dayNightBackground.setWeather(nextWeather);&#10;            System.out.println(&quot;Weather: &quot; + nextWeather.getName());&#10;        }&#10;    }&#10;&#10;    private void setTimeToNight() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.0); // Midnight&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Night)&quot;);&#10;        }&#10;    }&#10;&#10;    private void setTimeToMidday() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.5); // Noon&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Midday)&quot;);&#10;        }&#10;    }&#10;&#10;    private void adjustSunnyBias() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentBias = dayNightBackground.getSunnyWeatherBias();&#10;            // Cycle through different bias levels: 0.3 -&gt; 0.5 -&gt; 0.7 -&gt; 0.9 -&gt; 0.3&#10;            double newBias;&#10;            if (currentBias &lt; 0.4) {&#10;                newBias = 0.5; // Low -&gt; Medium&#10;            } else if (currentBias &lt; 0.6) {&#10;                newBias = 0.7; // Medium -&gt; High&#10;            } else if (currentBias &lt; 0.8) {&#10;                newBias = 0.9; // High -&gt; Very High&#10;            } else {&#10;                newBias = 0.3; // Very High -&gt; Low&#10;            }&#10;&#10;            dayNightBackground.setSunnyWeatherBias(newBias);&#10;            String biasLevel = getBiasLevelName(newBias);&#10;            System.out.println(&quot;Sunny weather bias: &quot; + biasLevel + &quot; (&quot; + Math.round(newBias * 100) + &quot;%)&quot;);&#10;        }&#10;    }&#10;&#10;    private String getBiasLevelName(double bias) {&#10;        if (bias &lt; 0.4) return &quot;LOW&quot;;&#10;        if (bias &lt; 0.6) return &quot;MEDIUM&quot;;&#10;        if (bias &lt; 0.8) return &quot;HIGH&quot;;&#10;        return &quot;VERY HIGH&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/AlienPlanetBackgroundProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/AlienPlanetBackgroundProvider.java" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.StyledChar;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationTicker;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.util.Random;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * A background provider that simulates an alien planet environment.&#10; * Features multiple moons, alien aurora effects, floating particles,&#10; * and strange celestial phenomena typical of an extraterrestrial world.&#10; * Note: This provider must be manually registered with the AnimationManager for animation.&#10; */&#10;@Getter&#10;@Setter&#10;public class AlienPlanetBackgroundProvider implements BackgroundProvider, AnimationTicker {&#10;&#10;    // Animation settings&#10;    private double animationSpeed = 0.02;&#10;    private double particleSpeed = 0.05;&#10;    private double auroraSpeed = 0.03;&#10;    &#10;    // Visual effects settings&#10;    private boolean showMoons = true;&#10;    private boolean showAurora = true;&#10;    private boolean showParticles = true;&#10;    private boolean showPulsar = true;&#10;    private double particleDensity = 0.8;&#10;    private double auroraBrightness = 0.7;&#10;    &#10;    // Sky colors for alien atmosphere&#10;    private AnsiColor[] alienSkyColors = {&#10;        AnsiColor.MAGENTA,      // Purple alien sky&#10;        AnsiColor.CYAN,         // Turquoise atmosphere&#10;        AnsiColor.YELLOW,       // Golden nebula&#10;        AnsiColor.GREEN         // Toxic green atmosphere&#10;    };&#10;    &#10;    private AnsiColor currentSkyColor = AnsiColor.MAGENTA;&#10;    &#10;    private Random random = new Random();&#10;    private int canvasWidth = 80;&#10;    private int canvasHeight = 25;&#10;    private double playerAngle = 0.0;&#10;    &#10;    // Animation timers&#10;    private double animationTimer = 0.0;&#10;    private double particleTimer = 0.0;&#10;    private double auroraTimer = 0.0;&#10;    private double pulsarTimer = 0.0;&#10;    private double skyTransitionTimer = 0.0;&#10;    &#10;    // Celestial objects&#10;    private List&lt;AlienMoon&gt; moons = new ArrayList&lt;&gt;();&#10;    private List&lt;FloatingParticle&gt; particles = new ArrayList&lt;&gt;();&#10;    private List&lt;AuroraStrip&gt; auroraStrips = new ArrayList&lt;&gt;();&#10;&#10;    public AlienPlanetBackgroundProvider() {&#10;        initializeAlienEnvironment();&#10;    }&#10;&#10;    public AlienPlanetBackgroundProvider(int canvasWidth, int canvasHeight) {&#10;        this.canvasWidth = canvasWidth;&#10;        this.canvasHeight = canvasHeight;&#10;        initializeAlienEnvironment();&#10;    }&#10;&#10;    private void initializeAlienEnvironment() {&#10;        initializeMoons();&#10;        initializeParticles();&#10;        initializeAuroraStrips();&#10;    }&#10;&#10;    private void initializeMoons() {&#10;        moons.clear();&#10;        &#10;        // Large primary moon with rings&#10;        moons.add(new AlienMoon(&#10;            0.3, 0.2,           // Position (relative to screen)&#10;            3.5,                // Size&#10;            AnsiColor.BRIGHT_WHITE,&#10;            AnsiColor.CYAN,&#10;            '◯', '○', '·',&#10;            true,               // Has rings&#10;            0.01                // Orbit speed&#10;        ));&#10;        &#10;        // Smaller secondary moon&#10;        moons.add(new AlienMoon(&#10;            0.7, 0.15,&#10;            2.0,&#10;            AnsiColor.YELLOW,&#10;            AnsiColor.BRIGHT_YELLOW,&#10;            '◉', '●', '·',&#10;            false,&#10;            0.02&#10;        ));&#10;        &#10;        // Tiny distant moon&#10;        moons.add(new AlienMoon(&#10;            0.8, 0.4,&#10;            1.2,&#10;            AnsiColor.RED,&#10;            AnsiColor.BRIGHT_RED,&#10;            '●', '○', '·',&#10;            false,&#10;            0.005&#10;        ));&#10;    }&#10;&#10;    private void initializeParticles() {&#10;        particles.clear();&#10;        int numParticles = (int) (canvasWidth * canvasHeight * particleDensity * 0.01);&#10;        &#10;        for (int i = 0; i &lt; numParticles; i++) {&#10;            particles.add(new FloatingParticle(&#10;                random.nextDouble() * canvasWidth,&#10;                random.nextDouble() * canvasHeight,&#10;                random.nextDouble() * 0.02 + 0.005,  // Speed&#10;                random.nextDouble() * Math.PI * 2,    // Direction&#10;                0.3 + random.nextDouble() * 0.7,      // Brightness&#10;                random.nextDouble() * Math.PI * 2,    // Phase&#10;                0.02 + random.nextDouble() * 0.08     // Pulse speed&#10;            ));&#10;        }&#10;    }&#10;&#10;    private void initializeAuroraStrips() {&#10;        auroraStrips.clear();&#10;        &#10;        // Create flowing aurora strips&#10;        for (int i = 0; i &lt; 5; i++) {&#10;            auroraStrips.add(new AuroraStrip(&#10;                random.nextDouble() * canvasWidth,&#10;                random.nextDouble() * canvasHeight * 0.6, // Upper part of sky&#10;                random.nextDouble() * 0.03 + 0.01,        // Flow speed&#10;                0.5 + random.nextDouble() * 0.5,          // Intensity&#10;                random.nextDouble() * Math.PI * 2         // Phase offset&#10;            ));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void setDimensionAndAngle(int width, int height, double playerAngle) {&#10;        this.playerAngle = playerAngle;&#10;        if (width != this.canvasWidth || height != this.canvasHeight) {&#10;            this.canvasWidth = width;&#10;            this.canvasHeight = height;&#10;            initializeAlienEnvironment();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public StyledChar getBackground(int x, int y) {&#10;        // Check for aurora effects first (they're atmospheric)&#10;        if (showAurora) {&#10;            StyledChar aurora = getAuroraEffect(x, y);&#10;            if (aurora != null) return aurora;&#10;        }&#10;        &#10;        // Check for floating particles&#10;        if (showParticles) {&#10;            StyledChar particle = getParticleEffect(x, y);&#10;            if (particle != null) return particle;&#10;        }&#10;        &#10;        // Check for moons&#10;        if (showMoons) {&#10;            StyledChar moon = getMoonEffect(x, y);&#10;            if (moon != null) return moon;&#10;        }&#10;        &#10;        // Check for pulsar effect&#10;        if (showPulsar) {&#10;            StyledChar pulsar = getPulsarEffect(x, y);&#10;            if (pulsar != null) return pulsar;&#10;        }&#10;        &#10;        // Return alien sky&#10;        return new StyledChar(' ', null, currentSkyColor, null);&#10;    }&#10;&#10;    private StyledChar getAuroraEffect(int x, int y) {&#10;        for (AuroraStrip strip : auroraStrips) {&#10;            double distance = getAuroraDistance(x, y, strip);&#10;            if (distance &lt; 3.0) {&#10;                double intensity = strip.intensity * auroraBrightness * (1.0 - distance / 3.0);&#10;                double wave = Math.sin(auroraTimer * strip.flowSpeed + strip.phaseOffset + x * 0.1) * 0.5 + 0.5;&#10;                intensity *= wave;&#10;                &#10;                if (intensity &gt; 0.3) {&#10;                    char auroraChar = intensity &gt; 0.7 ? '▓' : intensity &gt; 0.5 ? '▒' : '░';&#10;                    AnsiColor auroraColor = getAuroraColor(intensity);&#10;                    return new StyledChar(auroraChar, auroraColor, currentSkyColor, null);&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private double getAuroraDistance(int x, int y, AuroraStrip strip) {&#10;        // Create flowing ribbon-like aurora&#10;        double waveY = strip.y + Math.sin(auroraTimer * strip.flowSpeed + x * 0.2) * 3.0;&#10;        return Math.abs(y - waveY);&#10;    }&#10;&#10;    private AnsiColor getAuroraColor(double intensity) {&#10;        if (intensity &gt; 0.8) return AnsiColor.BRIGHT_GREEN;&#10;        if (intensity &gt; 0.6) return AnsiColor.GREEN;&#10;        if (intensity &gt; 0.4) return AnsiColor.CYAN;&#10;        return AnsiColor.BLUE;&#10;    }&#10;&#10;    private StyledChar getParticleEffect(int x, int y) {&#10;        for (FloatingParticle particle : particles) {&#10;            double adjustedX = (particle.x + (playerAngle / (Math.PI * 2)) * canvasWidth) % canvasWidth;&#10;            if (adjustedX &lt; 0) adjustedX += canvasWidth;&#10;            &#10;            if (Math.abs(adjustedX - x) &lt; 1.0 &amp;&amp; Math.abs(particle.y - y) &lt; 1.0) {&#10;                double pulse = Math.sin(particle.phase) * 0.3 + 0.7;&#10;                double effectiveBrightness = particle.brightness * pulse;&#10;                &#10;                if (effectiveBrightness &gt; 0.5) {&#10;                    char particleChar = effectiveBrightness &gt; 0.8 ? '◆' : effectiveBrightness &gt; 0.6 ? '◇' : '·';&#10;                    AnsiColor particleColor = getParticleColor(effectiveBrightness);&#10;                    return new StyledChar(particleChar, particleColor, currentSkyColor, null);&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private AnsiColor getParticleColor(double brightness) {&#10;        if (brightness &gt; 0.9) return AnsiColor.BRIGHT_YELLOW;&#10;        if (brightness &gt; 0.7) return AnsiColor.YELLOW;&#10;        if (brightness &gt; 0.5) return AnsiColor.WHITE;&#10;        return AnsiColor.BRIGHT_BLACK;&#10;    }&#10;&#10;    private StyledChar getMoonEffect(int x, int y) {&#10;        for (AlienMoon moon : moons) {&#10;            double moonX = moon.x * canvasWidth + Math.sin(animationTimer * moon.orbitSpeed) * 5.0;&#10;            double moonY = moon.y * canvasHeight + Math.cos(animationTimer * moon.orbitSpeed) * 2.0;&#10;            &#10;            // Apply player angle effect&#10;            moonX = (moonX + (playerAngle / (Math.PI * 2)) * canvasWidth * 0.1) % canvasWidth;&#10;            &#10;            double distance = Math.sqrt(Math.pow(x - moonX, 2) + Math.pow(y - moonY, 2));&#10;            &#10;            // Moon surface&#10;            if (distance &lt; moon.size) {&#10;                if (distance &lt; moon.size * 0.3) {&#10;                    return new StyledChar(moon.coreChar, moon.coreColor, currentSkyColor, null);&#10;                } else if (distance &lt; moon.size * 0.7) {&#10;                    return new StyledChar(moon.surfaceChar, moon.surfaceColor, currentSkyColor, null);&#10;                } else {&#10;                    return new StyledChar(moon.edgeChar, moon.surfaceColor, currentSkyColor, null);&#10;                }&#10;            }&#10;            &#10;            // Moon rings (for moons that have them)&#10;            if (moon.hasRings &amp;&amp; distance &gt; moon.size &amp;&amp; distance &lt; moon.size + 2.0) {&#10;                double ringPhase = Math.sin(x * 0.5 + animationTimer * 2.0);&#10;                if (ringPhase &gt; 0.3) {&#10;                    return new StyledChar('─', AnsiColor.BRIGHT_BLACK, currentSkyColor, null);&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getPulsarEffect(int x, int y) {&#10;        // Create a pulsing distant star/pulsar effect&#10;        double pulsarX = canvasWidth * 0.9;&#10;        double pulsarY = canvasHeight * 0.1;&#10;        double distance = Math.sqrt(Math.pow(x - pulsarX, 2) + Math.pow(y - pulsarY, 2));&#10;        &#10;        double pulseIntensity = Math.sin(pulsarTimer * 5.0) * 0.5 + 0.5;&#10;        double maxDistance = 2.0 + pulseIntensity * 3.0;&#10;        &#10;        if (distance &lt; maxDistance) {&#10;            double intensity = (1.0 - distance / maxDistance) * pulseIntensity;&#10;            if (intensity &gt; 0.3) {&#10;                char pulsarChar = intensity &gt; 0.8 ? '✦' : intensity &gt; 0.6 ? '*' : '·';&#10;                AnsiColor pulsarColor = intensity &gt; 0.7 ? AnsiColor.BRIGHT_MAGENTA : AnsiColor.MAGENTA;&#10;                return new StyledChar(pulsarChar, pulsarColor, currentSkyColor, null);&#10;            }&#10;        }&#10;        &#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public boolean tick() {&#10;        // Update animation timers&#10;        animationTimer += animationSpeed;&#10;        particleTimer += particleSpeed;&#10;        auroraTimer += auroraSpeed;&#10;        pulsarTimer += 0.05;&#10;        skyTransitionTimer += 0.001;&#10;        &#10;        // Slowly transition sky color&#10;        if (skyTransitionTimer &gt; Math.PI * 2) {&#10;            skyTransitionTimer = 0.0;&#10;            currentSkyColor = alienSkyColors[random.nextInt(alienSkyColors.length)];&#10;        }&#10;        &#10;        // Update floating particles&#10;        for (FloatingParticle particle : particles) {&#10;            particle.x += Math.cos(particle.direction) * particle.speed;&#10;            particle.y += Math.sin(particle.direction) * particle.speed;&#10;            particle.phase += particle.pulseSpeed;&#10;            &#10;            // Wrap particles around screen&#10;            if (particle.x &lt; 0) particle.x = canvasWidth;&#10;            if (particle.x &gt; canvasWidth) particle.x = 0;&#10;            if (particle.y &lt; 0) particle.y = canvasHeight;&#10;            if (particle.y &gt; canvasHeight) particle.y = 0;&#10;            &#10;            // Occasionally change direction&#10;            if (random.nextDouble() &lt; 0.001) {&#10;                particle.direction += (random.nextDouble() - 0.5) * 0.5;&#10;            }&#10;        }&#10;        &#10;        // Update aurora strips&#10;        for (AuroraStrip strip : auroraStrips) {&#10;            strip.y += strip.flowSpeed;&#10;            if (strip.y &gt; canvasHeight) {&#10;                strip.y = -5.0;&#10;                strip.x = random.nextDouble() * canvasWidth;&#10;            }&#10;        }&#10;        &#10;        return true;&#10;    }&#10;&#10;    // Setter methods for dynamic control&#10;    public void setAlienSkyColor(AnsiColor color) {&#10;        this.currentSkyColor = color;&#10;    }&#10;&#10;    public void triggerSkyTransition() {&#10;        this.currentSkyColor = alienSkyColors[random.nextInt(alienSkyColors.length)];&#10;    }&#10;&#10;    public void addRandomParticleBurst() {&#10;        // Add temporary particle burst effect&#10;        for (int i = 0; i &lt; 20; i++) {&#10;            particles.add(new FloatingParticle(&#10;                canvasWidth * 0.5,&#10;                canvasHeight * 0.5,&#10;                random.nextDouble() * 0.1 + 0.05,&#10;                random.nextDouble() * Math.PI * 2,&#10;                0.8 + random.nextDouble() * 0.2,&#10;                0.0,&#10;                0.1&#10;            ));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Alien moon class representing celestial bodies in the alien sky&#10;     */&#10;    private static class AlienMoon {&#10;        double x, y;           // Relative position (0.0 to 1.0)&#10;        double size;           // Radius in pixels&#10;        AnsiColor coreColor;&#10;        AnsiColor surfaceColor;&#10;        char coreChar;&#10;        char surfaceChar;&#10;        char edgeChar;&#10;        boolean hasRings;&#10;        double orbitSpeed;&#10;&#10;        AlienMoon(double x, double y, double size, AnsiColor coreColor, AnsiColor surfaceColor,&#10;                 char coreChar, char surfaceChar, char edgeChar, boolean hasRings, double orbitSpeed) {&#10;            this.x = x;&#10;            this.y = y;&#10;            this.size = size;&#10;            this.coreColor = coreColor;&#10;            this.surfaceColor = surfaceColor;&#10;            this.coreChar = coreChar;&#10;            this.surfaceChar = surfaceChar;&#10;            this.edgeChar = edgeChar;&#10;            this.hasRings = hasRings;&#10;            this.orbitSpeed = orbitSpeed;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Floating particle class for atmospheric effects&#10;     */&#10;    private static class FloatingParticle {&#10;        double x, y;&#10;        double speed;&#10;        double direction;&#10;        double brightness;&#10;        double phase;&#10;        double pulseSpeed;&#10;&#10;        FloatingParticle(double x, double y, double speed, double direction, &#10;                        double brightness, double phase, double pulseSpeed) {&#10;            this.x = x;&#10;            this.y = y;&#10;            this.speed = speed;&#10;            this.direction = direction;&#10;            this.brightness = brightness;&#10;            this.phase = phase;&#10;            this.pulseSpeed = pulseSpeed;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Aurora strip class for alien atmospheric light shows&#10;     */&#10;    private static class AuroraStrip {&#10;        double x, y;&#10;        double flowSpeed;&#10;        double intensity;&#10;        double phaseOffset;&#10;&#10;        AuroraStrip(double x, double y, double flowSpeed, double intensity, double phaseOffset) {&#10;            this.x = x;&#10;            this.y = y;&#10;            this.flowSpeed = flowSpeed;&#10;            this.intensity = intensity;&#10;            this.phaseOffset = phaseOffset;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>