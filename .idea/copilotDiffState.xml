<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/RaycastingDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/RaycastingDemo.java" />
              <option name="originalContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.BorderLayout;&#10;import com.consolemaster.Box;&#10;import com.consolemaster.Composite;&#10;import com.consolemaster.DefaultBorder;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.PositionConstraint;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.Text;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.DefaultMapProvider;&#10;import com.consolemaster.raycasting.MapProvider;&#10;import com.consolemaster.raycasting.EntryInfo;&#10;import com.consolemaster.raycasting.PictureTextureProvider;&#10;import com.consolemaster.raycasting.RegistryTextureProvider;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive raycasting demo showcasing first-person 3D perspective in a 2D world.&#10; * Features player movement, rotation, and different map environments using MapProvider.&#10; */&#10;@Slf4j&#10;public class RaycastingDemo {&#10;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static RaycastingCanvas raycastingCanvas;&#10;    private static int currentMapIndex = 0;&#10;    private static char[] wallEdgeStyles = {'│', '#', '*', '+'};&#10;    private static int currentWallEdgeStyleIndex = 0;&#10;&#10;    // Different map providers to showcase&#10;    private static final MapProvider[] MAP_PROVIDERS = {&#10;        // Simple map with basic walls and floors&#10;        new DefaultMapProvider(&quot;Simple Maze&quot;, new String[]{&#10;            &quot;########&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;#  ##  #&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;########&quot;&#10;        }),&#10;&#10;        // Advanced map with different EntryInfo types&#10;        createAdvancedMapProvider(),&#10;&#10;        // Textured map with various textures&#10;        createTexturedMapProvider(),&#10;&#10;        // Complex maze map&#10;        new DefaultMapProvider(&quot;Complex Maze&quot;, new String[]{&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# #### ## #### #&quot;,&#10;            &quot;#    #    #    #&quot;,&#10;            &quot;#### # ## # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# ## #### ## # #&quot;,&#10;            &quot;#  #      #  # #&quot;,&#10;            &quot;## # #### # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        }),&#10;&#10;        // Natural landscape with water and grass&#10;        createNaturalLandscapeProvider(),&#10;&#10;        // Castle dungeon with mixed entry types&#10;        createCastleMapProvider()&#10;    };&#10;&#10;    /**&#10;     * Creates an advanced map provider showcasing different EntryInfo features.&#10;     */&#10;    private static MapProvider createAdvancedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[8][12];&#10;&#10;        // Initialize with different floor types&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 3 == 0) {&#10;                    // Stone floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else if ((x + y) % 3 == 1) {&#10;                    // Grass floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else {&#10;                    // Sand floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character('°')&#10;                            .name(&quot;Sand Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                            .colorDark(AnsiColor.YELLOW)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create walls around the border using stone walls&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some glass walls (transparent but blocking)&#10;        map[2][3] = EntryInfo.createGlass();&#10;        map[2][4] = EntryInfo.createGlass();&#10;        map[2][5] = EntryInfo.createGlass();&#10;&#10;        // Add low walls (half height)&#10;        map[4][2] = EntryInfo.createLowWall();&#10;        map[4][3] = EntryInfo.createLowWall();&#10;        map[5][2] = EntryInfo.createLowWall();&#10;        map[5][3] = EntryInfo.createLowWall();&#10;&#10;        // Add brick walls with proper light/dark colors&#10;        map[3][7] = EntryInfo.createBrickWall();&#10;        map[3][8] = EntryInfo.createBrickWall();&#10;        map[4][7] = EntryInfo.createBrickWall();&#10;        map[4][8] = EntryInfo.createBrickWall();&#10;&#10;        // Add metal walls&#10;        map[6][7] = EntryInfo.createMetalWall();&#10;        map[6][8] = EntryInfo.createMetalWall();&#10;&#10;        // Add custom colored walls with specific light/dark combinations&#10;        EntryInfo greenWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Green Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo purpleWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Purple Wall&quot;)&#10;                .colorLight(AnsiColor.MAGENTA)&#10;                .colorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        map[6][4] = greenWall;&#10;        map[6][5] = greenWall;&#10;        map[5][9] = purpleWall;&#10;        map[6][9] = purpleWall;&#10;&#10;        // Add water area (blue floor)&#10;        EntryInfo water = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isFallthrough(true)&#10;                .isTransparent(true)&#10;                .character('~')&#10;                .name(&quot;Water&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(0.0)&#10;                .build();&#10;&#10;        map[3][9] = water;&#10;        map[3][10] = water;&#10;        map[4][9] = water;&#10;        map[4][10] = water;&#10;&#10;        return new DefaultMapProvider(&quot;Advanced Features&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a castle map with various EntryInfo types.&#10;     */&#10;    private static MapProvider createCastleMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with floors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create outer walls with stone&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add castle features with enhanced colors&#10;        EntryInfo tower = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('♦')&#10;                .name(&quot;Tower&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        EntryInfo gate = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isFallthrough(true)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Gate&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo courtyard = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Courtyard Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        // Place towers&#10;        map[2][2] = tower;&#10;        map[2][13] = tower;&#10;        map[9][2] = tower;&#10;        map[9][13] = tower;&#10;&#10;        // Create gates&#10;        map[5][0] = gate;&#10;        map[6][0] = gate;&#10;&#10;        // Add interior walls with different materials&#10;        for (int x = 4; x &lt; 12; x++) {&#10;            if (x != 7 &amp;&amp; x != 8) { // Leave doorway&#10;                if (x &lt; 8) {&#10;                    map[5][x] = EntryInfo.createBrickWall();&#10;                } else {&#10;                    map[5][x] = EntryInfo.createMetalWall();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add courtyard walls&#10;        map[7][3] = courtyard;&#10;        map[8][3] = courtyard;&#10;        map[7][12] = courtyard;&#10;        map[8][12] = courtyard;&#10;&#10;        return new DefaultMapProvider(&quot;Castle&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a natural landscape map with water and grass.&#10;     */&#10;    private static MapProvider createNaturalLandscapeProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][14];&#10;&#10;        // Initialize with grass floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass Floor&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create water areas&#10;        for (int y = 2; y &lt;= 3; y++) {&#10;            for (int x = 4; x &lt;= 9; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create island with trees&#10;        for (int y = 1; y &lt;= 8; y++) {&#10;            for (int x = 1; x &lt;= 12; x++) {&#10;                if (x == 1 || x == 12 || y == 1 || y == 8) {&#10;                    map[y][x] = EntryInfo.createStoneWall();&#10;                } else if ((x + y) % 4 == 0) {&#10;                    map[y][x] = EntryInfo.createTree();&#10;                }&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Natural Landscape&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a textured map provider showcasing various textures.&#10;     */&#10;    private static MapProvider createTexturedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some wooden walls&#10;        for (int i = 2; i &lt; 8; i++) {&#10;            map[i][3] = EntryInfo.createWoodenWall();&#10;            map[i][6] = EntryInfo.createWoodenWall();&#10;        }&#10;&#10;        // Add a water area&#10;        for (int y = 4; y &lt;= 5; y++) {&#10;            for (int x = 1; x &lt;= 8; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Textured Map&quot;, map);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(80, 25);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 4,&#10;                    screen.getHeight() - 4,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 5, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0,&#10;                &quot;Raycasting Demo - First Person 3D World (MapProvider)\n&quot; +&#10;                &quot;WASD: Move | Arrows: Rotate/Fine Move | M: Change Map | R: Reset\n&quot; +&#10;                &quot;E: Toggle Wall Edges | T: Edge Threshold | C: Edge Style | Q/ESC: Exit&quot;,&#10;                Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setContent(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create raycasting canvas with MapProvider&#10;            raycastingCanvas = new RaycastingCanvas(&quot;Raycasting World&quot;, 0, 0, MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;            raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;            raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;            raycastingCanvas.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Setup texture provider&#10;            setupTextureProvider(raycastingCanvas);&#10;&#10;            // Create status panel&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.LEFT);&#10;            statusText.setForegroundColor(AnsiColor.WHITE);&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 3, new DefaultBorder());&#10;            statusBox.setContent(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add all components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(raycastingCanvas);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Position the main container&#10;            screen.setContent(mainContainer);&#10;&#10;            // Register keyboard shortcuts&#10;            registerKeyboardControls(screen);&#10;&#10;            // Create and start the process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                // Update status text with MapProvider information&#10;                statusText.setText(String.format(&#10;                    &quot;Position: (%.1f, %.1f) | Angle: %.0f° | %s | Map: %s (%d/%d)&quot;,&#10;                    raycastingCanvas.getPlayerX(),&#10;                    raycastingCanvas.getPlayerY(),&#10;                    Math.toDegrees(raycastingCanvas.getPlayerAngle()),&#10;                    lastAction,&#10;                    raycastingCanvas.getMapProvider().getName(),&#10;                    currentMapIndex + 1,&#10;                    MAP_PROVIDERS.length&#10;                ));&#10;            });&#10;&#10;            log.info(&quot;Starting Raycasting Demo with MapProvider...&quot;);&#10;            processLoop.start();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error initializing Raycasting Demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    private static void registerKeyboardControls(ScreenCanvas screen) {&#10;        double moveSpeed = 0.1;&#10;        double rotateSpeed = 0.1;&#10;&#10;        // Movement controls&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed);&#10;            lastAction = &quot;Move Forward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;S&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed);&#10;            lastAction = &quot;Move Backward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-moveSpeed);&#10;            lastAction = &quot;Strafe Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(moveSpeed);&#10;            lastAction = &quot;Strafe Right&quot;;&#10;        });&#10;&#10;        // Rotation controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-rotateSpeed);&#10;            lastAction = &quot;Rotate Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(rotateSpeed);&#10;            lastAction = &quot;Rotate Right&quot;;&#10;        });&#10;&#10;        // Wall edge controls&#10;        screen.registerShortcut(&quot;E&quot;, () -&gt; {&#10;            raycastingCanvas.setDrawWallEdges(!raycastingCanvas.isDrawWallEdges());&#10;            lastAction = &quot;Wall Edges toggled&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            raycastingCanvas.setWallEdgeThreshold(&#10;                raycastingCanvas.getWallEdgeThreshold() + 0.1 &gt; 1.0 ? 0.0 : raycastingCanvas.getWallEdgeThreshold() + 0.1&#10;            );&#10;            lastAction = &quot;Edge Threshold changed&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            currentWallEdgeStyleIndex = (currentWallEdgeStyleIndex + 1) % wallEdgeStyles.length;&#10;            raycastingCanvas.setWallEdgeChar(wallEdgeStyles[currentWallEdgeStyleIndex]);&#10;            lastAction = &quot;Edge Character changed&quot;;&#10;        });&#10;&#10;        // Map change - now uses MapProvider&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            currentMapIndex = (currentMapIndex + 1) % MAP_PROVIDERS.length;&#10;            raycastingCanvas.setMapProvider(MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            lastAction = &quot;Changed to &quot; + MAP_PROVIDERS[currentMapIndex].getName();&#10;        });&#10;&#10;        // Reset player&#10;        screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setPlayerAngle(0.0);&#10;            lastAction = &quot;Player Reset&quot;;&#10;        });&#10;&#10;        // Fine movement controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed * 0.5);&#10;            lastAction = &quot;Move Forward (Slow)&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed * 0.5);&#10;            lastAction = &quot;Move Backward (Slow)&quot;;&#10;        });&#10;&#10;        // Exit&#10;        screen.registerShortcut(&quot;Q&quot;, () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESCAPE.name(), () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;    }&#10;&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Text buttonText = new Text(&quot;buttonText&quot;, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        buttonText.setBold(true);&#10;&#10;        Box button = new Box(&quot;button&quot;, 12, 3, new DefaultBorder());&#10;        button.setContent(buttonText);&#10;&#10;        return button;&#10;    }&#10;&#10;    /**&#10;     * Sets up the texture provider for the raycasting canvas.&#10;     */&#10;    private static void setupTextureProvider(RaycastingCanvas canvas) {&#10;        // Create a picture texture provider with various textures&#10;        PictureTextureProvider pictureProvider = new PictureTextureProvider();&#10;&#10;        // Add wood texture&#10;        String[] woodTexture = {&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood&quot;, woodTexture);&#10;&#10;        // Add brick texture&#10;        String[] brickTexture = {&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;brick&quot;, brickTexture);&#10;&#10;        // Add stone texture&#10;        String[] stoneTexture = {&#10;            &quot;█▓▒░░▒▓█&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;░      ░&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;█▓▒░░▒▓█&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone&quot;, stoneTexture);&#10;&#10;        // Add metal texture&#10;        String[] metalTexture = {&#10;            &quot;========&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;--------&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;========&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;metal&quot;, metalTexture);&#10;&#10;        // Create registry provider and add the picture provider&#10;        RegistryTextureProvider registryProvider = new RegistryTextureProvider();&#10;        registryProvider.addProvider(pictureProvider);&#10;&#10;        // Set the texture provider&#10;        canvas.setTextureProvider(registryProvider);&#10;&#10;        log.info(&quot;Texture provider set up with &quot; + pictureProvider.getTexturePaths().length + &quot; textures&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.BorderLayout;&#10;import com.consolemaster.Box;&#10;import com.consolemaster.Composite;&#10;import com.consolemaster.DefaultBorder;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.PositionConstraint;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.Text;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.DefaultMapProvider;&#10;import com.consolemaster.raycasting.MapProvider;&#10;import com.consolemaster.raycasting.EntryInfo;&#10;import com.consolemaster.raycasting.PictureTextureProvider;&#10;import com.consolemaster.raycasting.RegistryTextureProvider;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive raycasting demo showcasing first-person 3D perspective in a 2D world.&#10; * Features player movement, rotation, and different map environments using MapProvider.&#10; */&#10;@Slf4j&#10;public class RaycastingDemo {&#10;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static RaycastingCanvas raycastingCanvas;&#10;    private static int currentMapIndex = 0;&#10;    private static char[] wallEdgeStyles = {'│', '#', '*', '+'};&#10;    private static int currentWallEdgeStyleIndex = 0;&#10;&#10;    // Different map providers to showcase&#10;    private static final MapProvider[] MAP_PROVIDERS = {&#10;        // Simple map with basic walls and floors&#10;        new DefaultMapProvider(&quot;Simple Maze&quot;, new String[]{&#10;            &quot;########&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;#  ##  #&quot;,&#10;            &quot;#      #&quot;,&#10;            &quot;########&quot;&#10;        }),&#10;&#10;        // Advanced map with different EntryInfo types&#10;        createAdvancedMapProvider(),&#10;&#10;        // Textured map with various textures&#10;        createTexturedMapProvider(),&#10;&#10;        // Complex maze map&#10;        new DefaultMapProvider(&quot;Complex Maze&quot;, new String[]{&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# #### ## #### #&quot;,&#10;            &quot;#    #    #    #&quot;,&#10;            &quot;#### # ## # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;# ## #### ## # #&quot;,&#10;            &quot;#  #      #  # #&quot;,&#10;            &quot;## # #### # ####&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        }),&#10;&#10;        // Natural landscape with water and grass&#10;        createNaturalLandscapeProvider(),&#10;&#10;        // Castle dungeon with mixed entry types&#10;        createCastleMapProvider()&#10;    };&#10;&#10;    /**&#10;     * Creates an advanced map provider showcasing different EntryInfo features.&#10;     */&#10;    private static MapProvider createAdvancedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[8][12];&#10;&#10;        // Initialize with different floor types&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                if ((x + y) % 3 == 0) {&#10;                    // Stone floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character('.')&#10;                            .name(&quot;Stone Floor&quot;)&#10;                            .colorLight(AnsiColor.WHITE)&#10;                            .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else if ((x + y) % 3 == 1) {&#10;                    // Grass floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character(',')&#10;                            .name(&quot;Grass Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                            .colorDark(AnsiColor.GREEN)&#10;                            .height(0.0)&#10;                            .build();&#10;                } else {&#10;                    // Sand floor&#10;                    map[y][x] = EntryInfo.builder()&#10;                            .isWall(false)&#10;                            .isFallthrough(true)&#10;                            .isTransparent(true)&#10;                            .character('°')&#10;                            .name(&quot;Sand Floor&quot;)&#10;                            .colorLight(AnsiColor.BRIGHT_YELLOW)&#10;                            .colorDark(AnsiColor.YELLOW)&#10;                            .height(0.0)&#10;                            .build();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Create walls around the border using stone walls&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some glass walls (transparent but blocking)&#10;        map[2][3] = EntryInfo.createGlass();&#10;        map[2][4] = EntryInfo.createGlass();&#10;        map[2][5] = EntryInfo.createGlass();&#10;&#10;        // Add low walls (half height)&#10;        map[4][2] = EntryInfo.createLowWall();&#10;        map[4][3] = EntryInfo.createLowWall();&#10;        map[5][2] = EntryInfo.createLowWall();&#10;        map[5][3] = EntryInfo.createLowWall();&#10;&#10;        // Add brick walls with proper light/dark colors&#10;        map[3][7] = EntryInfo.createBrickWall();&#10;        map[3][8] = EntryInfo.createBrickWall();&#10;        map[4][7] = EntryInfo.createBrickWall();&#10;        map[4][8] = EntryInfo.createBrickWall();&#10;&#10;        // Add metal walls&#10;        map[6][7] = EntryInfo.createMetalWall();&#10;        map[6][8] = EntryInfo.createMetalWall();&#10;&#10;        // Add custom colored walls with specific light/dark combinations&#10;        EntryInfo greenWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Green Wall&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .height(1.0)&#10;                .build();&#10;&#10;        EntryInfo purpleWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('▓')&#10;                .name(&quot;Purple Wall&quot;)&#10;                .colorLight(AnsiColor.MAGENTA)&#10;                .colorDark(AnsiColor.BRIGHT_MAGENTA)&#10;                .height(1.2)&#10;                .build();&#10;&#10;        map[6][4] = greenWall;&#10;        map[6][5] = greenWall;&#10;        map[5][9] = purpleWall;&#10;        map[6][9] = purpleWall;&#10;&#10;        // Add water area (blue floor)&#10;        EntryInfo water = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isFallthrough(true)&#10;                .isTransparent(true)&#10;                .character('~')&#10;                .name(&quot;Water&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                .colorDark(AnsiColor.CYAN)&#10;                .height(0.0)&#10;                .build();&#10;&#10;        map[3][9] = water;&#10;        map[3][10] = water;&#10;        map[4][9] = water;&#10;        map[4][10] = water;&#10;&#10;        return new DefaultMapProvider(&quot;Advanced Features&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a castle map with various EntryInfo types.&#10;     */&#10;    private static MapProvider createCastleMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[12][16];&#10;&#10;        // Initialize with floors&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.createFloor();&#10;            }&#10;        }&#10;&#10;        // Create outer walls with stone&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add castle features with enhanced colors&#10;        EntryInfo tower = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('♦')&#10;                .name(&quot;Tower&quot;)&#10;                .colorLight(AnsiColor.BRIGHT_WHITE)&#10;                .colorDark(AnsiColor.WHITE)&#10;                .height(1.5)&#10;                .build();&#10;&#10;        EntryInfo gate = EntryInfo.builder()&#10;                .isWall(false)&#10;                .isFallthrough(true)&#10;                .isTransparent(true)&#10;                .character('|')&#10;                .name(&quot;Gate&quot;)&#10;                .colorLight(AnsiColor.YELLOW)&#10;                .colorDark(AnsiColor.BRIGHT_YELLOW)&#10;                .height(0.8)&#10;                .build();&#10;&#10;        EntryInfo courtyard = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('▒')&#10;                .name(&quot;Courtyard Wall&quot;)&#10;                .colorLight(AnsiColor.CYAN)&#10;                .colorDark(AnsiColor.BLUE)&#10;                .height(0.7)&#10;                .build();&#10;&#10;        // Place towers&#10;        map[2][2] = tower;&#10;        map[2][13] = tower;&#10;        map[9][2] = tower;&#10;        map[9][13] = tower;&#10;&#10;        // Create gates&#10;        map[5][0] = gate;&#10;        map[6][0] = gate;&#10;&#10;        // Add interior walls with different materials&#10;        for (int x = 4; x &lt; 12; x++) {&#10;            if (x != 7 &amp;&amp; x != 8) { // Leave doorway&#10;                if (x &lt; 8) {&#10;                    map[5][x] = EntryInfo.createBrickWall();&#10;                } else {&#10;                    map[5][x] = EntryInfo.createMetalWall();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add courtyard walls&#10;        map[7][3] = courtyard;&#10;        map[8][3] = courtyard;&#10;        map[7][12] = courtyard;&#10;        map[8][12] = courtyard;&#10;&#10;        return new DefaultMapProvider(&quot;Castle&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a natural landscape map with water and grass.&#10;     */&#10;    private static MapProvider createNaturalLandscapeProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][14];&#10;&#10;        // Initialize with grass floor&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass Floor&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create water areas&#10;        for (int y = 2; y &lt;= 3; y++) {&#10;            for (int x = 4; x &lt;= 9; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Create island with trees&#10;        for (int y = 1; y &lt;= 8; y++) {&#10;            for (int x = 1; x &lt;= 12; x++) {&#10;                if (x == 1 || x == 12 || y == 1 || y == 8) {&#10;                    map[y][x] = EntryInfo.createStoneWall();&#10;                } else if ((x + y) % 4 == 0) {&#10;                    map[y][x] = EntryInfo.createTree();&#10;                }&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Natural Landscape&quot;, map);&#10;    }&#10;&#10;    /**&#10;     * Creates a textured map provider showcasing various textures.&#10;     */&#10;    private static MapProvider createTexturedMapProvider() {&#10;        EntryInfo[][] map = new EntryInfo[10][10];&#10;&#10;        // Initialize with grass texture&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            for (int x = 0; x &lt; map[y].length; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character(',')&#10;                        .name(&quot;Grass&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                        .colorDark(AnsiColor.GREEN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        // Add stone walls around the border&#10;        for (int x = 0; x &lt; map[0].length; x++) {&#10;            map[0][x] = EntryInfo.createStoneWall();&#10;            map[map.length - 1][x] = EntryInfo.createStoneWall();&#10;        }&#10;        for (int y = 0; y &lt; map.length; y++) {&#10;            map[y][0] = EntryInfo.createStoneWall();&#10;            map[y][map[0].length - 1] = EntryInfo.createStoneWall();&#10;        }&#10;&#10;        // Add some wooden walls&#10;        for (int i = 2; i &lt; 8; i++) {&#10;            map[i][3] = EntryInfo.createWoodenWall();&#10;            map[i][6] = EntryInfo.createWoodenWall();&#10;        }&#10;&#10;        // Add a water area&#10;        for (int y = 4; y &lt;= 5; y++) {&#10;            for (int x = 1; x &lt;= 8; x++) {&#10;                map[y][x] = EntryInfo.builder()&#10;                        .isWall(false)&#10;                        .isFallthrough(true)&#10;                        .isTransparent(true)&#10;                        .character('~')&#10;                        .name(&quot;Water&quot;)&#10;                        .colorLight(AnsiColor.BRIGHT_CYAN)&#10;                        .colorDark(AnsiColor.CYAN)&#10;                        .height(0.0)&#10;                        .build();&#10;            }&#10;        }&#10;&#10;        return new DefaultMapProvider(&quot;Textured Map&quot;, map);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(80, 25);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 4,&#10;                    screen.getHeight() - 4,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 5, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0,&#10;                &quot;Raycasting Demo - First Person 3D World (MapProvider)\n&quot; +&#10;                &quot;WASD: Move | Arrows: Rotate/Fine Move | M: Change Map | R: Reset\n&quot; +&#10;                &quot;E: Toggle Wall Edges | T: Edge Threshold | C: Edge Style | Q/ESC: Exit&quot;,&#10;                Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setContent(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create raycasting canvas with MapProvider&#10;            raycastingCanvas = new RaycastingCanvas(&quot;Raycasting World&quot;, 0, 0, MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;            raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;            raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;            raycastingCanvas.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Setup texture provider&#10;            setupTextureProvider(raycastingCanvas);&#10;&#10;            // Create status panel&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.LEFT);&#10;            statusText.setForegroundColor(AnsiColor.WHITE);&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 3, new DefaultBorder());&#10;            statusBox.setContent(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add all components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(raycastingCanvas);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Position the main container&#10;            screen.setContent(mainContainer);&#10;&#10;            // Register keyboard shortcuts&#10;            registerKeyboardControls(screen);&#10;&#10;            // Create and start the process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                // Update status text with MapProvider information&#10;                statusText.setText(String.format(&#10;                    &quot;Position: (%.1f, %.1f) | Angle: %.0f° | %s | Map: %s (%d/%d)&quot;,&#10;                    raycastingCanvas.getPlayerX(),&#10;                    raycastingCanvas.getPlayerY(),&#10;                    Math.toDegrees(raycastingCanvas.getPlayerAngle()),&#10;                    lastAction,&#10;                    raycastingCanvas.getMapProvider().getName(),&#10;                    currentMapIndex + 1,&#10;                    MAP_PROVIDERS.length&#10;                ));&#10;            });&#10;&#10;            log.info(&quot;Starting Raycasting Demo with MapProvider...&quot;);&#10;            processLoop.start();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error initializing Raycasting Demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    private static void registerKeyboardControls(ScreenCanvas screen) {&#10;        double moveSpeed = 0.1;&#10;        double rotateSpeed = 0.1;&#10;&#10;        // Movement controls&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed);&#10;            lastAction = &quot;Move Forward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;S&quot;, () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed);&#10;            lastAction = &quot;Move Backward&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-moveSpeed);&#10;            lastAction = &quot;Strafe Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(moveSpeed);&#10;            lastAction = &quot;Strafe Right&quot;;&#10;        });&#10;&#10;        // Rotation controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-rotateSpeed);&#10;            lastAction = &quot;Rotate Left&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(rotateSpeed);&#10;            lastAction = &quot;Rotate Right&quot;;&#10;        });&#10;&#10;        // Wall edge controls&#10;        screen.registerShortcut(&quot;E&quot;, () -&gt; {&#10;            raycastingCanvas.setDrawWallEdges(!raycastingCanvas.isDrawWallEdges());&#10;            lastAction = &quot;Wall Edges toggled&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            raycastingCanvas.setWallEdgeThreshold(&#10;                raycastingCanvas.getWallEdgeThreshold() + 0.1 &gt; 1.0 ? 0.0 : raycastingCanvas.getWallEdgeThreshold() + 0.1&#10;            );&#10;            lastAction = &quot;Edge Threshold changed&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            currentWallEdgeStyleIndex = (currentWallEdgeStyleIndex + 1) % wallEdgeStyles.length;&#10;            raycastingCanvas.setWallEdgeChar(wallEdgeStyles[currentWallEdgeStyleIndex]);&#10;            lastAction = &quot;Edge Character changed&quot;;&#10;        });&#10;&#10;        // Map change - now uses MapProvider&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            currentMapIndex = (currentMapIndex + 1) % MAP_PROVIDERS.length;&#10;            raycastingCanvas.setMapProvider(MAP_PROVIDERS[currentMapIndex]);&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            lastAction = &quot;Changed to &quot; + MAP_PROVIDERS[currentMapIndex].getName();&#10;        });&#10;&#10;        // Reset player&#10;        screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;            raycastingCanvas.setPlayerPosition(2.5, 2.5);&#10;            raycastingCanvas.setPlayerAngle(0.0);&#10;            lastAction = &quot;Player Reset&quot;;&#10;        });&#10;&#10;        // Fine movement controls&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(moveSpeed * 0.5);&#10;            lastAction = &quot;Move Forward (Slow)&quot;;&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-moveSpeed * 0.5);&#10;            lastAction = &quot;Move Backward (Slow)&quot;;&#10;        });&#10;&#10;        // Exit&#10;        screen.registerShortcut(&quot;Q&quot;, () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESCAPE.name(), () -&gt; {&#10;            log.info(&quot;Exiting Raycasting Demo...&quot;);&#10;            System.exit(0);&#10;        });&#10;    }&#10;&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Text buttonText = new Text(&quot;buttonText&quot;, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        buttonText.setBold(true);&#10;&#10;        Box button = new Box(&quot;button&quot;, 12, 3, new DefaultBorder());&#10;        button.setContent(buttonText);&#10;&#10;        return button;&#10;    }&#10;&#10;    /**&#10;     * Sets up the texture provider for the raycasting canvas.&#10;     */&#10;    private static void setupTextureProvider(RaycastingCanvas canvas) {&#10;        // Create a picture texture provider with various textures&#10;        PictureTextureProvider pictureProvider = new PictureTextureProvider();&#10;        &#10;        // Add wood texture&#10;        String[] woodTexture = {&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;,&#10;            &quot;###|||###&quot;,&#10;            &quot;|||###|||&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;wood&quot;, woodTexture);&#10;        &#10;        // Add brick texture&#10;        String[] brickTexture = {&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;,&#10;            &quot;  ##  ##  &quot;,&#10;            &quot;##  ##  ##&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;brick&quot;, brickTexture);&#10;        &#10;        // Add stone texture&#10;        String[] stoneTexture = {&#10;            &quot;█▓▒░░▒▓█&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;░      ░&quot;,&#10;            &quot;▒░    ░▒&quot;,&#10;            &quot;▓▒░  ░▒▓&quot;,&#10;            &quot;█▓▒░░▒▓█&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;stone&quot;, stoneTexture);&#10;        &#10;        // Add metal texture&#10;        String[] metalTexture = {&#10;            &quot;========&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;--------&quot;,&#10;            &quot;||||||||&quot;,&#10;            &quot;========&quot;&#10;        };&#10;        pictureProvider.addTexture(&quot;metal&quot;, metalTexture);&#10;        &#10;        // Create registry provider and add the picture provider&#10;        RegistryTextureProvider registryProvider = new RegistryTextureProvider();&#10;        registryProvider.addProvider(pictureProvider);&#10;        &#10;        // Set the texture provider&#10;        canvas.setTextureProvider(registryProvider);&#10;        &#10;        log.info(&quot;Texture provider set up with &quot; + pictureProvider.getTexturePaths().length + &quot; textures&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/PictureTexture.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/PictureTexture.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.StyledChar;&#10;&#10;/**&#10; * A texture implementation that uses string arrays as source data.&#10; * The texture is scaled to fit the requested dimensions and uses EntryInfo for coloring.&#10; */&#10;public class PictureTexture implements Texture {&#10;&#10;    private final String[] textureData;&#10;    private final String name;&#10;&#10;    /**&#10;     * Creates a new picture texture from string array data.&#10;     *&#10;     * @param name the name of this texture&#10;     * @param textureData array of strings representing the texture pattern&#10;     */&#10;    public PictureTexture(String name, String[] textureData) {&#10;        this.name = name;&#10;        this.textureData = textureData != null ? textureData.clone() : new String[]{&quot;#&quot;};&#10;    }&#10;&#10;    @Override&#10;    public StyledChar[][] picture(int width, int height, EntryInfo entry, boolean light) {&#10;        if (width &lt;= 0 || height &lt;= 0) {&#10;            return new StyledChar[0][0];&#10;        }&#10;&#10;        StyledChar[][] result = new StyledChar[height][width];&#10;&#10;        // Get source dimensions&#10;        int sourceHeight = textureData.length;&#10;        int sourceWidth = sourceHeight &gt; 0 ? textureData[0].length() : 1;&#10;&#10;        // Ensure we have valid source dimensions&#10;        if (sourceHeight == 0 || sourceWidth == 0) {&#10;            // Fill with default character&#10;            char defaultChar = entry != null ? entry.getCharacter() : '#';&#10;            AnsiColor defaultColor = entry != null ? entry.getColor(light) : AnsiColor.WHITE;&#10;&#10;            for (int y = 0; y &lt; height; y++) {&#10;                for (int x = 0; x &lt; width; x++) {&#10;                    result[y][x] = new StyledChar(defaultChar, defaultColor);&#10;                }&#10;            }&#10;            return result;&#10;        }&#10;&#10;        // Get colors from entry&#10;        AnsiColor textureColor = entry != null ? entry.getColor(!light) : AnsiColor.WHITE;&#10;        if (textureColor == null) {&#10;            textureColor = AnsiColor.WHITE;&#10;        }&#10;&#10;        // Scale texture to fit dimensions&#10;        for (int y = 0; y &lt; height; y++) {&#10;            for (int x = 0; x &lt; width; x++) {&#10;                // Map target coordinates to source coordinates&#10;                int sourceY = (y * sourceHeight) / height;&#10;                int sourceX = (x * sourceWidth) / width;&#10;&#10;                // Ensure we don't go out of bounds&#10;                sourceY = Math.min(sourceY, sourceHeight - 1);&#10;                sourceX = Math.min(sourceX, Math.min(sourceWidth - 1, textureData[sourceY].length() - 1));&#10;&#10;                // Get character from source&#10;                char textureChar;&#10;                if (sourceY &gt;= 0 &amp;&amp; sourceY &lt; textureData.length &amp;&amp;&#10;                    sourceX &gt;= 0 &amp;&amp; sourceX &lt; textureData[sourceY].length()) {&#10;                    textureChar = textureData[sourceY].charAt(sourceX);&#10;                } else {&#10;                    textureChar = entry != null ? entry.getCharacter() : '#';&#10;                }&#10;&#10;                // Create styled character&#10;                result[y][x] = new StyledChar(textureChar, textureColor);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Gets the name of this texture.&#10;     */&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    /**&#10;     * Gets the source texture data.&#10;     */&#10;    public String[] getTextureData() {&#10;        return textureData.clone();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.StyledChar;&#10;&#10;/**&#10; * A texture implementation that uses string arrays as source data with coordinate-based access.&#10; * The texture provides direct access to styled characters at specific coordinates.&#10; */&#10;public class PictureTexture implements Texture {&#10;&#10;    private final String[] textureData;&#10;    private final String name;&#10;    private final int width;&#10;    private final int height;&#10;    private final EntryInfo entry;&#10;    private final boolean light;&#10;&#10;    /**&#10;     * Creates a new picture texture from string array data with specified dimensions and rendering parameters.&#10;     *&#10;     * @param name the name of this texture&#10;     * @param textureData array of strings representing the texture pattern&#10;     * @param width the target width for rendering&#10;     * @param height the target height for rendering&#10;     * @param entry the entry info for color and lighting information&#10;     * @param light true for light rendering, false for dark rendering&#10;     */&#10;    public PictureTexture(String name, String[] textureData, int width, int height, EntryInfo entry, boolean light) {&#10;        this.name = name;&#10;        this.textureData = textureData != null ? textureData.clone() : new String[]{&quot;#&quot;};&#10;        this.width = width;&#10;        this.height = height;&#10;        this.entry = entry;&#10;        this.light = light;&#10;    }&#10;&#10;    @Override&#10;    public StyledChar getCharAt(int x, int y) {&#10;        // Check bounds&#10;        if (x &lt; 0 || x &gt;= width || y &lt; 0 || y &gt;= height) {&#10;            return null;&#10;        }&#10;&#10;        // Get source dimensions&#10;        int sourceHeight = textureData.length;&#10;        int sourceWidth = sourceHeight &gt; 0 ? textureData[0].length() : 1;&#10;&#10;        // Handle empty texture data&#10;        if (sourceHeight == 0 || sourceWidth == 0) {&#10;            char defaultChar = entry != null ? entry.getCharacter() : '#';&#10;            AnsiColor defaultColor = entry != null ? entry.getColor(!light) : AnsiColor.WHITE;&#10;            return new StyledChar(defaultChar, defaultColor);&#10;        }&#10;&#10;        // Map target coordinates to source coordinates&#10;        int sourceY = (y * sourceHeight) / height;&#10;        int sourceX = (x * sourceWidth) / width;&#10;&#10;        // Ensure we don't go out of bounds&#10;        sourceY = Math.min(sourceY, sourceHeight - 1);&#10;        sourceX = Math.min(sourceX, Math.min(sourceWidth - 1, textureData[sourceY].length() - 1));&#10;&#10;        // Get character from source&#10;        char textureChar;&#10;        if (sourceY &gt;= 0 &amp;&amp; sourceY &lt; textureData.length &amp;&amp;&#10;            sourceX &gt;= 0 &amp;&amp; sourceX &lt; textureData[sourceY].length()) {&#10;            textureChar = textureData[sourceY].charAt(sourceX);&#10;        } else {&#10;            textureChar = entry != null ? entry.getCharacter() : '#';&#10;        }&#10;&#10;        // Get color from entry&#10;        AnsiColor textureColor = entry != null ? entry.getColor(!light) : AnsiColor.WHITE;&#10;        if (textureColor == null) {&#10;            textureColor = AnsiColor.WHITE;&#10;        }&#10;&#10;        return new StyledChar(textureChar, textureColor);&#10;    }&#10;&#10;    /**&#10;     * Gets the name of this texture.&#10;     */&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    /**&#10;     * Gets the source texture data.&#10;     */&#10;    public String[] getTextureData() {&#10;        return textureData.clone();&#10;    }&#10;&#10;    /**&#10;     * Gets the configured width.&#10;     */&#10;    public int getWidth() {&#10;        return width;&#10;    }&#10;&#10;    /**&#10;     * Gets the configured height.&#10;     */&#10;    public int getHeight() {&#10;        return height;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/PictureTextureProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/PictureTextureProvider.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * A texture provider that manages picture textures from string arrays.&#10; * Textures are stored in a map and can be retrieved by path.&#10; */&#10;public class PictureTextureProvider implements TextureProvider {&#10;&#10;    private final Map&lt;String, PictureTexture&gt; textures = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Adds a texture to this provider.&#10;     *&#10;     * @param path the path/name for the texture&#10;     * @param textureData the string array representing the texture&#10;     */&#10;    public void addTexture(String path, String[] textureData) {&#10;        if (path != null &amp;&amp; textureData != null) {&#10;            textures.put(path, new PictureTexture(path, textureData));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Adds a picture texture to this provider.&#10;     *&#10;     * @param path the path/name for the texture&#10;     * @param texture the picture texture&#10;     */&#10;    public void addTexture(String path, PictureTexture texture) {&#10;        if (path != null &amp;&amp; texture != null) {&#10;            textures.put(path, texture);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Texture getTexture(String path) {&#10;        return textures.get(path);&#10;    }&#10;&#10;    /**&#10;     * Removes a texture from this provider.&#10;     *&#10;     * @param path the path of the texture to remove&#10;     * @return the removed texture, or null if not found&#10;     */&#10;    public PictureTexture removeTexture(String path) {&#10;        return textures.remove(path);&#10;    }&#10;&#10;    /**&#10;     * Checks if this provider has a texture with the given path.&#10;     *&#10;     * @param path the path to check&#10;     * @return true if the texture exists&#10;     */&#10;    public boolean hasTexture(String path) {&#10;        return textures.containsKey(path);&#10;    }&#10;&#10;    /**&#10;     * Gets all texture paths managed by this provider.&#10;     *&#10;     * @return array of texture paths&#10;     */&#10;    public String[] getTexturePaths() {&#10;        return textures.keySet().toArray(new String[0]);&#10;    }&#10;&#10;    /**&#10;     * Clears all textures from this provider.&#10;     */&#10;    public void clear() {&#10;        textures.clear();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * A texture provider that manages picture textures from string arrays.&#10; * Acts as a transformator that creates textures with specified dimensions and parameters.&#10; */&#10;public class PictureTextureProvider implements TextureProvider {&#10;&#10;    private final Map&lt;String, String[]&gt; textureDataMap = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Adds a texture to this provider.&#10;     *&#10;     * @param path the path/name for the texture&#10;     * @param textureData the string array representing the texture&#10;     */&#10;    public void addTexture(String path, String[] textureData) {&#10;        if (path != null &amp;&amp; textureData != null) {&#10;            textureDataMap.put(path, textureData.clone());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Texture getTexture(String path, int width, int height, EntryInfo entry, boolean light) {&#10;        String[] textureData = textureDataMap.get(path);&#10;        if (textureData == null) {&#10;            return null;&#10;        }&#10;&#10;        return new PictureTexture(path, textureData, width, height, entry, light);&#10;    }&#10;&#10;    /**&#10;     * Removes a texture from this provider.&#10;     *&#10;     * @param path the path of the texture to remove&#10;     * @return true if the texture was removed, false if not found&#10;     */&#10;    public boolean removeTexture(String path) {&#10;        return textureDataMap.remove(path) != null;&#10;    }&#10;&#10;    /**&#10;     * Checks if this provider has a texture with the given path.&#10;     *&#10;     * @param path the path to check&#10;     * @return true if the texture exists&#10;     */&#10;    public boolean hasTexture(String path) {&#10;        return textureDataMap.containsKey(path);&#10;    }&#10;&#10;    /**&#10;     * Gets all texture paths managed by this provider.&#10;     *&#10;     * @return array of texture paths&#10;     */&#10;    public String[] getTexturePaths() {&#10;        return textureDataMap.keySet().toArray(new String[0]);&#10;    }&#10;&#10;    /**&#10;     * Clears all textures from this provider.&#10;     */&#10;    public void clear() {&#10;        textureDataMap.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/RaycastingCanvas.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/RaycastingCanvas.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.Canvas;&#10;import com.consolemaster.Graphics;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.StyledChar;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;/**&#10; * A canvas that renders a 3D world using raycasting technique.&#10; * The world is represented by a MapProvider where '#' represents walls and ' ' represents empty space.&#10; */&#10;@Getter&#10;@Setter&#10;public class RaycastingCanvas extends Canvas {&#10;&#10;    private MapProvider mapProvider;&#10;    private double playerX = 2.0;&#10;    private double playerY = 2.0;&#10;    private double playerAngle = 0.0;&#10;    private double fov = Math.PI / 3; // 60 degrees field of view&#10;    private char wallChar = '█';&#10;    private char floorChar = '.';&#10;    private char ceilingChar = ' ';&#10;    private char wallEdgeChar = '│'; // Character for vertical wall edges&#10;    private AnsiColor wallColor = AnsiColor.WHITE;&#10;    private AnsiColor floorColor = AnsiColor.YELLOW;&#10;    private AnsiColor ceilingColor = AnsiColor.BLUE;&#10;    private AnsiColor wallEdgeColor = AnsiColor.BRIGHT_WHITE; // Color for wall edges&#10;    private boolean drawWallEdges = true; // Enable/disable wall edge drawing&#10;    private double wallEdgeThreshold = 0.3; // Threshold for detecting wall edges&#10;    private TextureProvider textureProvider; // Texture provider for wall textures&#10;&#10;    public RaycastingCanvas(String name, int width, int height) {&#10;        super(name, width, height);&#10;        this.mapProvider = new DefaultMapProvider();&#10;    }&#10;&#10;    public RaycastingCanvas(String name, int width, int height, MapProvider mapProvider) {&#10;        super(name, width, height);&#10;        this.mapProvider = mapProvider != null ? mapProvider : new DefaultMapProvider();&#10;    }&#10;&#10;    @Override&#10;    public void paint(Graphics graphics) {&#10;        if (!isVisible() || mapProvider == null) {&#10;            return;&#10;        }&#10;&#10;        int mapWidth = mapProvider.getWidth();&#10;        int mapHeight = mapProvider.getHeight();&#10;&#10;        // Store raycast results for edge detection&#10;        RaycastResult[] raycastResults = new RaycastResult[getWidth()];&#10;&#10;        // First pass: Cast rays and store results&#10;        for (int x = 0; x &lt; getWidth(); x++) {&#10;            // Calculate ray angle&#10;            double rayAngle = playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;&#10;            // Ray direction&#10;            double rayDirX = Math.cos(rayAngle);&#10;            double rayDirY = Math.sin(rayAngle);&#10;&#10;            // Perform ray casting using DDA algorithm&#10;            raycastResults[x] = castRayDDA(rayDirX, rayDirY, mapWidth, mapHeight);&#10;        }&#10;&#10;        // Second pass: Render columns with edge detection&#10;        for (int x = 0; x &lt; getWidth(); x++) {&#10;            RaycastResult result = raycastResults[x];&#10;&#10;            // Calculate ray angle for fish-eye correction&#10;            double rayAngle = playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;&#10;            // Ray direction (needed for floor rendering)&#10;            double rayDirX = Math.cos(rayAngle);&#10;            double rayDirY = Math.sin(rayAngle);&#10;&#10;            // Apply fish-eye correction&#10;            double correctedDistance = result.distance * Math.cos(rayAngle - playerAngle);&#10;&#10;            // Prevent division by zero&#10;            if (correctedDistance &lt; 0.1) correctedDistance = 0.1;&#10;&#10;            // Get entry info for this hit&#10;            EntryInfo hitEntry = result.hitEntry;&#10;&#10;            // Calculate wall height based on corrected distance and entry height&#10;            int baseWallHeight = (int) (getHeight() / correctedDistance);&#10;            int wallHeight = (int) (baseWallHeight * hitEntry.getHeight());&#10;&#10;            // Calculate wall start and end positions&#10;            int wallStart = Math.max(0, (getHeight() - wallHeight) / 2);&#10;            int wallEnd = Math.min(getHeight() - 1, (getHeight() + wallHeight) / 2);&#10;&#10;            // Check if this column is a wall edge&#10;            boolean isLeftEdge = isWallEdge(raycastResults, x, true);&#10;            boolean isRightEdge = isWallEdge(raycastResults, x, false);&#10;&#10;            // Draw ceiling&#10;            for (int y = 0; y &lt; wallStart; y++) {&#10;                graphics.drawStyledChar(x, y, ceilingChar, ceilingColor, null);&#10;            }&#10;&#10;            // Draw wall with EntryInfo properties and texture support&#10;            renderWallColumn(graphics, x, wallStart, wallEnd, hitEntry, result.isVerticalWall,&#10;                           correctedDistance, isLeftEdge, isRightEdge);&#10;&#10;            // Draw floor with dynamic colors based on floor EntryInfo&#10;            for (int y = wallEnd + 1; y &lt; getHeight(); y++) {&#10;                // Calculate floor position using ray casting for floor rendering&#10;                double floorDistance = getHeight() / (2.0 * y - getHeight());&#10;&#10;                // Calculate floor world position&#10;                double floorX = playerX + floorDistance * rayDirX;&#10;                double floorY = playerY + floorDistance * rayDirY;&#10;&#10;                // Get floor EntryInfo at calculated position&#10;                int floorMapX = (int) Math.floor(floorX);&#10;                int floorMapY = (int) Math.floor(floorY);&#10;&#10;                AnsiColor floorColorToDraw = floorColor; // Default fallback&#10;                char floorCharToDraw = floorChar;&#10;&#10;                // Check if floor position is within map bounds&#10;                if (floorMapX &gt;= 0 &amp;&amp; floorMapX &lt; mapWidth &amp;&amp; floorMapY &gt;= 0 &amp;&amp; floorMapY &lt; mapHeight) {&#10;                    EntryInfo floorEntry = mapProvider.getEntry(floorMapX, floorMapY);&#10;&#10;                    // Use floor entry colors if available&#10;                    if (floorEntry.getColor(false) != null) {&#10;                        floorColorToDraw = floorEntry.getColor(false); // Use light color for floor&#10;                    }&#10;&#10;                    // Use floor entry character if it's not a wall&#10;                    if (!floorEntry.isWall() &amp;&amp; floorEntry.getCharacter() != ' ') {&#10;                        floorCharToDraw = floorEntry.getCharacter();&#10;                    }&#10;                }&#10;&#10;                graphics.drawStyledChar(x, y, floorCharToDraw, floorColorToDraw, null);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Determines if a column represents a wall edge by comparing distances with neighboring columns.&#10;     */&#10;    private boolean isWallEdge(RaycastResult[] raycastResults, int x, boolean checkLeft) {&#10;        if (!drawWallEdges || raycastResults == null) {&#10;            return false;&#10;        }&#10;&#10;        int neighborX = checkLeft ? x - 1 : x + 1;&#10;&#10;        // Check bounds&#10;        if (neighborX &lt; 0 || neighborX &gt;= raycastResults.length) {&#10;            return true; // Edge of screen is always an edge&#10;        }&#10;&#10;        RaycastResult current = raycastResults[x];&#10;        RaycastResult neighbor = raycastResults[neighborX];&#10;&#10;        if (current == null || neighbor == null) {&#10;            return false;&#10;        }&#10;&#10;        // Calculate difference in corrected distances&#10;        double currentDistance = current.distance * Math.cos(getCurrentRayAngle(x) - playerAngle);&#10;        double neighborDistance = neighbor.distance * Math.cos(getCurrentRayAngle(neighborX) - playerAngle);&#10;&#10;        // Edge detected if distance difference exceeds threshold&#10;        double distanceDiff = Math.abs(currentDistance - neighborDistance);&#10;        return distanceDiff &gt; wallEdgeThreshold;&#10;    }&#10;&#10;    /**&#10;     * Calculate the ray angle for a given column x.&#10;     */&#10;    private double getCurrentRayAngle(int x) {&#10;        return playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;    }&#10;&#10;    /**&#10;     * Result of a raycast operation.&#10;     */&#10;    private static class RaycastResult {&#10;        final double distance;&#10;        final boolean isVerticalWall;&#10;        final EntryInfo hitEntry;&#10;&#10;        RaycastResult(double distance, boolean isVerticalWall, EntryInfo hitEntry) {&#10;            this.distance = distance;&#10;            this.isVerticalWall = isVerticalWall;&#10;            this.hitEntry = hitEntry;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cast a ray using DDA (Digital Differential Analyzer) algorithm for better performance and accuracy.&#10;     */&#10;    private RaycastResult castRayDDA(double rayDirX, double rayDirY, int mapWidth, int mapHeight) {&#10;        // Current position&#10;        int mapX = (int) playerX;&#10;        int mapY = (int) playerY;&#10;&#10;        // Length of ray from current position to next x or y side&#10;        double deltaDistX = Math.abs(1.0 / rayDirX);&#10;        double deltaDistY = Math.abs(1.0 / rayDirY);&#10;&#10;        // Calculate step and initial sideDist&#10;        int stepX, stepY;&#10;        double sideDistX, sideDistY;&#10;&#10;        if (rayDirX &lt; 0) {&#10;            stepX = -1;&#10;            sideDistX = (playerX - mapX) * deltaDistX;&#10;        } else {&#10;            stepX = 1;&#10;            sideDistX = (mapX + 1.0 - playerX) * deltaDistX;&#10;        }&#10;&#10;        if (rayDirY &lt; 0) {&#10;            stepY = -1;&#10;            sideDistY = (playerY - mapY) * deltaDistY;&#10;        } else {&#10;            stepY = 1;&#10;            sideDistY = (mapY + 1.0 - playerY) * deltaDistY;&#10;        }&#10;&#10;        // Perform DDA&#10;        boolean hit = false;&#10;        boolean side = false; // false = x-side, true = y-side&#10;        EntryInfo hitEntry = EntryInfo.createWall(); // Default to wall&#10;&#10;        while (!hit) {&#10;            // Jump to next map square, either in x-direction, or in y-direction&#10;            if (sideDistX &lt; sideDistY) {&#10;                sideDistX += deltaDistX;&#10;                mapX += stepX;&#10;                side = false;&#10;            } else {&#10;                sideDistY += deltaDistY;&#10;                mapY += stepY;&#10;                side = true;&#10;            }&#10;&#10;            // Check if ray is out of bounds&#10;            if (mapX &lt; 0 || mapX &gt;= mapWidth || mapY &lt; 0 || mapY &gt;= mapHeight) {&#10;                hit = true;&#10;                hitEntry = EntryInfo.createWall(); // Out of bounds is treated as wall&#10;                break;&#10;            }&#10;&#10;            // Get entry info at current position&#10;            EntryInfo currentEntry = mapProvider.getEntry(mapX, mapY);&#10;&#10;            // Check if ray has hit a solid entry (wall or non-transparent obstacle)&#10;            if (currentEntry.isWall()) {&#10;                hit = true;&#10;                hitEntry = currentEntry;&#10;            }&#10;        }&#10;&#10;        // Calculate distance&#10;        double perpWallDist;&#10;        if (!side) {&#10;            perpWallDist = (mapX - playerX + (1 - stepX) / 2) / rayDirX;&#10;        } else {&#10;            perpWallDist = (mapY - playerY + (1 - stepY) / 2) / rayDirY;&#10;        }&#10;&#10;        return new RaycastResult(Math.abs(perpWallDist), !side, hitEntry);&#10;    }&#10;&#10;    /**&#10;     * Get wall shading based on distance and wall orientation.&#10;     */&#10;    private AnsiColor getWallShade(double distance, boolean isVerticalWall) {&#10;        // Darker shading for horizontal walls to create depth effect&#10;        AnsiColor baseColor = isVerticalWall ? wallColor :&#10;            (wallColor == AnsiColor.WHITE ? AnsiColor.BRIGHT_BLACK : wallColor);&#10;&#10;        // Distance-based shading&#10;        if (distance &gt; 8.0) {&#10;            return AnsiColor.BLACK;&#10;        } else if (distance &gt; 4.0) {&#10;            return AnsiColor.BRIGHT_BLACK;&#10;        } else {&#10;            return baseColor;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Move the player forward/backward.&#10;     */&#10;    public void movePlayer(double distance) {&#10;        double newX = playerX + Math.cos(playerAngle) * distance;&#10;        double newY = playerY + Math.sin(playerAngle) * distance;&#10;&#10;        // Check collision&#10;        if (isValidPosition(newX, newY)) {&#10;            playerX = newX;&#10;            playerY = newY;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Strafe the player left/right.&#10;     */&#10;    public void strafePlayer(double distance) {&#10;        double strafeAngle = playerAngle + Math.PI / 2;&#10;        double newX = playerX + Math.cos(strafeAngle) * distance;&#10;        double newY = playerY + Math.sin(strafeAngle) * distance;&#10;&#10;        // Check collision&#10;        if (isValidPosition(newX, newY)) {&#10;            playerX = newX;&#10;            playerY = newY;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Rotate the player.&#10;     */&#10;    public void rotatePlayer(double angle) {&#10;        playerAngle += angle;&#10;        // Normalize angle to [0, 2π]&#10;        while (playerAngle &lt; 0) playerAngle += 2 * Math.PI;&#10;        while (playerAngle &gt;= 2 * Math.PI) playerAngle -= 2 * Math.PI;&#10;    }&#10;&#10;    /**&#10;     * Check if a position is valid for player movement.&#10;     * Uses EntryInfo properties to determine walkability.&#10;     */&#10;    public boolean isValidPosition(double x, double y) {&#10;        if (mapProvider == null) return false;&#10;&#10;        int mapX = (int) Math.floor(x);&#10;        int mapY = (int) Math.floor(y);&#10;&#10;        // Check bounds&#10;        if (mapX &lt; 0 || mapX &gt;= mapProvider.getWidth() || mapY &lt; 0 || mapY &gt;= mapProvider.getHeight()) {&#10;            return false;&#10;        }&#10;&#10;        // Check if the position allows movement using EntryInfo&#10;        EntryInfo entry = mapProvider.getEntry(mapX, mapY);&#10;        return entry.isFallthrough();&#10;    }&#10;&#10;    /**&#10;     * Set a new map provider for the raycasting world.&#10;     */&#10;    public void setMapProvider(MapProvider mapProvider) {&#10;        this.mapProvider = mapProvider != null ? mapProvider : new DefaultMapProvider();&#10;&#10;        // Reset player position to a safe location if current position is invalid&#10;        if (!isValidPosition(playerX, playerY)) {&#10;            // Find first walkable space&#10;            for (int y = 0; y &lt; this.mapProvider.getHeight(); y++) {&#10;                for (int x = 0; x &lt; this.mapProvider.getWidth(); x++) {&#10;                    EntryInfo entry = this.mapProvider.getEntry(x, y);&#10;                    if (entry.isFallthrough()) {&#10;                        playerX = x + 0.5;&#10;                        playerY = y + 0.5;&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a new map for the raycasting world (creates a DefaultMapProvider).&#10;     */&#10;    public void setMap(String[] map) {&#10;        setMapProvider(new DefaultMapProvider(&quot;Custom Map&quot;, map));&#10;    }&#10;&#10;    /**&#10;     * Set player position.&#10;     */&#10;    public void setPlayerPosition(double x, double y) {&#10;        if (isValidPosition(x, y)) {&#10;            this.playerX = x;&#10;            this.playerY = y;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the current map as string array for backward compatibility.&#10;     */&#10;    public String[] getMap() {&#10;        if (mapProvider == null) return new String[0];&#10;&#10;        if (mapProvider instanceof DefaultMapProvider defaultProvider) {&#10;            return defaultProvider.toStringArray();&#10;        }&#10;&#10;        // Fallback: convert EntryInfo back to characters&#10;        String[] map = new String[mapProvider.getHeight()];&#10;        for (int y = 0; y &lt; mapProvider.getHeight(); y++) {&#10;            StringBuilder row = new StringBuilder();&#10;            for (int x = 0; x &lt; mapProvider.getWidth(); x++) {&#10;                row.append(mapProvider.getEntry(x, y).toCharacter());&#10;            }&#10;            map[y] = row.toString();&#10;        }&#10;        return map;&#10;    }&#10;&#10;    /**&#10;     * Render a column of the wall with support for textures and EntryInfo properties.&#10;     */&#10;    private void renderWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                  boolean isVertical, double distance, boolean isLeftEdge, boolean isRightEdge) {&#10;&#10;        // Check if texture is available&#10;        Texture texture = null;&#10;        if (textureProvider != null &amp;&amp; hitEntry.getTexture() != null) {&#10;            texture = textureProvider.getTexture(hitEntry.getTexture());&#10;        }&#10;&#10;        // If texture is available, render using texture&#10;        if (texture != null) {&#10;            renderTexturedWallColumn(graphics, x, wallStart, wallEnd, hitEntry, texture, !isVertical, isLeftEdge, isRightEdge);&#10;        } else {&#10;            // Render without texture using EntryInfo properties&#10;            renderPlainWallColumn(graphics, x, wallStart, wallEnd, hitEntry, isVertical, distance, isLeftEdge, isRightEdge);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Render a textured wall column.&#10;     */&#10;    private void renderTexturedWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                         Texture texture, boolean isDarkSide, boolean isLeftEdge, boolean isRightEdge) {&#10;        int wallHeight = wallEnd - wallStart + 1;&#10;&#10;        // Generate texture for the wall column (1 pixel wide, wallHeight tall)&#10;        StyledChar[][] textureData = texture.picture(1, wallHeight, hitEntry, !isDarkSide);&#10;&#10;        for (int y = wallStart; y &lt;= wallEnd; y++) {&#10;            int textureY = y - wallStart;&#10;&#10;            // Get character and color from texture&#10;            char charToDraw = hitEntry.getCharacter();&#10;            AnsiColor colorToDraw = hitEntry.getColor(isDarkSide);&#10;&#10;            if (textureData.length &gt; 0 &amp;&amp; textureData[0].length &gt; 0 &amp;&amp;&#10;                textureY &gt;= 0 &amp;&amp; textureY &lt; textureData.length) {&#10;                StyledChar textureChar = textureData[textureY][0];&#10;                if (textureChar != null) {&#10;                    charToDraw = textureChar.getCharacter();&#10;                    colorToDraw = textureChar.getForegroundColor();&#10;                }&#10;            }&#10;&#10;            // Apply edge rendering if enabled&#10;            if (drawWallEdges &amp;&amp; (isLeftEdge || isRightEdge)) {&#10;                charToDraw = wallEdgeChar;&#10;                colorToDraw = wallEdgeColor;&#10;            }&#10;&#10;            graphics.drawStyledChar(x, y, charToDraw, colorToDraw, null);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Render a plain wall column without texture.&#10;     */&#10;    private void renderPlainWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                      boolean isVertical, double distance, boolean isLeftEdge, boolean isRightEdge) {&#10;        // Use EntryInfo color based on wall orientation (light for vertical, dark for horizontal)&#10;        boolean isDarkSide = !isVertical;&#10;        AnsiColor entryColor = hitEntry.getColor(isDarkSide);&#10;        AnsiColor colorToDraw = entryColor != null ? entryColor : getWallShade(distance, isVertical);&#10;&#10;        // Use EntryInfo character or fall back to default wall char&#10;        char charToDraw = hitEntry.getCharacter() != ' ' ? hitEntry.getCharacter() : wallChar;&#10;&#10;        // Draw edge lines if enabled and this is an edge&#10;        if (drawWallEdges &amp;&amp; (isLeftEdge || isRightEdge)) {&#10;            charToDraw = wallEdgeChar;&#10;            colorToDraw = wallEdgeColor;&#10;        }&#10;&#10;        for (int y = wallStart; y &lt;= wallEnd; y++) {&#10;            graphics.drawStyledChar(x, y, charToDraw, colorToDraw, null);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.Canvas;&#10;import com.consolemaster.Graphics;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.StyledChar;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;/**&#10; * A canvas that renders a 3D world using raycasting technique.&#10; * The world is represented by a MapProvider where '#' represents walls and ' ' represents empty space.&#10; */&#10;@Getter&#10;@Setter&#10;public class RaycastingCanvas extends Canvas {&#10;&#10;    private MapProvider mapProvider;&#10;    private double playerX = 2.0;&#10;    private double playerY = 2.0;&#10;    private double playerAngle = 0.0;&#10;    private double fov = Math.PI / 3; // 60 degrees field of view&#10;    private char wallChar = '█';&#10;    private char floorChar = '.';&#10;    private char ceilingChar = ' ';&#10;    private char wallEdgeChar = '│'; // Character for vertical wall edges&#10;    private AnsiColor wallColor = AnsiColor.WHITE;&#10;    private AnsiColor floorColor = AnsiColor.YELLOW;&#10;    private AnsiColor ceilingColor = AnsiColor.BLUE;&#10;    private AnsiColor wallEdgeColor = AnsiColor.BRIGHT_WHITE; // Color for wall edges&#10;    private boolean drawWallEdges = true; // Enable/disable wall edge drawing&#10;    private double wallEdgeThreshold = 0.3; // Threshold for detecting wall edges&#10;    private TextureProvider textureProvider; // Texture provider for wall textures&#10;&#10;    public RaycastingCanvas(String name, int width, int height) {&#10;        super(name, width, height);&#10;        this.mapProvider = new DefaultMapProvider();&#10;    }&#10;&#10;    public RaycastingCanvas(String name, int width, int height, MapProvider mapProvider) {&#10;        super(name, width, height);&#10;        this.mapProvider = mapProvider != null ? mapProvider : new DefaultMapProvider();&#10;    }&#10;&#10;    @Override&#10;    public void paint(Graphics graphics) {&#10;        if (!isVisible() || mapProvider == null) {&#10;            return;&#10;        }&#10;&#10;        int mapWidth = mapProvider.getWidth();&#10;        int mapHeight = mapProvider.getHeight();&#10;&#10;        // Store raycast results for edge detection&#10;        RaycastResult[] raycastResults = new RaycastResult[getWidth()];&#10;&#10;        // First pass: Cast rays and store results&#10;        for (int x = 0; x &lt; getWidth(); x++) {&#10;            // Calculate ray angle&#10;            double rayAngle = playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;&#10;            // Ray direction&#10;            double rayDirX = Math.cos(rayAngle);&#10;            double rayDirY = Math.sin(rayAngle);&#10;&#10;            // Perform ray casting using DDA algorithm&#10;            raycastResults[x] = castRayDDA(rayDirX, rayDirY, mapWidth, mapHeight);&#10;        }&#10;&#10;        // Second pass: Render columns with edge detection&#10;        for (int x = 0; x &lt; getWidth(); x++) {&#10;            RaycastResult result = raycastResults[x];&#10;&#10;            // Calculate ray angle for fish-eye correction&#10;            double rayAngle = playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;&#10;            // Ray direction (needed for floor rendering)&#10;            double rayDirX = Math.cos(rayAngle);&#10;            double rayDirY = Math.sin(rayAngle);&#10;&#10;            // Apply fish-eye correction&#10;            double correctedDistance = result.distance * Math.cos(rayAngle - playerAngle);&#10;&#10;            // Prevent division by zero&#10;            if (correctedDistance &lt; 0.1) correctedDistance = 0.1;&#10;&#10;            // Get entry info for this hit&#10;            EntryInfo hitEntry = result.hitEntry;&#10;&#10;            // Calculate wall height based on corrected distance and entry height&#10;            int baseWallHeight = (int) (getHeight() / correctedDistance);&#10;            int wallHeight = (int) (baseWallHeight * hitEntry.getHeight());&#10;&#10;            // Calculate wall start and end positions&#10;            int wallStart = Math.max(0, (getHeight() - wallHeight) / 2);&#10;            int wallEnd = Math.min(getHeight() - 1, (getHeight() + wallHeight) / 2);&#10;&#10;            // Check if this column is a wall edge&#10;            boolean isLeftEdge = isWallEdge(raycastResults, x, true);&#10;            boolean isRightEdge = isWallEdge(raycastResults, x, false);&#10;&#10;            // Draw ceiling&#10;            for (int y = 0; y &lt; wallStart; y++) {&#10;                graphics.drawStyledChar(x, y, ceilingChar, ceilingColor, null);&#10;            }&#10;&#10;            // Draw wall with EntryInfo properties and texture support&#10;            renderWallColumn(graphics, x, wallStart, wallEnd, hitEntry, result.isVerticalWall,&#10;                           correctedDistance, isLeftEdge, isRightEdge);&#10;&#10;            // Draw floor with dynamic colors based on floor EntryInfo&#10;            for (int y = wallEnd + 1; y &lt; getHeight(); y++) {&#10;                // Calculate floor position using ray casting for floor rendering&#10;                double floorDistance = getHeight() / (2.0 * y - getHeight());&#10;&#10;                // Calculate floor world position&#10;                double floorX = playerX + floorDistance * rayDirX;&#10;                double floorY = playerY + floorDistance * rayDirY;&#10;&#10;                // Get floor EntryInfo at calculated position&#10;                int floorMapX = (int) Math.floor(floorX);&#10;                int floorMapY = (int) Math.floor(floorY);&#10;&#10;                AnsiColor floorColorToDraw = floorColor; // Default fallback&#10;                char floorCharToDraw = floorChar;&#10;&#10;                // Check if floor position is within map bounds&#10;                if (floorMapX &gt;= 0 &amp;&amp; floorMapX &lt; mapWidth &amp;&amp; floorMapY &gt;= 0 &amp;&amp; floorMapY &lt; mapHeight) {&#10;                    EntryInfo floorEntry = mapProvider.getEntry(floorMapX, floorMapY);&#10;&#10;                    // Use floor entry colors if available&#10;                    if (floorEntry.getColor(false) != null) {&#10;                        floorColorToDraw = floorEntry.getColor(false); // Use light color for floor&#10;                    }&#10;&#10;                    // Use floor entry character if it's not a wall&#10;                    if (!floorEntry.isWall() &amp;&amp; floorEntry.getCharacter() != ' ') {&#10;                        floorCharToDraw = floorEntry.getCharacter();&#10;                    }&#10;                }&#10;&#10;                graphics.drawStyledChar(x, y, floorCharToDraw, floorColorToDraw, null);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Determines if a column represents a wall edge by comparing distances with neighboring columns.&#10;     */&#10;    private boolean isWallEdge(RaycastResult[] raycastResults, int x, boolean checkLeft) {&#10;        if (!drawWallEdges || raycastResults == null) {&#10;            return false;&#10;        }&#10;&#10;        int neighborX = checkLeft ? x - 1 : x + 1;&#10;&#10;        // Check bounds&#10;        if (neighborX &lt; 0 || neighborX &gt;= raycastResults.length) {&#10;            return true; // Edge of screen is always an edge&#10;        }&#10;&#10;        RaycastResult current = raycastResults[x];&#10;        RaycastResult neighbor = raycastResults[neighborX];&#10;&#10;        if (current == null || neighbor == null) {&#10;            return false;&#10;        }&#10;&#10;        // Calculate difference in corrected distances&#10;        double currentDistance = current.distance * Math.cos(getCurrentRayAngle(x) - playerAngle);&#10;        double neighborDistance = neighbor.distance * Math.cos(getCurrentRayAngle(neighborX) - playerAngle);&#10;&#10;        // Edge detected if distance difference exceeds threshold&#10;        double distanceDiff = Math.abs(currentDistance - neighborDistance);&#10;        return distanceDiff &gt; wallEdgeThreshold;&#10;    }&#10;&#10;    /**&#10;     * Calculate the ray angle for a given column x.&#10;     */&#10;    private double getCurrentRayAngle(int x) {&#10;        return playerAngle - (fov / 2) + ((double) x / getWidth()) * fov;&#10;    }&#10;&#10;    /**&#10;     * Result of a raycast operation.&#10;     */&#10;    private static class RaycastResult {&#10;        final double distance;&#10;        final boolean isVerticalWall;&#10;        final EntryInfo hitEntry;&#10;&#10;        RaycastResult(double distance, boolean isVerticalWall, EntryInfo hitEntry) {&#10;            this.distance = distance;&#10;            this.isVerticalWall = isVerticalWall;&#10;            this.hitEntry = hitEntry;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cast a ray using DDA (Digital Differential Analyzer) algorithm for better performance and accuracy.&#10;     */&#10;    private RaycastResult castRayDDA(double rayDirX, double rayDirY, int mapWidth, int mapHeight) {&#10;        // Current position&#10;        int mapX = (int) playerX;&#10;        int mapY = (int) playerY;&#10;&#10;        // Length of ray from current position to next x or y side&#10;        double deltaDistX = Math.abs(1.0 / rayDirX);&#10;        double deltaDistY = Math.abs(1.0 / rayDirY);&#10;&#10;        // Calculate step and initial sideDist&#10;        int stepX, stepY;&#10;        double sideDistX, sideDistY;&#10;&#10;        if (rayDirX &lt; 0) {&#10;            stepX = -1;&#10;            sideDistX = (playerX - mapX) * deltaDistX;&#10;        } else {&#10;            stepX = 1;&#10;            sideDistX = (mapX + 1.0 - playerX) * deltaDistX;&#10;        }&#10;&#10;        if (rayDirY &lt; 0) {&#10;            stepY = -1;&#10;            sideDistY = (playerY - mapY) * deltaDistY;&#10;        } else {&#10;            stepY = 1;&#10;            sideDistY = (mapY + 1.0 - playerY) * deltaDistY;&#10;        }&#10;&#10;        // Perform DDA&#10;        boolean hit = false;&#10;        boolean side = false; // false = x-side, true = y-side&#10;        EntryInfo hitEntry = EntryInfo.createWall(); // Default to wall&#10;&#10;        while (!hit) {&#10;            // Jump to next map square, either in x-direction, or in y-direction&#10;            if (sideDistX &lt; sideDistY) {&#10;                sideDistX += deltaDistX;&#10;                mapX += stepX;&#10;                side = false;&#10;            } else {&#10;                sideDistY += deltaDistY;&#10;                mapY += stepY;&#10;                side = true;&#10;            }&#10;&#10;            // Check if ray is out of bounds&#10;            if (mapX &lt; 0 || mapX &gt;= mapWidth || mapY &lt; 0 || mapY &gt;= mapHeight) {&#10;                hit = true;&#10;                hitEntry = EntryInfo.createWall(); // Out of bounds is treated as wall&#10;                break;&#10;            }&#10;&#10;            // Get entry info at current position&#10;            EntryInfo currentEntry = mapProvider.getEntry(mapX, mapY);&#10;&#10;            // Check if ray has hit a solid entry (wall or non-transparent obstacle)&#10;            if (currentEntry.isWall()) {&#10;                hit = true;&#10;                hitEntry = currentEntry;&#10;            }&#10;        }&#10;&#10;        // Calculate distance&#10;        double perpWallDist;&#10;        if (!side) {&#10;            perpWallDist = (mapX - playerX + (1 - stepX) / 2) / rayDirX;&#10;        } else {&#10;            perpWallDist = (mapY - playerY + (1 - stepY) / 2) / rayDirY;&#10;        }&#10;&#10;        return new RaycastResult(Math.abs(perpWallDist), !side, hitEntry);&#10;    }&#10;&#10;    /**&#10;     * Get wall shading based on distance and wall orientation.&#10;     */&#10;    private AnsiColor getWallShade(double distance, boolean isVerticalWall) {&#10;        // Darker shading for horizontal walls to create depth effect&#10;        AnsiColor baseColor = isVerticalWall ? wallColor :&#10;            (wallColor == AnsiColor.WHITE ? AnsiColor.BRIGHT_BLACK : wallColor);&#10;&#10;        // Distance-based shading&#10;        if (distance &gt; 8.0) {&#10;            return AnsiColor.BLACK;&#10;        } else if (distance &gt; 4.0) {&#10;            return AnsiColor.BRIGHT_BLACK;&#10;        } else {&#10;            return baseColor;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Move the player forward/backward.&#10;     */&#10;    public void movePlayer(double distance) {&#10;        double newX = playerX + Math.cos(playerAngle) * distance;&#10;        double newY = playerY + Math.sin(playerAngle) * distance;&#10;&#10;        // Check collision&#10;        if (isValidPosition(newX, newY)) {&#10;            playerX = newX;&#10;            playerY = newY;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Strafe the player left/right.&#10;     */&#10;    public void strafePlayer(double distance) {&#10;        double strafeAngle = playerAngle + Math.PI / 2;&#10;        double newX = playerX + Math.cos(strafeAngle) * distance;&#10;        double newY = playerY + Math.sin(strafeAngle) * distance;&#10;&#10;        // Check collision&#10;        if (isValidPosition(newX, newY)) {&#10;            playerX = newX;&#10;            playerY = newY;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Rotate the player.&#10;     */&#10;    public void rotatePlayer(double angle) {&#10;        playerAngle += angle;&#10;        // Normalize angle to [0, 2π]&#10;        while (playerAngle &lt; 0) playerAngle += 2 * Math.PI;&#10;        while (playerAngle &gt;= 2 * Math.PI) playerAngle -= 2 * Math.PI;&#10;    }&#10;&#10;    /**&#10;     * Check if a position is valid for player movement.&#10;     * Uses EntryInfo properties to determine walkability.&#10;     */&#10;    public boolean isValidPosition(double x, double y) {&#10;        if (mapProvider == null) return false;&#10;&#10;        int mapX = (int) Math.floor(x);&#10;        int mapY = (int) Math.floor(y);&#10;&#10;        // Check bounds&#10;        if (mapX &lt; 0 || mapX &gt;= mapProvider.getWidth() || mapY &lt; 0 || mapY &gt;= mapProvider.getHeight()) {&#10;            return false;&#10;        }&#10;&#10;        // Check if the position allows movement using EntryInfo&#10;        EntryInfo entry = mapProvider.getEntry(mapX, mapY);&#10;        return entry.isFallthrough();&#10;    }&#10;&#10;    /**&#10;     * Set a new map provider for the raycasting world.&#10;     */&#10;    public void setMapProvider(MapProvider mapProvider) {&#10;        this.mapProvider = mapProvider != null ? mapProvider : new DefaultMapProvider();&#10;&#10;        // Reset player position to a safe location if current position is invalid&#10;        if (!isValidPosition(playerX, playerY)) {&#10;            // Find first walkable space&#10;            for (int y = 0; y &lt; this.mapProvider.getHeight(); y++) {&#10;                for (int x = 0; x &lt; this.mapProvider.getWidth(); x++) {&#10;                    EntryInfo entry = this.mapProvider.getEntry(x, y);&#10;                    if (entry.isFallthrough()) {&#10;                        playerX = x + 0.5;&#10;                        playerY = y + 0.5;&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set a new map for the raycasting world (creates a DefaultMapProvider).&#10;     */&#10;    public void setMap(String[] map) {&#10;        setMapProvider(new DefaultMapProvider(&quot;Custom Map&quot;, map));&#10;    }&#10;&#10;    /**&#10;     * Set player position.&#10;     */&#10;    public void setPlayerPosition(double x, double y) {&#10;        if (isValidPosition(x, y)) {&#10;            this.playerX = x;&#10;            this.playerY = y;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the current map as string array for backward compatibility.&#10;     */&#10;    public String[] getMap() {&#10;        if (mapProvider == null) return new String[0];&#10;&#10;        if (mapProvider instanceof DefaultMapProvider defaultProvider) {&#10;            return defaultProvider.toStringArray();&#10;        }&#10;&#10;        // Fallback: convert EntryInfo back to characters&#10;        String[] map = new String[mapProvider.getHeight()];&#10;        for (int y = 0; y &lt; mapProvider.getHeight(); y++) {&#10;            StringBuilder row = new StringBuilder();&#10;            for (int x = 0; x &lt; mapProvider.getWidth(); x++) {&#10;                row.append(mapProvider.getEntry(x, y).toCharacter());&#10;            }&#10;            map[y] = row.toString();&#10;        }&#10;        return map;&#10;    }&#10;&#10;    /**&#10;     * Render a column of the wall with support for textures and EntryInfo properties.&#10;     */&#10;    private void renderWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                  boolean isVertical, double distance, boolean isLeftEdge, boolean isRightEdge) {&#10;&#10;        // Check if texture is available&#10;        Texture texture = null;&#10;        if (textureProvider != null &amp;&amp; hitEntry.getTexture() != null) {&#10;            int wallHeight = wallEnd - wallStart + 1;&#10;            texture = textureProvider.getTexture(hitEntry.getTexture(), 1, wallHeight, hitEntry, !isVertical);&#10;        }&#10;&#10;        // If texture is available, render using texture&#10;        if (texture != null) {&#10;            renderTexturedWallColumn(graphics, x, wallStart, wallEnd, hitEntry, texture, !isVertical, isLeftEdge, isRightEdge);&#10;        } else {&#10;            // Render without texture using EntryInfo properties&#10;            renderPlainWallColumn(graphics, x, wallStart, wallEnd, hitEntry, isVertical, distance, isLeftEdge, isRightEdge);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Render a textured wall column.&#10;     */&#10;    private void renderTexturedWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                         Texture texture, boolean isDarkSide, boolean isLeftEdge, boolean isRightEdge) {&#10;        int wallHeight = wallEnd - wallStart + 1;&#10;        &#10;        for (int y = wallStart; y &lt;= wallEnd; y++) {&#10;            int textureY = y - wallStart;&#10;            &#10;            // Get character and color directly from texture using coordinates&#10;            StyledChar textureChar = texture.getCharAt(0, textureY);&#10;            &#10;            char charToDraw = hitEntry.getCharacter();&#10;            AnsiColor colorToDraw = hitEntry.getColor(isDarkSide);&#10;            &#10;            if (textureChar != null) {&#10;                charToDraw = textureChar.getCharacter();&#10;                colorToDraw = textureChar.getForegroundColor();&#10;            }&#10;&#10;            // Apply edge rendering if enabled&#10;            if (drawWallEdges &amp;&amp; (isLeftEdge || isRightEdge)) {&#10;                charToDraw = wallEdgeChar;&#10;                colorToDraw = wallEdgeColor;&#10;            }&#10;&#10;            graphics.drawStyledChar(x, y, charToDraw, colorToDraw, null);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Render a plain wall column without texture.&#10;     */&#10;    private void renderPlainWallColumn(Graphics graphics, int x, int wallStart, int wallEnd, EntryInfo hitEntry,&#10;                                      boolean isVertical, double distance, boolean isLeftEdge, boolean isRightEdge) {&#10;        // Use EntryInfo color based on wall orientation (light for vertical, dark for horizontal)&#10;        boolean isDarkSide = !isVertical;&#10;        AnsiColor entryColor = hitEntry.getColor(isDarkSide);&#10;        AnsiColor colorToDraw = entryColor != null ? entryColor : getWallShade(distance, isVertical);&#10;&#10;        // Use EntryInfo character or fall back to default wall char&#10;        char charToDraw = hitEntry.getCharacter() != ' ' ? hitEntry.getCharacter() : wallChar;&#10;&#10;        // Draw edge lines if enabled and this is an edge&#10;        if (drawWallEdges &amp;&amp; (isLeftEdge || isRightEdge)) {&#10;            charToDraw = wallEdgeChar;&#10;            colorToDraw = wallEdgeColor;&#10;        }&#10;&#10;        for (int y = wallStart; y &lt;= wallEnd; y++) {&#10;            graphics.drawStyledChar(x, y, charToDraw, colorToDraw, null);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/RegistryTextureProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/RegistryTextureProvider.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * A texture provider registry that manages multiple texture providers and caches lookups.&#10; * The registry searches through providers in order and caches which provider can provide each texture.&#10; */&#10;public class RegistryTextureProvider implements TextureProvider {&#10;&#10;    private final List&lt;TextureProvider&gt; providers = new ArrayList&lt;&gt;();&#10;    private final Map&lt;String, TextureProvider&gt; cache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Adds a texture provider to this registry.&#10;     * Providers are searched in the order they were added.&#10;     *&#10;     * @param provider the texture provider to add&#10;     */&#10;    public void addProvider(TextureProvider provider) {&#10;        if (provider != null &amp;&amp; !providers.contains(provider)) {&#10;            providers.add(provider);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Removes a texture provider from this registry.&#10;     * Also clears any cached entries for this provider.&#10;     *&#10;     * @param provider the provider to remove&#10;     * @return true if the provider was removed&#10;     */&#10;    public boolean removeProvider(TextureProvider provider) {&#10;        boolean removed = providers.remove(provider);&#10;        if (removed) {&#10;            // Clear cache entries for this provider&#10;            cache.entrySet().removeIf(entry -&gt; entry.getValue() == provider);&#10;        }&#10;        return removed;&#10;    }&#10;&#10;    @Override&#10;    public Texture getTexture(String path) {&#10;        if (path == null) {&#10;            return null;&#10;        }&#10;&#10;        // Check cache first&#10;        TextureProvider cachedProvider = cache.get(path);&#10;        if (cachedProvider != null) {&#10;            Texture texture = cachedProvider.getTexture(path);&#10;            if (texture != null) {&#10;                return texture;&#10;            } else {&#10;                // Cached provider no longer has this texture, remove from cache&#10;                cache.remove(path);&#10;            }&#10;        }&#10;&#10;        // Search through providers&#10;        for (TextureProvider provider : providers) {&#10;            Texture texture = provider.getTexture(path);&#10;            if (texture != null) {&#10;                // Cache this provider for future lookups&#10;                cache.put(path, provider);&#10;                return texture;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Clears the texture cache.&#10;     * This forces the registry to re-search providers on the next lookup.&#10;     */&#10;    public void clearCache() {&#10;        cache.clear();&#10;    }&#10;&#10;    /**&#10;     * Gets the number of registered providers.&#10;     *&#10;     * @return the number of providers&#10;     */&#10;    public int getProviderCount() {&#10;        return providers.size();&#10;    }&#10;&#10;    /**&#10;     * Gets all registered providers.&#10;     *&#10;     * @return a copy of the provider list&#10;     */&#10;    public List&lt;TextureProvider&gt; getProviders() {&#10;        return new ArrayList&lt;&gt;(providers);&#10;    }&#10;&#10;    /**&#10;     * Checks if a texture is available from any provider.&#10;     * This method uses the cache and will update it if needed.&#10;     *&#10;     * @param path the texture path to check&#10;     * @return true if the texture is available&#10;     */&#10;    public boolean hasTexture(String path) {&#10;        return getTexture(path) != null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * A texture provider registry that manages multiple texture providers and caches lookups.&#10; * The registry searches through providers in order and caches which provider can provide each texture.&#10; * Acts as a transformator that delegates to registered providers.&#10; */&#10;public class RegistryTextureProvider implements TextureProvider {&#10;&#10;    private final List&lt;TextureProvider&gt; providers = new ArrayList&lt;&gt;();&#10;    private final Map&lt;String, TextureProvider&gt; cache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Adds a texture provider to this registry.&#10;     * Providers are searched in the order they were added.&#10;     *&#10;     * @param provider the texture provider to add&#10;     */&#10;    public void addProvider(TextureProvider provider) {&#10;        if (provider != null &amp;&amp; !providers.contains(provider)) {&#10;            providers.add(provider);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Removes a texture provider from this registry.&#10;     * Also clears any cached entries for this provider.&#10;     *&#10;     * @param provider the provider to remove&#10;     * @return true if the provider was removed&#10;     */&#10;    public boolean removeProvider(TextureProvider provider) {&#10;        boolean removed = providers.remove(provider);&#10;        if (removed) {&#10;            // Clear cache entries for this provider&#10;            cache.entrySet().removeIf(entry -&gt; entry.getValue() == provider);&#10;        }&#10;        return removed;&#10;    }&#10;&#10;    @Override&#10;    public Texture getTexture(String path, int width, int height, EntryInfo entry, boolean light) {&#10;        if (path == null) {&#10;            return null;&#10;        }&#10;&#10;        // Check cache first&#10;        TextureProvider cachedProvider = cache.get(path);&#10;        if (cachedProvider != null) {&#10;            Texture texture = cachedProvider.getTexture(path, width, height, entry, light);&#10;            if (texture != null) {&#10;                return texture;&#10;            } else {&#10;                // Cached provider no longer has this texture, remove from cache&#10;                cache.remove(path);&#10;            }&#10;        }&#10;&#10;        // Search through providers&#10;        for (TextureProvider provider : providers) {&#10;            Texture texture = provider.getTexture(path, width, height, entry, light);&#10;            if (texture != null) {&#10;                // Cache this provider for future lookups&#10;                cache.put(path, provider);&#10;                return texture;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Clears the texture cache.&#10;     * This forces the registry to re-search providers on the next lookup.&#10;     */&#10;    public void clearCache() {&#10;        cache.clear();&#10;    }&#10;&#10;    /**&#10;     * Gets the number of registered providers.&#10;     *&#10;     * @return the number of providers&#10;     */&#10;    public int getProviderCount() {&#10;        return providers.size();&#10;    }&#10;&#10;    /**&#10;     * Gets all registered providers.&#10;     *&#10;     * @return a copy of the provider list&#10;     */&#10;    public List&lt;TextureProvider&gt; getProviders() {&#10;        return new ArrayList&lt;&gt;(providers);&#10;    }&#10;&#10;    /**&#10;     * Checks if a texture is available from any provider.&#10;     * This method uses a simplified check and does not cache the result.&#10;     *&#10;     * @param path the texture path to check&#10;     * @return true if the texture is available&#10;     */&#10;    public boolean hasTexture(String path) {&#10;        if (path == null) {&#10;            return false;&#10;        }&#10;&#10;        // Check cache first&#10;        if (cache.containsKey(path)) {&#10;            return true;&#10;        }&#10;&#10;        // Check providers (simplified check)&#10;        for (TextureProvider provider : providers) {&#10;            if (provider instanceof PictureTextureProvider pictureProvider) {&#10;                if (pictureProvider.hasTexture(path)) {&#10;                    return true;&#10;                }&#10;            }&#10;            // For other provider types, we would need to try getTexture with dummy parameters&#10;            // This is a limitation of the new interface design&#10;        }&#10;&#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/Texture.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/Texture.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.StyledChar;&#10;&#10;/**&#10; * Interface for texture rendering in raycasting.&#10; * Textures provide visual representation for map entries and can be scaled to any size.&#10; */&#10;public interface Texture {&#10;&#10;    /**&#10;     * Generates a picture representation of this texture scaled to the specified dimensions.&#10;     *&#10;     * @param width the desired width of the texture&#10;     * @param height the desired height of the texture&#10;     * @param entry the entry info for color and lighting information&#10;     * @param light true for light rendering (vertical walls), false for dark (horizontal walls)&#10;     * @return a 2D array of styled characters representing the texture&#10;     */&#10;    StyledChar[][] picture(int width, int height, EntryInfo entry, boolean light);&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.StyledChar;&#10;&#10;/**&#10; * Interface for texture rendering with coordinate-based access.&#10; * Textures provide direct access to styled characters at specific coordinates.&#10; */&#10;public interface Texture {&#10;&#10;    /**&#10;     * Gets the styled character at the specified coordinates.&#10;     * This method allows direct coordinate-based access to the texture data.&#10;     * &#10;     * @param x the x coordinate (0-based)&#10;     * @param y the y coordinate (0-based)&#10;     * @return the styled character at the given position, or null if coordinates are out of bounds&#10;     */&#10;    StyledChar getCharAt(int x, int y);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/TextureProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/TextureProvider.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;/**&#10; * Interface for providing textures by path.&#10; * TextureProviders can load and manage texture resources.&#10; */&#10;public interface TextureProvider {&#10;&#10;    /**&#10;     * Gets a texture by its path.&#10;     *&#10;     * @param path the path to the texture&#10;     * @return the texture if found, null otherwise&#10;     */&#10;    Texture getTexture(String path);&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;/**&#10; * Interface for providing textures by transforming coordinates directly to texture data.&#10; * TextureProviders act as pure transformators that map incoming coordinates to the original image.&#10; */&#10;public interface TextureProvider {&#10;&#10;    /**&#10;     * Gets a texture by its path with specified dimensions and rendering parameters.&#10;     * The texture is configured for the given dimensions and EntryInfo properties.&#10;     * &#10;     * @param path the path to the texture&#10;     * @param width the desired width of the texture&#10;     * @param height the desired height of the texture&#10;     * @param entry the entry info for color and lighting information&#10;     * @param light true for light rendering (vertical walls), false for dark (horizontal walls)&#10;     * @return the texture if found, null otherwise&#10;     */&#10;    Texture getTexture(String path, int width, int height, EntryInfo entry, boolean light);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/test/java/com/consolemaster/raycasting/RaycastingCanvasTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/test/java/com/consolemaster/raycasting/RaycastingCanvasTest.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Tests for RaycastingCanvas with EntryInfo system.&#10; */&#10;class RaycastingCanvasTest {&#10;&#10;    private RaycastingCanvas canvas;&#10;    private MapProvider testMapProvider;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Create a simple test map&#10;        String[] testMap = {&#10;            &quot;####&quot;,&#10;            &quot;#  #&quot;,&#10;            &quot;#  #&quot;,&#10;            &quot;####&quot;&#10;        };&#10;        testMapProvider = new DefaultMapProvider(&quot;Test Map&quot;, testMap);&#10;        canvas = new RaycastingCanvas(&quot;test&quot;, 80, 25, testMapProvider);&#10;    }&#10;&#10;    @Test&#10;    void testMapProviderIntegration() {&#10;        assertNotNull(canvas.getMapProvider());&#10;        assertEquals(&quot;Test Map&quot;, canvas.getMapProvider().getName());&#10;        assertEquals(4, canvas.getMapProvider().getWidth());&#10;        assertEquals(4, canvas.getMapProvider().getHeight());&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoWallDetection() {&#10;        // Test wall detection using EntryInfo&#10;        EntryInfo wallEntry = canvas.getMapProvider().getEntry(0, 0);&#10;        assertTrue(wallEntry.isWall());&#10;        assertFalse(wallEntry.isFallthrough());&#10;&#10;        EntryInfo floorEntry = canvas.getMapProvider().getEntry(1, 1);&#10;        assertFalse(floorEntry.isWall());&#10;        assertTrue(floorEntry.isFallthrough());&#10;    }&#10;&#10;    @Test&#10;    void testPlayerMovementWithEntryInfo() {&#10;        // Set player in valid position&#10;        canvas.setPlayerPosition(1.5, 1.5);&#10;        assertEquals(1.5, canvas.getPlayerX(), 0.01);&#10;        assertEquals(1.5, canvas.getPlayerY(), 0.01);&#10;&#10;        // Test valid position check using EntryInfo.isFallthrough()&#10;        assertTrue(canvas.isValidPosition(1.5, 1.5)); // Floor&#10;        assertFalse(canvas.isValidPosition(0.5, 0.5)); // Wall&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoFromCharacterConversion() {&#10;        // Test conversion from legacy characters to EntryInfo&#10;        EntryInfo wallInfo = EntryInfo.fromCharacter('#');&#10;        assertTrue(wallInfo.isWall());&#10;        assertFalse(wallInfo.isFallthrough());&#10;        assertEquals(&quot;Wall&quot;, wallInfo.getName());&#10;&#10;        EntryInfo floorInfo = EntryInfo.fromCharacter(' ');&#10;        assertFalse(floorInfo.isWall());&#10;        assertTrue(floorInfo.isFallthrough());&#10;        assertEquals(&quot;Empty&quot;, floorInfo.getName());&#10;    }&#10;&#10;    @Test&#10;    void testAdvancedMapProviderWithCustomEntries() {&#10;        // Create map with custom EntryInfo objects&#10;        EntryInfo[][] customMap = new EntryInfo[3][3];&#10;&#10;        // Fill with walls&#10;        for (int y = 0; y &lt; 3; y++) {&#10;            for (int x = 0; x &lt; 3; x++) {&#10;                customMap[y][x] = EntryInfo.createWall();&#10;            }&#10;        }&#10;&#10;        // Add glass wall in center&#10;        customMap[1][1] = EntryInfo.createGlass();&#10;&#10;        MapProvider customProvider = new DefaultMapProvider(&quot;Custom&quot;, customMap);&#10;        canvas.setMapProvider(customProvider);&#10;&#10;        // Test glass properties&#10;        EntryInfo glassEntry = canvas.getMapProvider().getEntry(1, 1);&#10;        assertTrue(glassEntry.isWall()); // Blocks movement&#10;        assertFalse(glassEntry.isFallthrough()); // Can't walk through&#10;        assertTrue(glassEntry.isTransparent()); // But is transparent&#10;        assertEquals(&quot;Glass&quot;, glassEntry.getName());&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoColors() {&#10;        // Test single color (backward compatibility)&#10;        EntryInfo redWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .colorLight(AnsiColor.RED)&#10;                .character('█')&#10;                .name(&quot;Red Wall&quot;)&#10;                .build();&#10;&#10;        assertEquals(AnsiColor.RED, redWall.getColorLight());&#10;        assertEquals(AnsiColor.RED, redWall.getColor(false)); // Light color&#10;        assertEquals(AnsiColor.RED, redWall.getColor(true)); // Falls back to light color when dark is not set&#10;        assertNull(redWall.getColorDark()); // Dark color not explicitly set&#10;        assertEquals('█', redWall.getCharacter());&#10;        assertTrue(redWall.isWall());&#10;&#10;        // Test light and dark colors&#10;        EntryInfo dualColorWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .character('█')&#10;                .name(&quot;Dual Color Wall&quot;)&#10;                .build();&#10;&#10;        assertEquals(AnsiColor.BRIGHT_GREEN, dualColorWall.getColor(false)); // Light&#10;        assertEquals(AnsiColor.GREEN, dualColorWall.getColor(true)); // Dark&#10;        assertEquals(AnsiColor.BRIGHT_GREEN, dualColorWall.getColor()); // Default to light&#10;&#10;        // Test backward compatibility setter&#10;        EntryInfo compatWall = EntryInfo.builder().build();&#10;        compatWall.setColor(AnsiColor.BLUE);&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColorLight());&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColorDark());&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColor(false));&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColor(true));&#10;&#10;        // Test only dark color set (edge case)&#10;        EntryInfo darkOnlyWall = EntryInfo.builder()&#10;                .colorDark(AnsiColor.BLACK)&#10;                .build();&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColor(true)); // Dark color&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColor(false)); // Falls back to dark when light not set&#10;        assertNull(darkOnlyWall.getColorLight());&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColorDark());&#10;    }&#10;&#10;    @Test&#10;    void testPredefinedWallTypes() {&#10;        // Test stone wall&#10;        EntryInfo stoneWall = EntryInfo.createStoneWall();&#10;        assertTrue(stoneWall.isWall());&#10;        assertFalse(stoneWall.isFallthrough());&#10;        assertEquals(&quot;Stone Wall&quot;, stoneWall.getName());&#10;        assertEquals(AnsiColor.WHITE, stoneWall.getColorLight());&#10;        assertEquals(AnsiColor.BRIGHT_BLACK, stoneWall.getColorDark());&#10;&#10;        // Test brick wall&#10;        EntryInfo brickWall = EntryInfo.createBrickWall();&#10;        assertTrue(brickWall.isWall());&#10;        assertEquals(&quot;Brick Wall&quot;, brickWall.getName());&#10;        assertEquals(AnsiColor.RED, brickWall.getColorLight());&#10;&#10;        // Test metal wall&#10;        EntryInfo metalWall = EntryInfo.createMetalWall();&#10;        assertTrue(metalWall.isWall());&#10;        assertEquals(&quot;Metal Wall&quot;, metalWall.getName());&#10;        assertEquals(AnsiColor.BRIGHT_WHITE, metalWall.getColorLight());&#10;&#10;        // Test tree&#10;        EntryInfo tree = EntryInfo.createTree();&#10;        assertTrue(tree.isWall());&#10;        assertEquals(&quot;Tree&quot;, tree.getName());&#10;        assertEquals('♠', tree.getCharacter());&#10;        assertEquals(1.3, tree.getHeight(), 0.01);&#10;&#10;        // Test wooden wall (with texture reference)&#10;        EntryInfo woodenWall = EntryInfo.createWoodenWall();&#10;        assertTrue(woodenWall.isWall());&#10;        assertEquals(&quot;Wooden Wall&quot;, woodenWall.getName());&#10;        assertEquals(&quot;wood&quot;, woodenWall.getTexture());&#10;        assertEquals(AnsiColor.YELLOW, woodenWall.getColorLight());&#10;    }&#10;&#10;    @Test&#10;    void testTextureProvider() {&#10;        // Test setting texture provider&#10;        PictureTextureProvider textureProvider = new PictureTextureProvider();&#10;&#10;        // Add a test texture&#10;        String[] testTexture = {&#10;            &quot;###&quot;,&#10;            &quot;   &quot;,&#10;            &quot;###&quot;&#10;        };&#10;        textureProvider.addTexture(&quot;test&quot;, testTexture);&#10;&#10;        canvas.setTextureProvider(textureProvider);&#10;        assertNotNull(canvas.getTextureProvider());&#10;&#10;        // Test texture retrieval&#10;        Texture retrievedTexture = canvas.getTextureProvider().getTexture(&quot;test&quot;);&#10;        assertNotNull(retrievedTexture);&#10;&#10;        // Test texture rendering&#10;        EntryInfo testEntry = EntryInfo.builder()&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .character('█')&#10;                .build();&#10;&#10;        var textureData = retrievedTexture.picture(3, 3, testEntry, true);&#10;        assertNotNull(textureData);&#10;        assertEquals(3, textureData.length);&#10;        assertEquals(3, textureData[0].length);&#10;    }&#10;&#10;    @Test&#10;    void testRegistryTextureProvider() {&#10;        // Create multiple texture providers&#10;        PictureTextureProvider provider1 = new PictureTextureProvider();&#10;        PictureTextureProvider provider2 = new PictureTextureProvider();&#10;&#10;        // Add textures to different providers&#10;        String[] texture1 = {&quot;###&quot;, &quot;   &quot;, &quot;###&quot;};&#10;        String[] texture2 = {&quot;***&quot;, &quot;   &quot;, &quot;***&quot;};&#10;&#10;        provider1.addTexture(&quot;wood&quot;, texture1);&#10;        provider2.addTexture(&quot;metal&quot;, texture2);&#10;&#10;        // Create registry and add providers&#10;        RegistryTextureProvider registry = new RegistryTextureProvider();&#10;        registry.addProvider(provider1);&#10;        registry.addProvider(provider2);&#10;&#10;        canvas.setTextureProvider(registry);&#10;&#10;        // Test texture retrieval from different providers&#10;        assertNotNull(canvas.getTextureProvider().getTexture(&quot;wood&quot;));&#10;        assertNotNull(canvas.getTextureProvider().getTexture(&quot;metal&quot;));&#10;        assertNull(canvas.getTextureProvider().getTexture(&quot;nonexistent&quot;));&#10;&#10;        // Test caching&#10;        assertTrue(registry.hasTexture(&quot;wood&quot;));&#10;        assertTrue(registry.hasTexture(&quot;metal&quot;));&#10;        assertFalse(registry.hasTexture(&quot;nonexistent&quot;));&#10;    }&#10;&#10;    @Test&#10;    void testPictureTexture() {&#10;        String[] textureData = {&#10;            &quot;ABC&quot;,&#10;            &quot;DEF&quot;,&#10;            &quot;GHI&quot;&#10;        };&#10;&#10;        PictureTexture texture = new PictureTexture(&quot;TestTexture&quot;, textureData);&#10;        assertEquals(&quot;TestTexture&quot;, texture.getName());&#10;        assertArrayEquals(textureData, texture.getTextureData());&#10;&#10;        // Test texture scaling&#10;        EntryInfo entry = EntryInfo.builder()&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .character('█')&#10;                .build();&#10;&#10;        // Test 1x1 scaling&#10;        var result1x1 = texture.picture(1, 1, entry, true);&#10;        assertEquals(1, result1x1.length);&#10;        assertEquals(1, result1x1[0].length);&#10;        assertEquals('A', result1x1[0][0].getCharacter());&#10;&#10;        // Test 6x6 scaling (2x upscale)&#10;        var result6x6 = texture.picture(6, 6, entry, true);&#10;        assertEquals(6, result6x6.length);&#10;        assertEquals(6, result6x6[0].length);&#10;&#10;        // Test edge cases&#10;        var resultEmpty = texture.picture(0, 0, entry, true);&#10;        assertEquals(0, resultEmpty.length);&#10;&#10;        // Test with null texture data&#10;        PictureTexture nullTexture = new PictureTexture(&quot;Null&quot;, null);&#10;        var resultNull = nullTexture.picture(3, 3, entry, true);&#10;        assertEquals(3, resultNull.length);&#10;        assertEquals(3, resultNull[0].length);&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoWithTexture() {&#10;        // Test EntryInfo with texture reference&#10;        EntryInfo texturedWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Textured Wall&quot;)&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .texture(&quot;stone&quot;)&#10;                .textureInstructions(&quot;scale=2&quot;)&#10;                .build();&#10;&#10;        assertEquals(&quot;stone&quot;, texturedWall.getTexture());&#10;        assertEquals(&quot;scale=2&quot;, texturedWall.getTextureInstructions());&#10;        assertTrue(texturedWall.isWall());&#10;        assertEquals(&quot;Textured Wall&quot;, texturedWall.getName());&#10;    }&#10;&#10;    @Test&#10;    void testMapProviderToStringArray() {&#10;        // Test conversion back to string array&#10;        String[] originalMap = canvas.getMap();&#10;        assertNotNull(originalMap);&#10;        assertEquals(4, originalMap.length);&#10;        assertEquals(&quot;####&quot;, originalMap[0]);&#10;        assertEquals(&quot;#  #&quot;, originalMap[1]);&#10;        assertEquals(&quot;#  #&quot;, originalMap[2]);&#10;        assertEquals(&quot;####&quot;, originalMap[3]);&#10;    }&#10;&#10;    @Test&#10;    void testWallEdgeDetection() {&#10;        // Test wall edge functionality&#10;        assertTrue(canvas.isDrawWallEdges());&#10;&#10;        canvas.setDrawWallEdges(false);&#10;        assertFalse(canvas.isDrawWallEdges());&#10;&#10;        canvas.setWallEdgeThreshold(0.5);&#10;        assertEquals(0.5, canvas.getWallEdgeThreshold(), 0.01);&#10;&#10;        canvas.setWallEdgeChar('|');&#10;        assertEquals('|', canvas.getWallEdgeChar());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.AnsiColor;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Tests for RaycastingCanvas with EntryInfo system.&#10; */&#10;class RaycastingCanvasTest {&#10;&#10;    private RaycastingCanvas canvas;&#10;    private MapProvider testMapProvider;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Create a simple test map&#10;        String[] testMap = {&#10;            &quot;####&quot;,&#10;            &quot;#  #&quot;,&#10;            &quot;#  #&quot;,&#10;            &quot;####&quot;&#10;        };&#10;        testMapProvider = new DefaultMapProvider(&quot;Test Map&quot;, testMap);&#10;        canvas = new RaycastingCanvas(&quot;test&quot;, 80, 25, testMapProvider);&#10;    }&#10;&#10;    @Test&#10;    void testMapProviderIntegration() {&#10;        assertNotNull(canvas.getMapProvider());&#10;        assertEquals(&quot;Test Map&quot;, canvas.getMapProvider().getName());&#10;        assertEquals(4, canvas.getMapProvider().getWidth());&#10;        assertEquals(4, canvas.getMapProvider().getHeight());&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoWallDetection() {&#10;        // Test wall detection using EntryInfo&#10;        EntryInfo wallEntry = canvas.getMapProvider().getEntry(0, 0);&#10;        assertTrue(wallEntry.isWall());&#10;        assertFalse(wallEntry.isFallthrough());&#10;&#10;        EntryInfo floorEntry = canvas.getMapProvider().getEntry(1, 1);&#10;        assertFalse(floorEntry.isWall());&#10;        assertTrue(floorEntry.isFallthrough());&#10;    }&#10;&#10;    @Test&#10;    void testPlayerMovementWithEntryInfo() {&#10;        // Set player in valid position&#10;        canvas.setPlayerPosition(1.5, 1.5);&#10;        assertEquals(1.5, canvas.getPlayerX(), 0.01);&#10;        assertEquals(1.5, canvas.getPlayerY(), 0.01);&#10;&#10;        // Test valid position check using EntryInfo.isFallthrough()&#10;        assertTrue(canvas.isValidPosition(1.5, 1.5)); // Floor&#10;        assertFalse(canvas.isValidPosition(0.5, 0.5)); // Wall&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoFromCharacterConversion() {&#10;        // Test conversion from legacy characters to EntryInfo&#10;        EntryInfo wallInfo = EntryInfo.fromCharacter('#');&#10;        assertTrue(wallInfo.isWall());&#10;        assertFalse(wallInfo.isFallthrough());&#10;        assertEquals(&quot;Wall&quot;, wallInfo.getName());&#10;&#10;        EntryInfo floorInfo = EntryInfo.fromCharacter(' ');&#10;        assertFalse(floorInfo.isWall());&#10;        assertTrue(floorInfo.isFallthrough());&#10;        assertEquals(&quot;Empty&quot;, floorInfo.getName());&#10;    }&#10;&#10;    @Test&#10;    void testAdvancedMapProviderWithCustomEntries() {&#10;        // Create map with custom EntryInfo objects&#10;        EntryInfo[][] customMap = new EntryInfo[3][3];&#10;&#10;        // Fill with walls&#10;        for (int y = 0; y &lt; 3; y++) {&#10;            for (int x = 0; x &lt; 3; x++) {&#10;                customMap[y][x] = EntryInfo.createWall();&#10;            }&#10;        }&#10;&#10;        // Add glass wall in center&#10;        customMap[1][1] = EntryInfo.createGlass();&#10;&#10;        MapProvider customProvider = new DefaultMapProvider(&quot;Custom&quot;, customMap);&#10;        canvas.setMapProvider(customProvider);&#10;&#10;        // Test glass properties&#10;        EntryInfo glassEntry = canvas.getMapProvider().getEntry(1, 1);&#10;        assertTrue(glassEntry.isWall()); // Blocks movement&#10;        assertFalse(glassEntry.isFallthrough()); // Can't walk through&#10;        assertTrue(glassEntry.isTransparent()); // But is transparent&#10;        assertEquals(&quot;Glass&quot;, glassEntry.getName());&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoColors() {&#10;        // Test single color (backward compatibility)&#10;        EntryInfo redWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .colorLight(AnsiColor.RED)&#10;                .character('█')&#10;                .name(&quot;Red Wall&quot;)&#10;                .build();&#10;&#10;        assertEquals(AnsiColor.RED, redWall.getColorLight());&#10;        assertEquals(AnsiColor.RED, redWall.getColor(false)); // Light color&#10;        assertEquals(AnsiColor.RED, redWall.getColor(true)); // Falls back to light color when dark is not set&#10;        assertNull(redWall.getColorDark()); // Dark color not explicitly set&#10;        assertEquals('█', redWall.getCharacter());&#10;        assertTrue(redWall.isWall());&#10;&#10;        // Test light and dark colors&#10;        EntryInfo dualColorWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .colorLight(AnsiColor.BRIGHT_GREEN)&#10;                .colorDark(AnsiColor.GREEN)&#10;                .character('█')&#10;                .name(&quot;Dual Color Wall&quot;)&#10;                .build();&#10;&#10;        assertEquals(AnsiColor.BRIGHT_GREEN, dualColorWall.getColor(false)); // Light&#10;        assertEquals(AnsiColor.GREEN, dualColorWall.getColor(true)); // Dark&#10;        assertEquals(AnsiColor.BRIGHT_GREEN, dualColorWall.getColor()); // Default to light&#10;&#10;        // Test backward compatibility setter&#10;        EntryInfo compatWall = EntryInfo.builder().build();&#10;        compatWall.setColor(AnsiColor.BLUE);&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColorLight());&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColorDark());&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColor(false));&#10;        assertEquals(AnsiColor.BLUE, compatWall.getColor(true));&#10;&#10;        // Test only dark color set (edge case)&#10;        EntryInfo darkOnlyWall = EntryInfo.builder()&#10;                .colorDark(AnsiColor.BLACK)&#10;                .build();&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColor(true)); // Dark color&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColor(false)); // Falls back to dark when light not set&#10;        assertNull(darkOnlyWall.getColorLight());&#10;        assertEquals(AnsiColor.BLACK, darkOnlyWall.getColorDark());&#10;    }&#10;&#10;    @Test&#10;    void testPredefinedWallTypes() {&#10;        // Test stone wall&#10;        EntryInfo stoneWall = EntryInfo.createStoneWall();&#10;        assertTrue(stoneWall.isWall());&#10;        assertFalse(stoneWall.isFallthrough());&#10;        assertEquals(&quot;Stone Wall&quot;, stoneWall.getName());&#10;        assertEquals(AnsiColor.WHITE, stoneWall.getColorLight());&#10;        assertEquals(AnsiColor.BRIGHT_BLACK, stoneWall.getColorDark());&#10;&#10;        // Test brick wall&#10;        EntryInfo brickWall = EntryInfo.createBrickWall();&#10;        assertTrue(brickWall.isWall());&#10;        assertEquals(&quot;Brick Wall&quot;, brickWall.getName());&#10;        assertEquals(AnsiColor.RED, brickWall.getColorLight());&#10;&#10;        // Test metal wall&#10;        EntryInfo metalWall = EntryInfo.createMetalWall();&#10;        assertTrue(metalWall.isWall());&#10;        assertEquals(&quot;Metal Wall&quot;, metalWall.getName());&#10;        assertEquals(AnsiColor.BRIGHT_WHITE, metalWall.getColorLight());&#10;&#10;        // Test tree&#10;        EntryInfo tree = EntryInfo.createTree();&#10;        assertTrue(tree.isWall());&#10;        assertEquals(&quot;Tree&quot;, tree.getName());&#10;        assertEquals('♠', tree.getCharacter());&#10;        assertEquals(1.3, tree.getHeight(), 0.01);&#10;&#10;        // Test wooden wall (with texture reference)&#10;        EntryInfo woodenWall = EntryInfo.createWoodenWall();&#10;        assertTrue(woodenWall.isWall());&#10;        assertEquals(&quot;Wooden Wall&quot;, woodenWall.getName());&#10;        assertEquals(&quot;wood&quot;, woodenWall.getTexture());&#10;        assertEquals(AnsiColor.YELLOW, woodenWall.getColorLight());&#10;    }&#10;&#10;    @Test&#10;    void testTextureProvider() {&#10;        // Test setting texture provider&#10;        PictureTextureProvider textureProvider = new PictureTextureProvider();&#10;        &#10;        // Add a test texture&#10;        String[] testTexture = {&#10;            &quot;###&quot;,&#10;            &quot;   &quot;,&#10;            &quot;###&quot;&#10;        };&#10;        textureProvider.addTexture(&quot;test&quot;, testTexture);&#10;        &#10;        canvas.setTextureProvider(textureProvider);&#10;        assertNotNull(canvas.getTextureProvider());&#10;        &#10;        // Test texture retrieval with new transformator-based interface&#10;        EntryInfo testEntry = EntryInfo.builder()&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .character('█')&#10;                .build();&#10;        &#10;        Texture retrievedTexture = canvas.getTextureProvider().getTexture(&quot;test&quot;, 3, 3, testEntry, true);&#10;        assertNotNull(retrievedTexture);&#10;        &#10;        // Test coordinate-based access&#10;        StyledChar charAtOrigin = retrievedTexture.getCharAt(0, 0);&#10;        assertNotNull(charAtOrigin);&#10;        assertEquals('#', charAtOrigin.getCharacter());&#10;        &#10;        StyledChar charAtMiddle = retrievedTexture.getCharAt(1, 1);&#10;        assertNotNull(charAtMiddle);&#10;        assertEquals(' ', charAtMiddle.getCharacter());&#10;        &#10;        // Test bounds checking&#10;        StyledChar charOutOfBounds = retrievedTexture.getCharAt(10, 10);&#10;        assertNull(charOutOfBounds);&#10;    }&#10;&#10;    @Test&#10;    void testRegistryTextureProvider() {&#10;        // Create multiple texture providers&#10;        PictureTextureProvider provider1 = new PictureTextureProvider();&#10;        PictureTextureProvider provider2 = new PictureTextureProvider();&#10;&#10;        // Add textures to different providers&#10;        String[] texture1 = {&quot;###&quot;, &quot;   &quot;, &quot;###&quot;};&#10;        String[] texture2 = {&quot;***&quot;, &quot;   &quot;, &quot;***&quot;};&#10;&#10;        provider1.addTexture(&quot;wood&quot;, texture1);&#10;        provider2.addTexture(&quot;metal&quot;, texture2);&#10;&#10;        // Create registry and add providers&#10;        RegistryTextureProvider registry = new RegistryTextureProvider();&#10;        registry.addProvider(provider1);&#10;        registry.addProvider(provider2);&#10;&#10;        canvas.setTextureProvider(registry);&#10;&#10;        // Test texture retrieval from different providers&#10;        assertNotNull(canvas.getTextureProvider().getTexture(&quot;wood&quot;));&#10;        assertNotNull(canvas.getTextureProvider().getTexture(&quot;metal&quot;));&#10;        assertNull(canvas.getTextureProvider().getTexture(&quot;nonexistent&quot;));&#10;&#10;        // Test caching&#10;        assertTrue(registry.hasTexture(&quot;wood&quot;));&#10;        assertTrue(registry.hasTexture(&quot;metal&quot;));&#10;        assertFalse(registry.hasTexture(&quot;nonexistent&quot;));&#10;    }&#10;&#10;    @Test&#10;    void testPictureTexture() {&#10;        String[] textureData = {&#10;            &quot;ABC&quot;,&#10;            &quot;DEF&quot;,&#10;            &quot;GHI&quot;&#10;        };&#10;&#10;        PictureTexture texture = new PictureTexture(&quot;TestTexture&quot;, textureData);&#10;        assertEquals(&quot;TestTexture&quot;, texture.getName());&#10;        assertArrayEquals(textureData, texture.getTextureData());&#10;&#10;        // Test texture scaling&#10;        EntryInfo entry = EntryInfo.builder()&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .character('█')&#10;                .build();&#10;&#10;        // Test 1x1 scaling&#10;        var result1x1 = texture.picture(1, 1, entry, true);&#10;        assertEquals(1, result1x1.length);&#10;        assertEquals(1, result1x1[0].length);&#10;        assertEquals('A', result1x1[0][0].getCharacter());&#10;&#10;        // Test 6x6 scaling (2x upscale)&#10;        var result6x6 = texture.picture(6, 6, entry, true);&#10;        assertEquals(6, result6x6.length);&#10;        assertEquals(6, result6x6[0].length);&#10;&#10;        // Test edge cases&#10;        var resultEmpty = texture.picture(0, 0, entry, true);&#10;        assertEquals(0, resultEmpty.length);&#10;&#10;        // Test with null texture data&#10;        PictureTexture nullTexture = new PictureTexture(&quot;Null&quot;, null);&#10;        var resultNull = nullTexture.picture(3, 3, entry, true);&#10;        assertEquals(3, resultNull.length);&#10;        assertEquals(3, resultNull[0].length);&#10;    }&#10;&#10;    @Test&#10;    void testEntryInfoWithTexture() {&#10;        // Test EntryInfo with texture reference&#10;        EntryInfo texturedWall = EntryInfo.builder()&#10;                .isWall(true)&#10;                .isFallthrough(false)&#10;                .isTransparent(false)&#10;                .character('█')&#10;                .name(&quot;Textured Wall&quot;)&#10;                .colorLight(AnsiColor.WHITE)&#10;                .colorDark(AnsiColor.BRIGHT_BLACK)&#10;                .texture(&quot;stone&quot;)&#10;                .textureInstructions(&quot;scale=2&quot;)&#10;                .build();&#10;&#10;        assertEquals(&quot;stone&quot;, texturedWall.getTexture());&#10;        assertEquals(&quot;scale=2&quot;, texturedWall.getTextureInstructions());&#10;        assertTrue(texturedWall.isWall());&#10;        assertEquals(&quot;Textured Wall&quot;, texturedWall.getName());&#10;    }&#10;&#10;    @Test&#10;    void testMapProviderToStringArray() {&#10;        // Test conversion back to string array&#10;        String[] originalMap = canvas.getMap();&#10;        assertNotNull(originalMap);&#10;        assertEquals(4, originalMap.length);&#10;        assertEquals(&quot;####&quot;, originalMap[0]);&#10;        assertEquals(&quot;#  #&quot;, originalMap[1]);&#10;        assertEquals(&quot;#  #&quot;, originalMap[2]);&#10;        assertEquals(&quot;####&quot;, originalMap[3]);&#10;    }&#10;&#10;    @Test&#10;    void testWallEdgeDetection() {&#10;        // Test wall edge functionality&#10;        assertTrue(canvas.isDrawWallEdges());&#10;&#10;        canvas.setDrawWallEdges(false);&#10;        assertFalse(canvas.isDrawWallEdges());&#10;&#10;        canvas.setWallEdgeThreshold(0.5);&#10;        assertEquals(0.5, canvas.getWallEdgeThreshold(), 0.01);&#10;&#10;        canvas.setWallEdgeChar('|');&#10;        assertEquals('|', canvas.getWallEdgeChar());&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>