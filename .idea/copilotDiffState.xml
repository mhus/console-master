<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/BackgroundDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/demo/BackgroundDemo.java" />
              <option name="originalContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnimationThrottle;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationManager;&#10;import com.consolemaster.EventHandler;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.BackgroundProvider;&#10;import com.consolemaster.raycasting.SolidColorBackgroundProvider;&#10;import com.consolemaster.raycasting.CloudsBackgroundProvider;&#10;import com.consolemaster.raycasting.StarfieldBackgroundProvider;&#10;import com.consolemaster.raycasting.ConstellationBackgroundProvider;&#10;import com.consolemaster.raycasting.DayNightCycleBackgroundProvider;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application showcasing the different BackgroundProvider implementations&#10; * for RaycastingCanvas. Users can switch between solid color, clouds, and starfield&#10; * backgrounds using keyboard shortcuts.&#10; */&#10;public class BackgroundDemo {&#10;&#10;    private ScreenCanvas screen;&#10;    private RaycastingCanvas raycastingCanvas;&#10;    private ProcessLoop processLoop;&#10;&#10;    // Background providers&#10;    private SolidColorBackgroundProvider solidBackground;&#10;    private CloudsBackgroundProvider cloudsBackground;&#10;    private StarfieldBackgroundProvider starfieldBackground;&#10;    private ConstellationBackgroundProvider constellationBackground;&#10;    private DayNightCycleBackgroundProvider dayNightBackground;&#10;    private AnimationThrottle startfieldThrottle;&#10;&#10;    // Current background type&#10;    private BackgroundType currentBackground = BackgroundType.SOLID;&#10;&#10;    private enum BackgroundType {&#10;        SOLID(&quot;Solid Color Background&quot;),&#10;        CLOUDS(&quot;Animated Clouds Background&quot;),&#10;        STARFIELD(&quot;Animated Starfield Background&quot;),&#10;        CONSTELLATION(&quot;Constellation Background&quot;),&#10;        DAY_NIGHT_CYCLE(&quot;Day-Night Cycle with Weather&quot;);&#10;&#10;        private final String description;&#10;&#10;        BackgroundType(String description) {&#10;            this.description = description;&#10;        }&#10;&#10;        public String getDescription() {&#10;            return description;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws IOException {&#10;        new BackgroundDemo().run();&#10;    }&#10;&#10;    public void run() throws IOException {&#10;        setupComponents();&#10;        setupBackgrounds();&#10;        setupMap();&#10;        setupScreen();&#10;&#10;        // Start with solid background&#10;        setBackground(BackgroundType.SOLID);&#10;&#10;        // Start the process loop&#10;        processLoop = new ProcessLoop(screen);&#10;        processLoop.start();&#10;    }&#10;&#10;    private void setupComponents() throws IOException {&#10;        screen = new ScreenCanvas(80, 25);&#10;&#10;        // Create raycasting canvas&#10;        raycastingCanvas = new RaycastingCanvas(&quot;Background Demo&quot;, 80, 25);&#10;        raycastingCanvas.setPosition(0, 0);&#10;        raycastingCanvas.setVisible(true);&#10;&#10;        // Configure raycasting appearance&#10;        raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;        raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;        raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;        raycastingCanvas.setDrawWallEdges(true);&#10;        raycastingCanvas.setWallEdgeThreshold(0.3);&#10;        raycastingCanvas.setRenderCeilings(false); // Disable ceiling to show background better&#10;&#10;        // Set player position&#10;        raycastingCanvas.setPlayerPosition(4.5, 4.5);&#10;        raycastingCanvas.setPlayerAngle(0.0);&#10;    }&#10;&#10;    private void setupBackgrounds() {&#10;        // Create solid color background&#10;        solidBackground = new SolidColorBackgroundProvider(AnsiColor.BLUE);&#10;&#10;        // Create animated clouds background&#10;        cloudsBackground = new CloudsBackgroundProvider(0.03, 0.04, 0.4);&#10;        cloudsBackground.setSkyColor(AnsiColor.CYAN);&#10;        cloudsBackground.setCloudColorLight(AnsiColor.WHITE);&#10;        cloudsBackground.setCloudColorDark(AnsiColor.BRIGHT_BLACK);&#10;&#10;        // Create animated starfield background&#10;        starfieldBackground = new StarfieldBackgroundProvider(80, 25);&#10;        starfieldBackground.setRotationSpeed(0.3);&#10;        starfieldBackground.setNumStars(150);&#10;        starfieldBackground.setSkyColor(AnsiColor.BLACK);&#10;        startfieldThrottle = AnimationThrottle.withDelaySeconds(starfieldBackground, 1);&#10;&#10;        // Create animated constellation background&#10;        constellationBackground = new ConstellationBackgroundProvider(80, 25);&#10;        constellationBackground.setDriftSpeed(0.01);&#10;        constellationBackground.setTwinkleIntensity(0.3);&#10;        constellationBackground.setShowConstellationLines(true);&#10;        constellationBackground.setSkyColor(AnsiColor.BLACK);&#10;&#10;        // Create day-night cycle background&#10;        dayNightBackground = new DayNightCycleBackgroundProvider(80, 25);&#10;        dayNightBackground.setTimeSpeed(0.0001); // Slightly faster for demo&#10;        dayNightBackground.setAutomaticWeather(true);&#10;        dayNightBackground.setShowCelestialBodies(true);&#10;        dayNightBackground.setCurrentTime(0.5); // Start at noon&#10;    }&#10;&#10;    private void setupMap() {&#10;        // Create a simple map with open areas to show the background&#10;        String[] map = {&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ####    ##  #&quot;,&#10;            &quot;#    ##        #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#     ##       #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ##    ####  #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#      ##      #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        };&#10;        raycastingCanvas.setMap(map);&#10;    }&#10;&#10;    private void setupScreen() {&#10;        screen.setContent(raycastingCanvas);&#10;&#10;        // Register keyboard shortcuts&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESC.name(), () -&gt; {&#10;            try {&#10;                processLoop.stop();&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;&#10;        screen.registerShortcut(&quot;1&quot;, () -&gt; {&#10;            setBackground(BackgroundType.SOLID);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;2&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CLOUDS);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;3&quot;, () -&gt; {&#10;            setBackground(BackgroundType.STARFIELD);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;4&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CONSTELLATION);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;5&quot;, () -&gt; {&#10;            setBackground(BackgroundType.DAY_NIGHT_CYCLE);&#10;        });&#10;&#10;        // Day-Night cycle specific controls&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            toggleTimeSpeed();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            cycleWeather();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;N&quot;, () -&gt; {&#10;            setTimeToNight();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            setTimeToMidday();&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut( KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            toggleCeilings();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;H&quot;, () -&gt; {&#10;            showHelp();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;    }&#10;&#10;    private void setBackground(BackgroundType backgroundType) {&#10;        // Remove current background from animation manager&#10;        if (currentBackground == BackgroundType.CLOUDS) {&#10;            processLoop.removeAnimationTicker(cloudsBackground);&#10;        } else if (currentBackground == BackgroundType.STARFIELD) {&#10;            processLoop.removeAnimationTicker(startfieldThrottle);&#10;        } else if (currentBackground == BackgroundType.CONSTELLATION) {&#10;            processLoop.removeAnimationTicker(constellationBackground);&#10;        } else if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            processLoop.removeAnimationTicker(dayNightBackground);&#10;        }&#10;&#10;        // Set new background&#10;        currentBackground = backgroundType;&#10;        BackgroundProvider provider;&#10;&#10;        switch (backgroundType) {&#10;            case SOLID:&#10;                provider = solidBackground;&#10;                break;&#10;            case CLOUDS:&#10;                provider = cloudsBackground;&#10;                processLoop.addAnimationTicker(cloudsBackground);&#10;                break;&#10;            case STARFIELD:&#10;                provider = starfieldBackground;&#10;                processLoop.addAnimationTicker(startfieldThrottle);&#10;                break;&#10;            case CONSTELLATION:&#10;                provider = constellationBackground;&#10;                processLoop.addAnimationTicker(constellationBackground);&#10;                break;&#10;            case DAY_NIGHT_CYCLE:&#10;                provider = dayNightBackground;&#10;                processLoop.addAnimationTicker(dayNightBackground);&#10;                break;&#10;            default:&#10;                provider = solidBackground;&#10;        }&#10;&#10;        raycastingCanvas.setBackgroundProvider(provider);&#10;        System.out.println(&quot;Switched to: &quot; + backgroundType.getDescription());&#10;    }&#10;&#10;    private void toggleCeilings() {&#10;        boolean currentState = raycastingCanvas.isRenderCeilings();&#10;        raycastingCanvas.setRenderCeilings(!currentState);&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (currentState ? &quot;OFF&quot; : &quot;ON&quot;));&#10;    }&#10;&#10;    private void showHelp() {&#10;        System.out.println(&quot;\n=== Background Demo Controls ===&quot;);&#10;        System.out.println(&quot;Movement:&quot;);&#10;        System.out.println(&quot;  ↑/↓      - Move forward/backward&quot;);&#10;        System.out.println(&quot;  A/D      - Strafe left/right&quot;);&#10;        System.out.println(&quot;  ←/→      - Turn left/right&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Backgrounds:&quot;);&#10;        System.out.println(&quot;  1        - Solid color background&quot;);&#10;        System.out.println(&quot;  2        - Animated clouds background&quot;);&#10;        System.out.println(&quot;  3        - Animated starfield background&quot;);&#10;        System.out.println(&quot;  4        - Constellation background&quot;);&#10;        System.out.println(&quot;  5        - Day-Night cycle background&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Day-Night Cycle Controls (when active):&quot;);&#10;        System.out.println(&quot;  T        - Toggle time speed (slow/fast)&quot;);&#10;        System.out.println(&quot;  W        - Cycle weather (sunny→cloudy→rainy→stormy)&quot;);&#10;        System.out.println(&quot;  B        - Adjust sunny weather bias (low→med→high→very high)&quot;);&#10;        System.out.println(&quot;  N        - Set time to night (midnight)&quot;);&#10;        System.out.println(&quot;  M        - Set time to midday (noon)&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Options:&quot;);&#10;        System.out.println(&quot;  C        - Toggle ceiling rendering&quot;);&#10;        System.out.println(&quot;  H        - Show this help&quot;);&#10;        System.out.println(&quot;  ESC      - Exit demo&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Current background: &quot; + currentBackground.getDescription());&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (raycastingCanvas.isRenderCeilings() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;&#10;        // Show additional info for Day-Night cycle&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            System.out.println();&#10;            System.out.println(&quot;Day-Night Cycle Status:&quot;);&#10;            System.out.println(&quot;  Time: &quot; + dayNightBackground.getTimeString());&#10;            System.out.println(&quot;  Weather: &quot; + dayNightBackground.getCurrentWeatherString());&#10;            System.out.println(&quot;  Auto Weather: &quot; + (dayNightBackground.isAutomaticWeather() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;        }&#10;&#10;        System.out.println(&quot;===============================\n&quot;);&#10;    }&#10;&#10;    private void toggleTimeSpeed() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentSpeed = dayNightBackground.getTimeSpeed();&#10;            double newSpeed = currentSpeed &lt;= 0.0001 ? 0.001 : 0.0001; // Toggle between slow and fast&#10;            dayNightBackground.setTimeSpeed(newSpeed);&#10;            System.out.println(&quot;Time speed: &quot; + (newSpeed &gt; 0.0001 ? &quot;FAST&quot; : &quot;SLOW&quot;));&#10;        }&#10;    }&#10;&#10;    private void cycleWeather() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            DayNightCycleBackgroundProvider.WeatherType[] weathers =&#10;                DayNightCycleBackgroundProvider.WeatherType.values();&#10;            DayNightCycleBackgroundProvider.WeatherType current = dayNightBackground.getCurrentWeather();&#10;&#10;            // Find next weather type&#10;            int currentIndex = 0;&#10;            for (int i = 0; i &lt; weathers.length; i++) {&#10;                if (weathers[i] == current) {&#10;                    currentIndex = i;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            DayNightCycleBackgroundProvider.WeatherType nextWeather =&#10;                weathers[(currentIndex + 1) % weathers.length];&#10;            dayNightBackground.setWeather(nextWeather);&#10;            System.out.println(&quot;Weather: &quot; + nextWeather.getName());&#10;        }&#10;    }&#10;&#10;    private void setTimeToNight() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.0); // Midnight&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Night)&quot;);&#10;        }&#10;    }&#10;&#10;    private void setTimeToMidday() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.5); // Noon&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Midday)&quot;);&#10;        }&#10;    }&#10;&#10;    private void adjustSunnyBias() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentBias = dayNightBackground.getSunnyWeatherBias();&#10;            // Cycle through different bias levels: 0.3 -&gt; 0.5 -&gt; 0.7 -&gt; 0.9 -&gt; 0.3&#10;            double newBias;&#10;            if (currentBias &lt; 0.4) {&#10;                newBias = 0.5; // Low -&gt; Medium&#10;            } else if (currentBias &lt; 0.6) {&#10;                newBias = 0.7; // Medium -&gt; High&#10;            } else if (currentBias &lt; 0.8) {&#10;                newBias = 0.9; // High -&gt; Very High&#10;            } else {&#10;                newBias = 0.3; // Very High -&gt; Low&#10;            }&#10;&#10;            dayNightBackground.setSunnyWeatherBias(newBias);&#10;            String biasLevel = getBiasLevelName(newBias);&#10;            System.out.println(&quot;Sunny weather bias: &quot; + biasLevel + &quot; (&quot; + Math.round(newBias * 100) + &quot;%)&quot;);&#10;        }&#10;    }&#10;&#10;    private String getBiasLevelName(double bias) {&#10;        if (bias &lt; 0.4) return &quot;LOW&quot;;&#10;        if (bias &lt; 0.6) return &quot;MEDIUM&quot;;&#10;        if (bias &lt; 0.8) return &quot;HIGH&quot;;&#10;        return &quot;VERY HIGH&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.demo;&#10;&#10;import com.consolemaster.AnimationThrottle;&#10;import com.consolemaster.ScreenCanvas;&#10;import com.consolemaster.ProcessLoop;&#10;import com.consolemaster.KeyEvent;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationManager;&#10;import com.consolemaster.EventHandler;&#10;import com.consolemaster.raycasting.RaycastingCanvas;&#10;import com.consolemaster.raycasting.BackgroundProvider;&#10;import com.consolemaster.raycasting.SolidColorBackgroundProvider;&#10;import com.consolemaster.raycasting.CloudsBackgroundProvider;&#10;import com.consolemaster.raycasting.StarfieldBackgroundProvider;&#10;import com.consolemaster.raycasting.ConstellationBackgroundProvider;&#10;import com.consolemaster.raycasting.DayNightCycleBackgroundProvider;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application showcasing the different BackgroundProvider implementations&#10; * for RaycastingCanvas. Users can switch between solid color, clouds, and starfield&#10; * backgrounds using keyboard shortcuts.&#10; */&#10;public class BackgroundDemo {&#10;&#10;    private ScreenCanvas screen;&#10;    private RaycastingCanvas raycastingCanvas;&#10;    private ProcessLoop processLoop;&#10;&#10;    // Background providers&#10;    private SolidColorBackgroundProvider solidBackground;&#10;    private CloudsBackgroundProvider cloudsBackground;&#10;    private StarfieldBackgroundProvider starfieldBackground;&#10;    private ConstellationBackgroundProvider constellationBackground;&#10;    private DayNightCycleBackgroundProvider dayNightBackground;&#10;    private AnimationThrottle startfieldThrottle;&#10;&#10;    // Current background type&#10;    private BackgroundType currentBackground = BackgroundType.SOLID;&#10;&#10;    private enum BackgroundType {&#10;        SOLID(&quot;Solid Color Background&quot;),&#10;        CLOUDS(&quot;Animated Clouds Background&quot;),&#10;        STARFIELD(&quot;Animated Starfield Background&quot;),&#10;        CONSTELLATION(&quot;Constellation Background&quot;),&#10;        DAY_NIGHT_CYCLE(&quot;Day-Night Cycle with Weather&quot;);&#10;&#10;        private final String description;&#10;&#10;        BackgroundType(String description) {&#10;            this.description = description;&#10;        }&#10;&#10;        public String getDescription() {&#10;            return description;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws IOException {&#10;        new BackgroundDemo().run();&#10;    }&#10;&#10;    public void run() throws IOException {&#10;        setupComponents();&#10;        setupBackgrounds();&#10;        setupMap();&#10;        setupScreen();&#10;&#10;        // Start with solid background&#10;        setBackground(BackgroundType.SOLID);&#10;&#10;        // Start the process loop&#10;        processLoop = new ProcessLoop(screen);&#10;        processLoop.start();&#10;    }&#10;&#10;    private void setupComponents() throws IOException {&#10;        screen = new ScreenCanvas(80, 25);&#10;&#10;        // Create raycasting canvas&#10;        raycastingCanvas = new RaycastingCanvas(&quot;Background Demo&quot;, 80, 25);&#10;        raycastingCanvas.setPosition(0, 0);&#10;        raycastingCanvas.setVisible(true);&#10;&#10;        // Configure raycasting appearance&#10;        raycastingCanvas.setWallColor(AnsiColor.WHITE);&#10;        raycastingCanvas.setFloorColor(AnsiColor.YELLOW);&#10;        raycastingCanvas.setCeilingColor(AnsiColor.BLUE);&#10;        raycastingCanvas.setDrawWallEdges(true);&#10;        raycastingCanvas.setWallEdgeThreshold(0.3);&#10;        raycastingCanvas.setRenderCeilings(false); // Disable ceiling to show background better&#10;&#10;        // Set player position&#10;        raycastingCanvas.setPlayerPosition(4.5, 4.5);&#10;        raycastingCanvas.setPlayerAngle(0.0);&#10;    }&#10;&#10;    private void setupBackgrounds() {&#10;        // Create solid color background&#10;        solidBackground = new SolidColorBackgroundProvider(AnsiColor.BLUE);&#10;&#10;        // Create animated clouds background&#10;        cloudsBackground = new CloudsBackgroundProvider(0.03, 0.04, 0.4);&#10;        cloudsBackground.setSkyColor(AnsiColor.CYAN);&#10;        cloudsBackground.setCloudColorLight(AnsiColor.WHITE);&#10;        cloudsBackground.setCloudColorDark(AnsiColor.BRIGHT_BLACK);&#10;&#10;        // Create animated starfield background&#10;        starfieldBackground = new StarfieldBackgroundProvider(80, 25);&#10;        starfieldBackground.setRotationSpeed(0.3);&#10;        starfieldBackground.setNumStars(150);&#10;        starfieldBackground.setSkyColor(AnsiColor.BLACK);&#10;        startfieldThrottle = AnimationThrottle.withDelaySeconds(starfieldBackground, 1);&#10;&#10;        // Create animated constellation background&#10;        constellationBackground = new ConstellationBackgroundProvider(80, 25);&#10;        constellationBackground.setDriftSpeed(0.01);&#10;        constellationBackground.setTwinkleIntensity(0.3);&#10;        constellationBackground.setShowConstellationLines(true);&#10;        constellationBackground.setSkyColor(AnsiColor.BLACK);&#10;&#10;        // Create day-night cycle background&#10;        dayNightBackground = new DayNightCycleBackgroundProvider(80, 25);&#10;        dayNightBackground.setTimeSpeed(0.0001); // Slightly faster for demo&#10;        dayNightBackground.setAutomaticWeather(true);&#10;        dayNightBackground.setShowCelestialBodies(true);&#10;        dayNightBackground.setCurrentTime(0.5); // Start at noon&#10;    }&#10;&#10;    private void setupMap() {&#10;        // Create a simple map with open areas to show the background&#10;        String[] map = {&#10;            &quot;################&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ####    ##  #&quot;,&#10;            &quot;#    ##        #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#     ##       #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#  ##    ####  #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;#      ##      #&quot;,&#10;            &quot;#              #&quot;,&#10;            &quot;################&quot;&#10;        };&#10;        raycastingCanvas.setMap(map);&#10;    }&#10;&#10;    private void setupScreen() {&#10;        screen.setContent(raycastingCanvas);&#10;&#10;        // Register keyboard shortcuts&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ESC.name(), () -&gt; {&#10;            try {&#10;                processLoop.stop();&#10;            } catch (IOException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;&#10;        screen.registerShortcut(&quot;1&quot;, () -&gt; {&#10;            setBackground(BackgroundType.SOLID);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;2&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CLOUDS);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;3&quot;, () -&gt; {&#10;            setBackground(BackgroundType.STARFIELD);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;4&quot;, () -&gt; {&#10;            setBackground(BackgroundType.CONSTELLATION);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;5&quot;, () -&gt; {&#10;            setBackground(BackgroundType.DAY_NIGHT_CYCLE);&#10;        });&#10;&#10;        // Day-Night cycle specific controls&#10;        screen.registerShortcut(&quot;T&quot;, () -&gt; {&#10;            toggleTimeSpeed();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;            cycleWeather();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;N&quot;, () -&gt; {&#10;            setTimeToNight();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;M&quot;, () -&gt; {&#10;            setTimeToMidday();&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_UP.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut( KeyEvent.SpecialKey.ARROW_DOWN.name(), () -&gt; {&#10;            raycastingCanvas.movePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;A&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;D&quot;, () -&gt; {&#10;            raycastingCanvas.strafePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_LEFT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(-0.1);&#10;        });&#10;&#10;        screen.registerShortcut(KeyEvent.SpecialKey.ARROW_RIGHT.name(), () -&gt; {&#10;            raycastingCanvas.rotatePlayer(0.1);&#10;        });&#10;&#10;        screen.registerShortcut(&quot;C&quot;, () -&gt; {&#10;            toggleCeilings();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;H&quot;, () -&gt; {&#10;            showHelp();&#10;        });&#10;&#10;        screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;            adjustSunnyBias();&#10;        });&#10;    }&#10;&#10;    private void setBackground(BackgroundType backgroundType) {&#10;        // Remove current background from animation manager&#10;        if (currentBackground == BackgroundType.CLOUDS) {&#10;            processLoop.removeAnimationTicker(cloudsBackground);&#10;        } else if (currentBackground == BackgroundType.STARFIELD) {&#10;            processLoop.removeAnimationTicker(startfieldThrottle);&#10;        } else if (currentBackground == BackgroundType.CONSTELLATION) {&#10;            processLoop.removeAnimationTicker(constellationBackground);&#10;        } else if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            processLoop.removeAnimationTicker(dayNightBackground);&#10;        }&#10;&#10;        // Set new background&#10;        currentBackground = backgroundType;&#10;        BackgroundProvider provider;&#10;&#10;        switch (backgroundType) {&#10;            case SOLID:&#10;                provider = solidBackground;&#10;                break;&#10;            case CLOUDS:&#10;                provider = cloudsBackground;&#10;                processLoop.addAnimationTicker(cloudsBackground);&#10;                break;&#10;            case STARFIELD:&#10;                provider = starfieldBackground;&#10;                processLoop.addAnimationTicker(startfieldThrottle);&#10;                break;&#10;            case CONSTELLATION:&#10;                provider = constellationBackground;&#10;                processLoop.addAnimationTicker(constellationBackground);&#10;                break;&#10;            case DAY_NIGHT_CYCLE:&#10;                provider = dayNightBackground;&#10;                processLoop.addAnimationTicker(dayNightBackground);&#10;                break;&#10;            default:&#10;                provider = solidBackground;&#10;        }&#10;&#10;        raycastingCanvas.setBackgroundProvider(provider);&#10;        System.out.println(&quot;Switched to: &quot; + backgroundType.getDescription());&#10;    }&#10;&#10;    private void toggleCeilings() {&#10;        boolean currentState = raycastingCanvas.isRenderCeilings();&#10;        raycastingCanvas.setRenderCeilings(!currentState);&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (currentState ? &quot;OFF&quot; : &quot;ON&quot;));&#10;    }&#10;&#10;    private void showHelp() {&#10;        System.out.println(&quot;\n=== Background Demo Controls ===&quot;);&#10;        System.out.println(&quot;Movement:&quot;);&#10;        System.out.println(&quot;  ↑/↓      - Move forward/backward&quot;);&#10;        System.out.println(&quot;  A/D      - Strafe left/right&quot;);&#10;        System.out.println(&quot;  ←/→      - Turn left/right&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Backgrounds:&quot;);&#10;        System.out.println(&quot;  1        - Solid color background&quot;);&#10;        System.out.println(&quot;  2        - Animated clouds background&quot;);&#10;        System.out.println(&quot;  3        - Animated starfield background&quot;);&#10;        System.out.println(&quot;  4        - Constellation background&quot;);&#10;        System.out.println(&quot;  5        - Day-Night cycle background&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Day-Night Cycle Controls (when active):&quot;);&#10;        System.out.println(&quot;  T        - Toggle time speed (slow/fast)&quot;);&#10;        System.out.println(&quot;  W        - Cycle weather (sunny→cloudy→rainy→stormy)&quot;);&#10;        System.out.println(&quot;  B        - Adjust sunny weather bias (low→med→high→very high)&quot;);&#10;        System.out.println(&quot;  N        - Set time to night (midnight)&quot;);&#10;        System.out.println(&quot;  M        - Set time to midday (noon)&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Options:&quot;);&#10;        System.out.println(&quot;  C        - Toggle ceiling rendering&quot;);&#10;        System.out.println(&quot;  H        - Show this help&quot;);&#10;        System.out.println(&quot;  ESC      - Exit demo&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Current background: &quot; + currentBackground.getDescription());&#10;        System.out.println(&quot;Ceiling rendering: &quot; + (raycastingCanvas.isRenderCeilings() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;&#10;        // Show additional info for Day-Night cycle&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            System.out.println();&#10;            System.out.println(&quot;Day-Night Cycle Status:&quot;);&#10;            System.out.println(&quot;  Time: &quot; + dayNightBackground.getTimeString());&#10;            System.out.println(&quot;  Weather: &quot; + dayNightBackground.getCurrentWeatherString());&#10;            System.out.println(&quot;  Auto Weather: &quot; + (dayNightBackground.isAutomaticWeather() ? &quot;ON&quot; : &quot;OFF&quot;));&#10;        }&#10;&#10;        System.out.println(&quot;===============================\n&quot;);&#10;    }&#10;&#10;    private void toggleTimeSpeed() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentSpeed = dayNightBackground.getTimeSpeed();&#10;            double newSpeed = currentSpeed &lt;= 0.0001 ? 0.001 : 0.0001; // Toggle between slow and fast&#10;            dayNightBackground.setTimeSpeed(newSpeed);&#10;            System.out.println(&quot;Time speed: &quot; + (newSpeed &gt; 0.0001 ? &quot;FAST&quot; : &quot;SLOW&quot;));&#10;        }&#10;    }&#10;&#10;    private void cycleWeather() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            DayNightCycleBackgroundProvider.WeatherType[] weathers =&#10;                DayNightCycleBackgroundProvider.WeatherType.values();&#10;            DayNightCycleBackgroundProvider.WeatherType current = dayNightBackground.getCurrentWeather();&#10;&#10;            // Find next weather type&#10;            int currentIndex = 0;&#10;            for (int i = 0; i &lt; weathers.length; i++) {&#10;                if (weathers[i] == current) {&#10;                    currentIndex = i;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            DayNightCycleBackgroundProvider.WeatherType nextWeather =&#10;                weathers[(currentIndex + 1) % weathers.length];&#10;            dayNightBackground.setWeather(nextWeather);&#10;            System.out.println(&quot;Weather: &quot; + nextWeather.getName());&#10;        }&#10;    }&#10;&#10;    private void setTimeToNight() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.0); // Midnight&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Night)&quot;);&#10;        }&#10;    }&#10;&#10;    private void setTimeToMidday() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            dayNightBackground.setTimeOfDay(0.5); // Noon&#10;            System.out.println(&quot;Time set to: &quot; + dayNightBackground.getTimeString() + &quot; (Midday)&quot;);&#10;        }&#10;    }&#10;&#10;    private void adjustSunnyBias() {&#10;        if (currentBackground == BackgroundType.DAY_NIGHT_CYCLE) {&#10;            double currentBias = dayNightBackground.getSunnyWeatherBias();&#10;            // Cycle through different bias levels: 0.3 -&gt; 0.5 -&gt; 0.7 -&gt; 0.9 -&gt; 0.3&#10;            double newBias;&#10;            if (currentBias &lt; 0.4) {&#10;                newBias = 0.5; // Low -&gt; Medium&#10;            } else if (currentBias &lt; 0.6) {&#10;                newBias = 0.7; // Medium -&gt; High&#10;            } else if (currentBias &lt; 0.8) {&#10;                newBias = 0.9; // High -&gt; Very High&#10;            } else {&#10;                newBias = 0.3; // Very High -&gt; Low&#10;            }&#10;&#10;            dayNightBackground.setSunnyWeatherBias(newBias);&#10;            String biasLevel = getBiasLevelName(newBias);&#10;            System.out.println(&quot;Sunny weather bias: &quot; + biasLevel + &quot; (&quot; + Math.round(newBias * 100) + &quot;%)&quot;);&#10;        }&#10;    }&#10;&#10;    private String getBiasLevelName(double bias) {&#10;        if (bias &lt; 0.4) return &quot;LOW&quot;;&#10;        if (bias &lt; 0.6) return &quot;MEDIUM&quot;;&#10;        if (bias &lt; 0.8) return &quot;HIGH&quot;;&#10;        return &quot;VERY HIGH&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/DayNightCycleBackgroundProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/raycasting/src/main/java/com/consolemaster/raycasting/DayNightCycleBackgroundProvider.java" />
              <option name="originalContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.StyledChar;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationTicker;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.util.Random;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * A background provider that simulates a complete day-night cycle with weather systems.&#10; * Features automatic weather changes, sun/moon movement, and realistic sky colors.&#10; * Includes sunny, cloudy, rainy, and stormy weather conditions.&#10; * Note: This provider must be manually registered with the AnimationManager for animation.&#10; */&#10;@Getter&#10;@Setter&#10;public class DayNightCycleBackgroundProvider implements BackgroundProvider, AnimationTicker {&#10;&#10;    // Time and speed settings&#10;    private double timeSpeed = 0.00001; // How fast time progresses (0.01 = slow, 0.1 = fast)&#10;    private double currentTime = 0.5; // Time of day (0.0 = midnight, 0.5 = noon, 1.0 = midnight)&#10;&#10;    // Weather settings&#10;    private boolean automaticWeather = false;&#10;    private double weatherChangeSpeed = 0.001; // How often weather changes&#10;    private double sunnyWeatherBias = 0.99; // Probability bias towards sunny weather (0.0 = equal, 1.0 = always sunny)&#10;    private WeatherType currentWeather = WeatherType.SUNNY;&#10;    private double weatherTransition = 0.0; // Current weather transition progress (0.0 to 1.0)&#10;    private WeatherType targetWeather = WeatherType.SUNNY;&#10;&#10;    // Visual settings&#10;    private boolean showCelestialBodies = true; // Show sun, moon, stars&#10;    private double rainIntensity = 1.0;&#10;    private double stormIntensity = 1.0;&#10;&#10;    private Random random = new Random();&#10;    private int canvasWidth = 80;&#10;    private int canvasHeight = 25;&#10;    private double playerAngle = 0.0;&#10;&#10;    // Celestial objects&#10;    private List&lt;Star&gt; stars = new ArrayList&lt;&gt;();&#10;    private double weatherTimer = 0.0;&#10;&#10;    public enum WeatherType {&#10;        SUNNY(&quot;Sunny&quot;, AnsiColor.CYAN, AnsiColor.BRIGHT_CYAN),&#10;        CLOUDY(&quot;Cloudy&quot;, AnsiColor.BRIGHT_BLACK, AnsiColor.WHITE),&#10;        RAINY(&quot;Rainy&quot;, AnsiColor.BLUE, AnsiColor.BRIGHT_BLUE),&#10;        STORMY(&quot;Stormy&quot;, AnsiColor.BLACK, AnsiColor.BRIGHT_BLACK);&#10;&#10;        private final String name;&#10;        private final AnsiColor primaryColor;&#10;        private final AnsiColor secondaryColor;&#10;&#10;        WeatherType(String name, AnsiColor primaryColor, AnsiColor secondaryColor) {&#10;            this.name = name;&#10;            this.primaryColor = primaryColor;&#10;            this.secondaryColor = secondaryColor;&#10;        }&#10;&#10;        public String getName() { return name; }&#10;        public AnsiColor getPrimaryColor() { return primaryColor; }&#10;        public AnsiColor getSecondaryColor() { return secondaryColor; }&#10;    }&#10;&#10;    public DayNightCycleBackgroundProvider() {&#10;        initializeStars();&#10;    }&#10;&#10;    public DayNightCycleBackgroundProvider(int canvasWidth, int canvasHeight) {&#10;        this.canvasWidth = canvasWidth;&#10;        this.canvasHeight = canvasHeight;&#10;        initializeStars();&#10;    }&#10;&#10;    private void initializeStars() {&#10;        stars.clear();&#10;        // Create stars for nighttime&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            double x = random.nextDouble() * canvasWidth;&#10;            double y = random.nextDouble() * (canvasHeight * 0.7); // Only in upper part of sky&#10;            double brightness = 0.3 + random.nextDouble() * 0.7;&#10;            double twinklePhase = random.nextDouble() * Math.PI * 2;&#10;            double twinkleSpeed = 0.02 + random.nextDouble() * 0.08;&#10;&#10;            stars.add(new Star(x, y, brightness, twinklePhase, twinkleSpeed));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void setDimensionAndAngle(int width, int height, double playerAngle) {&#10;        this.playerAngle = playerAngle;&#10;        if (width != this.canvasWidth || height != this.canvasHeight) {&#10;            this.canvasWidth = width;&#10;            this.canvasHeight = height;&#10;            initializeStars();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public StyledChar getBackground(int x, int y) {&#10;        // Calculate sky color based on time of day and weather&#10;        AnsiColor skyColor = calculateSkyColor();&#10;&#10;        // Check for weather effects first (they can hide celestial bodies)&#10;        StyledChar weather = getWeatherEffect(x, y, skyColor);&#10;        if (weather != null) {&#10;            return weather;&#10;        }&#10;&#10;        // Check for celestial bodies (sun, moon, stars) - only if not covered by weather&#10;        if (showCelestialBodies) {&#10;            StyledChar celestial = getCelestialBody(x, y);&#10;            if (celestial != null) {&#10;                return celestial;&#10;            }&#10;        }&#10;&#10;&#10;        // Return sky&#10;        return new StyledChar(' ', null, skyColor, null);&#10;    }&#10;&#10;    private AnsiColor calculateSkyColor() {&#10;        // Calculate base sky color from time of day&#10;        AnsiColor timeColor;&#10;&#10;        if (isNight()) {&#10;            timeColor = AnsiColor.BLACK;&#10;        } else if (isDawn() || isDusk()) {&#10;            // Sunrise/sunset colors&#10;            double dawnDuskProgress = getDawnDuskProgress();&#10;            if (dawnDuskProgress &lt; 0.5) {&#10;                timeColor = AnsiColor.MAGENTA; // Purple dawn/dusk&#10;            } else {&#10;                timeColor = AnsiColor.YELLOW; // Orange dawn/dusk&#10;            }&#10;        } else {&#10;            // Daytime&#10;            timeColor = AnsiColor.CYAN;&#10;        }&#10;&#10;        // Modify color based on weather&#10;        return modifyColorForWeather(timeColor);&#10;    }&#10;&#10;    private AnsiColor modifyColorForWeather(AnsiColor baseColor) {&#10;        // Blend current weather with target weather based on transition&#10;        WeatherType effectiveWeather = currentWeather;&#10;&#10;        if (weatherTransition &gt; 0.5 &amp;&amp; targetWeather != currentWeather) {&#10;            effectiveWeather = targetWeather;&#10;        }&#10;&#10;        switch (effectiveWeather) {&#10;            case CLOUDY:&#10;                return baseColor == AnsiColor.CYAN ? AnsiColor.BRIGHT_BLACK : baseColor;&#10;            case RAINY:&#10;                return baseColor == AnsiColor.CYAN ? AnsiColor.BLUE :&#10;                       baseColor == AnsiColor.BLACK ? AnsiColor.BLUE : baseColor;&#10;            case STORMY:&#10;                return AnsiColor.BLACK;&#10;            default:&#10;                return baseColor;&#10;        }&#10;    }&#10;&#10;    private StyledChar getCelestialBody(int x, int y) {&#10;        double adjustedX = (x + (playerAngle / (Math.PI * 2)) * canvasWidth) % canvasWidth;&#10;&#10;        if (isDay()) {&#10;            // Draw sun&#10;            StyledChar sun = getSun(adjustedX, y);&#10;            if (sun != null) return sun;&#10;        } else if (isNight()) {&#10;            // Draw moon&#10;            StyledChar moon = getMoon(adjustedX, y);&#10;            if (moon != null) return moon;&#10;&#10;            // Draw stars&#10;            StyledChar star = getStars(adjustedX, y);&#10;            if (star != null) return star;&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getSun(double x, double y) {&#10;        // Calculate sun position based on time&#10;        double sunProgress = (currentTime - 0.25) / 0.5; // Sun visible from 6am to 6pm&#10;        if (sunProgress &lt; 0 || sunProgress &gt; 1) return null;&#10;&#10;        double sunX = sunProgress * canvasWidth;&#10;        double sunY = Math.sin(sunProgress * Math.PI) * (canvasHeight * 0.3) + (canvasHeight * 0.1);&#10;&#10;        double distance = Math.sqrt(Math.pow(x - sunX, 2) + Math.pow(y - sunY, 2));&#10;&#10;        // Larger, more visible sun with extended radius and multiple layers&#10;        if (distance &lt; 3.0) { // Increased radius from 1.5 to 3.0&#10;            if (distance &lt; 0.8) {&#10;                return new StyledChar('☀', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            } else if (distance &lt; 1.5) {&#10;                return new StyledChar('*', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            } else if (distance &lt; 2.2) {&#10;                return new StyledChar('*', AnsiColor.YELLOW, calculateSkyColor(), null);&#10;            } else {&#10;                return new StyledChar('·', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getMoon(double x, double y) {&#10;        // Calculate moon position (opposite to sun)&#10;        double moonProgress = currentTime &lt; 0.5 ? (currentTime + 0.5) : (currentTime - 0.5);&#10;        moonProgress = (moonProgress - 0.25) / 0.5;&#10;        if (moonProgress &lt; 0 || moonProgress &gt; 1) return null;&#10;&#10;        double moonX = moonProgress * canvasWidth;&#10;        double moonY = Math.sin(moonProgress * Math.PI) * (canvasHeight * 0.3) + (canvasHeight * 0.1);&#10;&#10;        double distance = Math.sqrt(Math.pow(x - moonX, 2) + Math.pow(y - moonY, 2));&#10;&#10;        // Larger, more visible moon with extended radius and multiple layers&#10;        if (distance &lt; 2.5) { // Increased radius from 1.0 to 2.5&#10;            if (distance &lt; 0.8) {&#10;                return new StyledChar('☽', AnsiColor.BRIGHT_WHITE, calculateSkyColor(), null);&#10;            } else if (distance &lt; 1.5) {&#10;                return new StyledChar('○', AnsiColor.WHITE, calculateSkyColor(), null);&#10;            } else if (distance &lt; 2.0) {&#10;                return new StyledChar('○', AnsiColor.BRIGHT_BLACK, calculateSkyColor(), null);&#10;            } else {&#10;                return new StyledChar('·', AnsiColor.WHITE, calculateSkyColor(), null);&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getStars(double x, double y) {&#10;        // Only show stars at night and if weather allows&#10;        if (!isNight() || currentWeather == WeatherType.STORMY) return null;&#10;&#10;        double starVisibility = getStarVisibility();&#10;        if (starVisibility &lt; 0.3) return null;&#10;&#10;        for (Star star : stars) {&#10;            double adjustedStarX = (star.x + (playerAngle / (Math.PI * 2)) * canvasWidth) % canvasWidth;&#10;            if (adjustedStarX &lt; 0) adjustedStarX += canvasWidth;&#10;&#10;            if (Math.abs(adjustedStarX - x) &lt; 1.0 &amp;&amp; Math.abs(star.y - y) &lt; 1.0) {&#10;                double twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;&#10;                double effectiveBrightness = star.brightness * twinkle * starVisibility;&#10;&#10;                if (effectiveBrightness &gt; 0.5) {&#10;                    char starChar = effectiveBrightness &gt; 0.8 ? '*' : '·';&#10;                    AnsiColor starColor = effectiveBrightness &gt; 0.7 ? AnsiColor.WHITE : AnsiColor.BRIGHT_BLACK;&#10;                    return new StyledChar(starChar, starColor, calculateSkyColor(), null);&#10;                }&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getWeatherEffect(int x, int y, AnsiColor skyColor) {&#10;        switch (currentWeather) {&#10;            case CLOUDY:&#10;                return getCloudEffect(x, y, skyColor);&#10;            case RAINY:&#10;                return getRainEffect(x, y, skyColor);&#10;            case STORMY:&#10;                return getStormEffect(x, y, skyColor);&#10;            default:&#10;                return null;&#10;        }&#10;    }&#10;&#10;    private StyledChar getCloudEffect(int x, int y, AnsiColor skyColor) {&#10;        // Simple cloud simulation&#10;        double cloudNoise = getPerlinNoise(x * 0.1, y * 0.2 + weatherTimer * 0.1);&#10;        if (cloudNoise &gt; 0.6) {&#10;            if (cloudNoise &gt; 0.8) {&#10;                return new StyledChar('█', AnsiColor.WHITE, skyColor, null);&#10;            } else if (cloudNoise &gt; 0.7) {&#10;                return new StyledChar('▓', AnsiColor.BRIGHT_BLACK, skyColor, null);&#10;            } else {&#10;                return new StyledChar('░', AnsiColor.BRIGHT_BLACK, skyColor, null);&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getRainEffect(int x, int y, AnsiColor skyColor) {&#10;        // Rain drops&#10;        double rainNoise = getPerlinNoise(x * 0.3, y * 0.1 + weatherTimer * 2.0);&#10;        if (rainNoise &gt; 0.7 * (2.0 - rainIntensity)) {&#10;            char rainChar = rainIntensity &gt; 0.7 ? '|' : '\'';&#10;            return new StyledChar(rainChar, AnsiColor.BLUE, skyColor, null);&#10;        }&#10;&#10;        // Background clouds&#10;        StyledChar cloud = getCloudEffect(x, y, skyColor);&#10;        if (cloud != null) return cloud;&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getStormEffect(int x, int y, AnsiColor skyColor) {&#10;        // Lightning effect (random flashes)&#10;        if (random.nextDouble() &lt; 0.001 * stormIntensity) {&#10;            return new StyledChar('⚡', AnsiColor.BRIGHT_YELLOW, AnsiColor.BLACK, null);&#10;        }&#10;&#10;        // Heavy rain&#10;        double stormNoise = getPerlinNoise(x * 0.5, y * 0.1 + weatherTimer * 3.0);&#10;        if (stormNoise &gt; 0.5) {&#10;            return new StyledChar('║', AnsiColor.BRIGHT_BLUE, skyColor, null);&#10;        }&#10;&#10;        // Dark storm clouds&#10;        double cloudNoise = getPerlinNoise(x * 0.05, y * 0.1 + weatherTimer * 0.05);&#10;        if (cloudNoise &gt; 0.4) {&#10;            return new StyledChar('█', AnsiColor.BLACK, skyColor, null);&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private double getPerlinNoise(double x, double y) {&#10;        // Simple pseudo-Perlin noise&#10;        return (Math.sin(x) * Math.cos(y) + Math.sin(x * 2.1) * Math.cos(y * 1.7) +&#10;                Math.sin(x * 0.7) * Math.cos(y * 2.3)) / 3.0 + 0.5;&#10;    }&#10;&#10;    private boolean isDay() {&#10;        return currentTime &gt; 0.25 &amp;&amp; currentTime &lt; 0.75;&#10;    }&#10;&#10;    private boolean isNight() {&#10;        return currentTime &lt; 0.25 || currentTime &gt; 0.75;&#10;    }&#10;&#10;    private boolean isDawn() {&#10;        return currentTime &gt; 0.2 &amp;&amp; currentTime &lt; 0.3;&#10;    }&#10;&#10;    private boolean isDusk() {&#10;        return currentTime &gt; 0.7 &amp;&amp; currentTime &lt; 0.8;&#10;    }&#10;&#10;    private double getDawnDuskProgress() {&#10;        if (isDawn()) {&#10;            return (currentTime - 0.2) / 0.1;&#10;        } else if (isDusk()) {&#10;            return (currentTime - 0.7) / 0.1;&#10;        }&#10;        return 0.0;&#10;    }&#10;&#10;    private double getStarVisibility() {&#10;        if (currentWeather == WeatherType.STORMY) return 0.0;&#10;        if (currentWeather == WeatherType.RAINY) return 0.2;&#10;        if (currentWeather == WeatherType.CLOUDY) return 0.6;&#10;        return 1.0;&#10;    }&#10;&#10;    @Override&#10;    public boolean tick() {&#10;        // Update time&#10;        currentTime += timeSpeed;&#10;        if (currentTime &gt;= 1.0) {&#10;            currentTime -= 1.0;&#10;        }&#10;&#10;        // Update weather timer&#10;        weatherTimer += 0.1;&#10;&#10;        // Handle automatic weather changes&#10;        if (automaticWeather) {&#10;            updateAutomaticWeather();&#10;        }&#10;&#10;        // Update weather transition&#10;        if (currentWeather != targetWeather) {&#10;            weatherTransition += 0.02; // Transition speed&#10;            if (weatherTransition &gt;= 1.0) {&#10;                currentWeather = targetWeather;&#10;                weatherTransition = 0.0;&#10;            }&#10;        }&#10;&#10;        // Update star twinkling&#10;        for (Star star : stars) {&#10;            star.twinklePhase += star.twinkleSpeed;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    private void updateAutomaticWeather() {&#10;        // Change weather randomly but slowly, with bias towards sunny weather&#10;        if (random.nextDouble() &lt; weatherChangeSpeed) {&#10;            WeatherType newWeather = selectWeatherWithBias();&#10;&#10;            // Don't change to the same weather&#10;            if (newWeather != currentWeather) {&#10;                setTargetWeather(newWeather);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Selects a new weather type with bias towards sunny weather.&#10;     * The sunnyWeatherBias parameter controls how likely sunny weather is:&#10;     * - 0.0 = equal probability for all weather types&#10;     * - 0.5 = sunny weather is moderately favored&#10;     * - 0.7 = sunny weather is strongly favored (default)&#10;     * - 1.0 = always sunny weather&#10;     */&#10;    private WeatherType selectWeatherWithBias() {&#10;        double rand = random.nextDouble();&#10;&#10;        // If random value is below the sunny bias, return sunny weather&#10;        if (rand &lt; sunnyWeatherBias) {&#10;            return WeatherType.SUNNY;&#10;        }&#10;&#10;        // Otherwise, select from remaining weather types&#10;        // Scale the remaining probability space (1.0 - sunnyWeatherBias) across other weather types&#10;        double remainingSpace = 1.0 - sunnyWeatherBias;&#10;        double scaledRand = (rand - sunnyWeatherBias) / remainingSpace;&#10;&#10;        // Distribute remaining probability equally among non-sunny weather types&#10;        WeatherType[] nonSunnyWeathers = {WeatherType.CLOUDY, WeatherType.RAINY, WeatherType.STORMY};&#10;        int index = (int) (scaledRand * nonSunnyWeathers.length);&#10;        index = Math.min(index, nonSunnyWeathers.length - 1); // Ensure we don't go out of bounds&#10;&#10;        return nonSunnyWeathers[index];&#10;    }&#10;    // Public methods for manual weather control&#10;    public void setWeather(WeatherType weather) {&#10;        this.automaticWeather = false;&#10;        setTargetWeather(weather);&#10;    }&#10;&#10;    public void setTargetWeather(WeatherType weather) {&#10;        if (this.targetWeather != weather) {&#10;            this.targetWeather = weather;&#10;            this.weatherTransition = 0.0;&#10;        }&#10;    }&#10;&#10;    public void setTimeOfDay(double time) {&#10;        this.currentTime = Math.max(0.0, Math.min(1.0, time));&#10;    }&#10;&#10;    public String getTimeString() {&#10;        int hours = (int) (currentTime * 24);&#10;        int minutes = (int) ((currentTime * 24 - hours) * 60);&#10;        return String.format(&quot;%02d:%02d&quot;, hours, minutes);&#10;    }&#10;&#10;    public String getCurrentWeatherString() {&#10;        if (currentWeather != targetWeather) {&#10;            return currentWeather.getName() + &quot; → &quot; + targetWeather.getName();&#10;        }&#10;        return currentWeather.getName();&#10;    }&#10;&#10;    /**&#10;     * Star class for nighttime sky&#10;     */&#10;    private static class Star {&#10;        double x, y;&#10;        double brightness;&#10;        double twinklePhase;&#10;        double twinkleSpeed;&#10;&#10;        Star(double x, double y, double brightness, double twinklePhase, double twinkleSpeed) {&#10;            this.x = x;&#10;            this.y = y;&#10;            this.brightness = brightness;&#10;            this.twinklePhase = twinklePhase;&#10;            this.twinkleSpeed = twinkleSpeed;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.raycasting;&#10;&#10;import com.consolemaster.StyledChar;&#10;import com.consolemaster.AnsiColor;&#10;import com.consolemaster.AnimationTicker;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.util.Random;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * A background provider that simulates a complete day-night cycle with weather systems.&#10; * Features automatic weather changes, sun/moon movement, and realistic sky colors.&#10; * Includes sunny, cloudy, rainy, and stormy weather conditions.&#10; * Note: This provider must be manually registered with the AnimationManager for animation.&#10; */&#10;@Getter&#10;@Setter&#10;public class DayNightCycleBackgroundProvider implements BackgroundProvider, AnimationTicker {&#10;&#10;    // Time and speed settings&#10;    private double timeSpeed = 0.00001; // How fast time progresses (0.01 = slow, 0.1 = fast)&#10;    private double currentTime = 0.5; // Time of day (0.0 = midnight, 0.5 = noon, 1.0 = midnight)&#10;&#10;    // Weather settings&#10;    private boolean automaticWeather = false;&#10;    private double weatherChangeSpeed = 0.001; // How often weather changes&#10;    private double sunnyWeatherBias = 0.99; // Probability bias towards sunny weather (0.0 = equal, 1.0 = always sunny)&#10;    private WeatherType currentWeather = WeatherType.SUNNY;&#10;    private double weatherTransition = 0.0; // Current weather transition progress (0.0 to 1.0)&#10;    private WeatherType targetWeather = WeatherType.SUNNY;&#10;&#10;    // Visual settings&#10;    private boolean showCelestialBodies = true; // Show sun, moon, stars&#10;    private double rainIntensity = 1.0;&#10;    private double stormIntensity = 1.0;&#10;&#10;    private Random random = new Random();&#10;    private int canvasWidth = 80;&#10;    private int canvasHeight = 25;&#10;    private double playerAngle = 0.0;&#10;&#10;    // Celestial objects&#10;    private List&lt;Star&gt; stars = new ArrayList&lt;&gt;();&#10;    private double weatherTimer = 0.0;&#10;&#10;    public enum WeatherType {&#10;        SUNNY(&quot;Sunny&quot;, AnsiColor.CYAN, AnsiColor.BRIGHT_CYAN),&#10;        CLOUDY(&quot;Cloudy&quot;, AnsiColor.BRIGHT_BLACK, AnsiColor.WHITE),&#10;        RAINY(&quot;Rainy&quot;, AnsiColor.BLUE, AnsiColor.BRIGHT_BLUE),&#10;        STORMY(&quot;Stormy&quot;, AnsiColor.BLACK, AnsiColor.BRIGHT_BLACK);&#10;&#10;        private final String name;&#10;        private final AnsiColor primaryColor;&#10;        private final AnsiColor secondaryColor;&#10;&#10;        WeatherType(String name, AnsiColor primaryColor, AnsiColor secondaryColor) {&#10;            this.name = name;&#10;            this.primaryColor = primaryColor;&#10;            this.secondaryColor = secondaryColor;&#10;        }&#10;&#10;        public String getName() { return name; }&#10;        public AnsiColor getPrimaryColor() { return primaryColor; }&#10;        public AnsiColor getSecondaryColor() { return secondaryColor; }&#10;    }&#10;&#10;    public DayNightCycleBackgroundProvider() {&#10;        initializeStars();&#10;    }&#10;&#10;    public DayNightCycleBackgroundProvider(int canvasWidth, int canvasHeight) {&#10;        this.canvasWidth = canvasWidth;&#10;        this.canvasHeight = canvasHeight;&#10;        initializeStars();&#10;    }&#10;&#10;    private void initializeStars() {&#10;        stars.clear();&#10;        // Create stars for nighttime&#10;        for (int i = 0; i &lt; 50; i++) {&#10;            double x = random.nextDouble() * canvasWidth;&#10;            double y = random.nextDouble() * (canvasHeight * 0.7); // Only in upper part of sky&#10;            double brightness = 0.3 + random.nextDouble() * 0.7;&#10;            double twinklePhase = random.nextDouble() * Math.PI * 2;&#10;            double twinkleSpeed = 0.02 + random.nextDouble() * 0.08;&#10;&#10;            stars.add(new Star(x, y, brightness, twinklePhase, twinkleSpeed));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void setDimensionAndAngle(int width, int height, double playerAngle) {&#10;        this.playerAngle = playerAngle;&#10;        if (width != this.canvasWidth || height != this.canvasHeight) {&#10;            this.canvasWidth = width;&#10;            this.canvasHeight = height;&#10;            initializeStars();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public StyledChar getBackground(int x, int y) {&#10;        // Calculate sky color based on time of day and weather&#10;        AnsiColor skyColor = calculateSkyColor();&#10;&#10;        // Check for weather effects first (they can hide celestial bodies)&#10;        StyledChar weather = getWeatherEffect(x, y, skyColor);&#10;        if (weather != null) {&#10;            return weather;&#10;        }&#10;&#10;        // Check for celestial bodies (sun, moon, stars) - only if not covered by weather&#10;        if (showCelestialBodies) {&#10;            StyledChar celestial = getCelestialBody(x, y);&#10;            if (celestial != null) {&#10;                return celestial;&#10;            }&#10;        }&#10;&#10;&#10;        // Return sky&#10;        return new StyledChar(' ', null, skyColor, null);&#10;    }&#10;&#10;    private AnsiColor calculateSkyColor() {&#10;        // Calculate base sky color from time of day&#10;        AnsiColor timeColor;&#10;&#10;        if (isNight()) {&#10;            timeColor = AnsiColor.BLACK;&#10;        } else if (isDawn() || isDusk()) {&#10;            // Sunrise/sunset colors&#10;            double dawnDuskProgress = getDawnDuskProgress();&#10;            if (dawnDuskProgress &lt; 0.5) {&#10;                timeColor = AnsiColor.MAGENTA; // Purple dawn/dusk&#10;            } else {&#10;                timeColor = AnsiColor.YELLOW; // Orange dawn/dusk&#10;            }&#10;        } else {&#10;            // Daytime&#10;            timeColor = AnsiColor.CYAN;&#10;        }&#10;&#10;        // Modify color based on weather&#10;        return modifyColorForWeather(timeColor);&#10;    }&#10;&#10;    private AnsiColor modifyColorForWeather(AnsiColor baseColor) {&#10;        // Blend current weather with target weather based on transition&#10;        WeatherType effectiveWeather = currentWeather;&#10;&#10;        if (weatherTransition &gt; 0.5 &amp;&amp; targetWeather != currentWeather) {&#10;            effectiveWeather = targetWeather;&#10;        }&#10;&#10;        switch (effectiveWeather) {&#10;            case CLOUDY:&#10;                return baseColor == AnsiColor.CYAN ? AnsiColor.BRIGHT_BLACK : baseColor;&#10;            case RAINY:&#10;                return baseColor == AnsiColor.CYAN ? AnsiColor.BLUE :&#10;                       baseColor == AnsiColor.BLACK ? AnsiColor.BLUE : baseColor;&#10;            case STORMY:&#10;                return AnsiColor.BLACK;&#10;            default:&#10;                return baseColor;&#10;        }&#10;    }&#10;&#10;    private StyledChar getCelestialBody(int x, int y) {&#10;        double adjustedX = (x + (playerAngle / (Math.PI * 2)) * canvasWidth) % canvasWidth;&#10;&#10;        if (isDay()) {&#10;            // Draw sun&#10;            StyledChar sun = getSun(adjustedX, y);&#10;            if (sun != null) return sun;&#10;        } else if (isNight()) {&#10;            // Draw moon&#10;            StyledChar moon = getMoon(adjustedX, y);&#10;            if (moon != null) return moon;&#10;&#10;            // Draw stars&#10;            StyledChar star = getStars(adjustedX, y);&#10;            if (star != null) return star;&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getSun(double x, double y) {&#10;        // Calculate sun position based on time&#10;        double sunProgress = (currentTime - 0.25) / 0.5; // Sun visible from 6am to 6pm&#10;        if (sunProgress &lt; 0 || sunProgress &gt; 1) return null;&#10;&#10;        double sunX = sunProgress * canvasWidth;&#10;        double sunY = Math.sin(sunProgress * Math.PI) * (canvasHeight * 0.3) + (canvasHeight * 0.1);&#10;&#10;        double distance = Math.sqrt(Math.pow(x - sunX, 2) + Math.pow(y - sunY, 2));&#10;&#10;        // Larger, more visible sun with extended radius and multiple layers&#10;        if (distance &lt; 3.0) { // Increased radius from 1.5 to 3.0&#10;            if (distance &lt; 0.8) {&#10;                return new StyledChar('☀', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            } else if (distance &lt; 1.5) {&#10;                return new StyledChar('*', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            } else if (distance &lt; 2.2) {&#10;                return new StyledChar('*', AnsiColor.YELLOW, calculateSkyColor(), null);&#10;            } else {&#10;                return new StyledChar('·', AnsiColor.BRIGHT_YELLOW, calculateSkyColor(), null);&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getMoon(double x, double y) {&#10;        // Calculate moon position (opposite to sun)&#10;        double moonProgress = currentTime &lt; 0.5 ? (currentTime + 0.5) : (currentTime - 0.5);&#10;        moonProgress = (moonProgress - 0.25) / 0.5;&#10;        if (moonProgress &lt; 0 || moonProgress &gt; 1) return null;&#10;&#10;        double moonX = moonProgress * canvasWidth;&#10;        double moonY = Math.sin(moonProgress * Math.PI) * (canvasHeight * 0.3) + (canvasHeight * 0.1);&#10;&#10;        double distance = Math.sqrt(Math.pow(x - moonX, 2) + Math.pow(y - moonY, 2));&#10;&#10;        // Larger, more visible moon with extended radius and multiple layers&#10;        if (distance &lt; 2.5) { // Increased radius from 1.0 to 2.5&#10;            if (distance &lt; 0.8) {&#10;                return new StyledChar('☽', AnsiColor.BRIGHT_WHITE, calculateSkyColor(), null);&#10;            } else if (distance &lt; 1.5) {&#10;                return new StyledChar('○', AnsiColor.WHITE, calculateSkyColor(), null);&#10;            } else if (distance &lt; 2.0) {&#10;                return new StyledChar('○', AnsiColor.BRIGHT_BLACK, calculateSkyColor(), null);&#10;            } else {&#10;                return new StyledChar('·', AnsiColor.WHITE, calculateSkyColor(), null);&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getStars(double x, double y) {&#10;        // Only show stars at night and if weather allows&#10;        if (!isNight() || currentWeather == WeatherType.STORMY) return null;&#10;&#10;        double starVisibility = getStarVisibility();&#10;        if (starVisibility &lt; 0.3) return null;&#10;&#10;        for (Star star : stars) {&#10;            double adjustedStarX = (star.x + (playerAngle / (Math.PI * 2)) * canvasWidth) % canvasWidth;&#10;            if (adjustedStarX &lt; 0) adjustedStarX += canvasWidth;&#10;&#10;            if (Math.abs(adjustedStarX - x) &lt; 1.0 &amp;&amp; Math.abs(star.y - y) &lt; 1.0) {&#10;                double twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;&#10;                double effectiveBrightness = star.brightness * twinkle * starVisibility;&#10;&#10;                if (effectiveBrightness &gt; 0.5) {&#10;                    char starChar = effectiveBrightness &gt; 0.8 ? '*' : '·';&#10;                    AnsiColor starColor = effectiveBrightness &gt; 0.7 ? AnsiColor.WHITE : AnsiColor.BRIGHT_BLACK;&#10;                    return new StyledChar(starChar, starColor, calculateSkyColor(), null);&#10;                }&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getWeatherEffect(int x, int y, AnsiColor skyColor) {&#10;        switch (currentWeather) {&#10;            case CLOUDY:&#10;                return getCloudEffect(x, y, skyColor);&#10;            case RAINY:&#10;                return getRainEffect(x, y, skyColor);&#10;            case STORMY:&#10;                return getStormEffect(x, y, skyColor);&#10;            default:&#10;                return null;&#10;        }&#10;    }&#10;&#10;    private StyledChar getCloudEffect(int x, int y, AnsiColor skyColor) {&#10;        // Simple cloud simulation&#10;        double cloudNoise = getPerlinNoise(x * 0.1, y * 0.2 + weatherTimer * 0.1);&#10;        if (cloudNoise &gt; 0.6) {&#10;            if (cloudNoise &gt; 0.8) {&#10;                return new StyledChar('█', AnsiColor.WHITE, skyColor, null);&#10;            } else if (cloudNoise &gt; 0.7) {&#10;                return new StyledChar('▓', AnsiColor.BRIGHT_BLACK, skyColor, null);&#10;            } else {&#10;                return new StyledChar('░', AnsiColor.BRIGHT_BLACK, skyColor, null);&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getRainEffect(int x, int y, AnsiColor skyColor) {&#10;        // Rain drops&#10;        double rainNoise = getPerlinNoise(x * 0.3, y * 0.1 + weatherTimer * 2.0);&#10;        if (rainNoise &gt; 0.7 * (2.0 - rainIntensity)) {&#10;            char rainChar = rainIntensity &gt; 0.7 ? '|' : '\'';&#10;&#10;            // Adjust rain color based on time of day&#10;            AnsiColor rainColor;&#10;            if (isNight()) {&#10;                // Darker rain at night&#10;                rainColor = AnsiColor.BLACK;&#10;            } else if (isDawn() || isDusk()) {&#10;                // Medium rain at dawn/dusk&#10;                rainColor = AnsiColor.BRIGHT_BLACK;&#10;            } else {&#10;                // Bright rain during day&#10;                rainColor = AnsiColor.BLUE;&#10;            }&#10;&#10;            return new StyledChar(rainChar, rainColor, skyColor, null);&#10;        }&#10;&#10;        // Background clouds&#10;        StyledChar cloud = getCloudEffect(x, y, skyColor);&#10;        if (cloud != null) return cloud;&#10;&#10;        return null;&#10;    }&#10;&#10;    private StyledChar getStormEffect(int x, int y, AnsiColor skyColor) {&#10;        // Lightning effect (random flashes)&#10;        if (random.nextDouble() &lt; 0.001 * stormIntensity) {&#10;            return new StyledChar('⚡', AnsiColor.BRIGHT_YELLOW, AnsiColor.BLACK, null);&#10;        }&#10;&#10;        // Heavy rain with time-based coloring&#10;        double stormNoise = getPerlinNoise(x * 0.5, y * 0.1 + weatherTimer * 3.0);&#10;        if (stormNoise &gt; 0.5) {&#10;            // Adjust storm rain color based on time of day&#10;            AnsiColor stormRainColor;&#10;            if (isNight()) {&#10;                // Very dark storm rain at night&#10;                stormRainColor = AnsiColor.BLACK;&#10;            } else if (isDawn() || isDusk()) {&#10;                // Dark storm rain at dawn/dusk&#10;                stormRainColor = AnsiColor.BRIGHT_BLACK;&#10;            } else {&#10;                // Bright storm rain during day&#10;                stormRainColor = AnsiColor.BRIGHT_BLUE;&#10;            }&#10;            &#10;            return new StyledChar('║', stormRainColor, skyColor, null);&#10;        }&#10;&#10;        // Dark storm clouds&#10;        double cloudNoise = getPerlinNoise(x * 0.05, y * 0.1 + weatherTimer * 0.05);&#10;        if (cloudNoise &gt; 0.4) {&#10;            return new StyledChar('█', AnsiColor.BLACK, skyColor, null);&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private double getPerlinNoise(double x, double y) {&#10;        // Simple pseudo-Perlin noise&#10;        return (Math.sin(x) * Math.cos(y) + Math.sin(x * 2.1) * Math.cos(y * 1.7) +&#10;                Math.sin(x * 0.7) * Math.cos(y * 2.3)) / 3.0 + 0.5;&#10;    }&#10;&#10;    private boolean isDay() {&#10;        return currentTime &gt; 0.25 &amp;&amp; currentTime &lt; 0.75;&#10;    }&#10;&#10;    private boolean isNight() {&#10;        return currentTime &lt; 0.25 || currentTime &gt; 0.75;&#10;    }&#10;&#10;    private boolean isDawn() {&#10;        return currentTime &gt; 0.2 &amp;&amp; currentTime &lt; 0.3;&#10;    }&#10;&#10;    private boolean isDusk() {&#10;        return currentTime &gt; 0.7 &amp;&amp; currentTime &lt; 0.8;&#10;    }&#10;&#10;    private double getDawnDuskProgress() {&#10;        if (isDawn()) {&#10;            return (currentTime - 0.2) / 0.1;&#10;        } else if (isDusk()) {&#10;            return (currentTime - 0.7) / 0.1;&#10;        }&#10;        return 0.0;&#10;    }&#10;&#10;    private double getStarVisibility() {&#10;        if (currentWeather == WeatherType.STORMY) return 0.0;&#10;        if (currentWeather == WeatherType.RAINY) return 0.2;&#10;        if (currentWeather == WeatherType.CLOUDY) return 0.6;&#10;        return 1.0;&#10;    }&#10;&#10;    @Override&#10;    public boolean tick() {&#10;        // Update time&#10;        currentTime += timeSpeed;&#10;        if (currentTime &gt;= 1.0) {&#10;            currentTime -= 1.0;&#10;        }&#10;&#10;        // Update weather timer&#10;        weatherTimer += 0.1;&#10;&#10;        // Handle automatic weather changes&#10;        if (automaticWeather) {&#10;            updateAutomaticWeather();&#10;        }&#10;&#10;        // Update weather transition&#10;        if (currentWeather != targetWeather) {&#10;            weatherTransition += 0.02; // Transition speed&#10;            if (weatherTransition &gt;= 1.0) {&#10;                currentWeather = targetWeather;&#10;                weatherTransition = 0.0;&#10;            }&#10;        }&#10;&#10;        // Update star twinkling&#10;        for (Star star : stars) {&#10;            star.twinklePhase += star.twinkleSpeed;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    private void updateAutomaticWeather() {&#10;        // Change weather randomly but slowly, with bias towards sunny weather&#10;        if (random.nextDouble() &lt; weatherChangeSpeed) {&#10;            WeatherType newWeather = selectWeatherWithBias();&#10;&#10;            // Don't change to the same weather&#10;            if (newWeather != currentWeather) {&#10;                setTargetWeather(newWeather);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Selects a new weather type with bias towards sunny weather.&#10;     * The sunnyWeatherBias parameter controls how likely sunny weather is:&#10;     * - 0.0 = equal probability for all weather types&#10;     * - 0.5 = sunny weather is moderately favored&#10;     * - 0.7 = sunny weather is strongly favored (default)&#10;     * - 1.0 = always sunny weather&#10;     */&#10;    private WeatherType selectWeatherWithBias() {&#10;        double rand = random.nextDouble();&#10;&#10;        // If random value is below the sunny bias, return sunny weather&#10;        if (rand &lt; sunnyWeatherBias) {&#10;            return WeatherType.SUNNY;&#10;        }&#10;&#10;        // Otherwise, select from remaining weather types&#10;        // Scale the remaining probability space (1.0 - sunnyWeatherBias) across other weather types&#10;        double remainingSpace = 1.0 - sunnyWeatherBias;&#10;        double scaledRand = (rand - sunnyWeatherBias) / remainingSpace;&#10;&#10;        // Distribute remaining probability equally among non-sunny weather types&#10;        WeatherType[] nonSunnyWeathers = {WeatherType.CLOUDY, WeatherType.RAINY, WeatherType.STORMY};&#10;        int index = (int) (scaledRand * nonSunnyWeathers.length);&#10;        index = Math.min(index, nonSunnyWeathers.length - 1); // Ensure we don't go out of bounds&#10;&#10;        return nonSunnyWeathers[index];&#10;    }&#10;    // Public methods for manual weather control&#10;    public void setWeather(WeatherType weather) {&#10;        this.automaticWeather = false;&#10;        setTargetWeather(weather);&#10;    }&#10;&#10;    public void setTargetWeather(WeatherType weather) {&#10;        if (this.targetWeather != weather) {&#10;            this.targetWeather = weather;&#10;            this.weatherTransition = 0.0;&#10;        }&#10;    }&#10;&#10;    public void setTimeOfDay(double time) {&#10;        this.currentTime = Math.max(0.0, Math.min(1.0, time));&#10;    }&#10;&#10;    public String getTimeString() {&#10;        int hours = (int) (currentTime * 24);&#10;        int minutes = (int) ((currentTime * 24 - hours) * 60);&#10;        return String.format(&quot;%02d:%02d&quot;, hours, minutes);&#10;    }&#10;&#10;    public String getCurrentWeatherString() {&#10;        if (currentWeather != targetWeather) {&#10;            return currentWeather.getName() + &quot; → &quot; + targetWeather.getName();&#10;        }&#10;        return currentWeather.getName();&#10;    }&#10;&#10;    /**&#10;     * Star class for nighttime sky&#10;     */&#10;    private static class Star {&#10;        double x, y;&#10;        double brightness;&#10;        double twinklePhase;&#10;        double twinkleSpeed;&#10;&#10;        Star(double x, double y, double brightness, double twinklePhase, double twinkleSpeed) {&#10;            this.x = x;&#10;            this.y = y;&#10;            this.brightness = brightness;&#10;            this.twinklePhase = twinklePhase;&#10;            this.twinkleSpeed = twinkleSpeed;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>