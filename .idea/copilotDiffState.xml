<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/AnsiColor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/AnsiColor.java" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;/**&#10; * ANSI color codes for console output.&#10; * Supports both foreground and background colors.&#10; */&#10;public enum AnsiColor {&#10;    // Standard colors&#10;    BLACK(&quot;\u001B[30m&quot;, &quot;\u001B[40m&quot;),&#10;    RED(&quot;\u001B[31m&quot;, &quot;\u001B[41m&quot;),&#10;    GREEN(&quot;\u001B[32m&quot;, &quot;\u001B[42m&quot;),&#10;    YELLOW(&quot;\u001B[33m&quot;, &quot;\u001B[43m&quot;),&#10;    BLUE(&quot;\u001B[34m&quot;, &quot;\u001B[44m&quot;),&#10;    MAGENTA(&quot;\u001B[35m&quot;, &quot;\u001B[45m&quot;),&#10;    CYAN(&quot;\u001B[36m&quot;, &quot;\u001B[46m&quot;),&#10;    WHITE(&quot;\u001B[37m&quot;, &quot;\u001B[47m&quot;),&#10;    &#10;    // Bright colors&#10;    BRIGHT_BLACK(&quot;\u001B[90m&quot;, &quot;\u001B[100m&quot;),&#10;    BRIGHT_RED(&quot;\u001B[91m&quot;, &quot;\u001B[101m&quot;),&#10;    BRIGHT_GREEN(&quot;\u001B[92m&quot;, &quot;\u001B[102m&quot;),&#10;    BRIGHT_YELLOW(&quot;\u001B[93m&quot;, &quot;\u001B[103m&quot;),&#10;    BRIGHT_BLUE(&quot;\u001B[94m&quot;, &quot;\u001B[104m&quot;),&#10;    BRIGHT_MAGENTA(&quot;\u001B[95m&quot;, &quot;\u001B[105m&quot;),&#10;    BRIGHT_CYAN(&quot;\u001B[96m&quot;, &quot;\u001B[106m&quot;),&#10;    BRIGHT_WHITE(&quot;\u001B[97m&quot;, &quot;\u001B[107m&quot;),&#10;    &#10;    // Reset&#10;    RESET(&quot;\u001B[0m&quot;, &quot;\u001B[0m&quot;);&#10;    &#10;    private final String foregroundCode;&#10;    private final String backgroundCode;&#10;    &#10;    AnsiColor(String foregroundCode, String backgroundCode) {&#10;        this.foregroundCode = foregroundCode;&#10;        this.backgroundCode = backgroundCode;&#10;    }&#10;    &#10;    /**&#10;     * Gets the ANSI code for foreground color.&#10;     */&#10;    public String getForeground() {&#10;        return foregroundCode;&#10;    }&#10;    &#10;    /**&#10;     * Gets the ANSI code for background color.&#10;     */&#10;    public String getBackground() {&#10;        return backgroundCode;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/AnsiFormat.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/AnsiFormat.java" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;/**&#10; * ANSI formatting codes for console text styling.&#10; */&#10;public enum AnsiFormat {&#10;    RESET(&quot;\u001B[0m&quot;),&#10;    BOLD(&quot;\u001B[1m&quot;),&#10;    DIM(&quot;\u001B[2m&quot;),&#10;    ITALIC(&quot;\u001B[3m&quot;),&#10;    UNDERLINE(&quot;\u001B[4m&quot;),&#10;    BLINK(&quot;\u001B[5m&quot;),&#10;    REVERSE(&quot;\u001B[7m&quot;),&#10;    STRIKETHROUGH(&quot;\u001B[9m&quot;),&#10;    &#10;    // Reset specific formatting&#10;    RESET_BOLD(&quot;\u001B[22m&quot;),&#10;    RESET_DIM(&quot;\u001B[22m&quot;),&#10;    RESET_ITALIC(&quot;\u001B[23m&quot;),&#10;    RESET_UNDERLINE(&quot;\u001B[24m&quot;),&#10;    RESET_BLINK(&quot;\u001B[25m&quot;),&#10;    RESET_REVERSE(&quot;\u001B[27m&quot;),&#10;    RESET_STRIKETHROUGH(&quot;\u001B[29m&quot;);&#10;    &#10;    private final String code;&#10;    &#10;    AnsiFormat(String code) {&#10;        this.code = code;&#10;    }&#10;    &#10;    /**&#10;     * Gets the ANSI code for this formatting.&#10;     */&#10;    public String getCode() {&#10;        return code;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/ConsoleMasterDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/ConsoleMasterDemo.java" />
              <option name="originalContent" value="package com.consolemaster;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application to showcase the console framework capabilities.&#10; * Creates a sample application with multiple canvas elements.&#10; */&#10;public class ConsoleMasterDemo {&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(60, 20);&#10;&#10;            // Create a composite canvas for the main content&#10;            CompositeCanvas mainContent = new CompositeCanvas(0, 0,&#10;                                                             screen.getWidth(),&#10;                                                             screen.getHeight());&#10;&#10;            // Create header canvas&#10;            TextCanvas header = new TextCanvas(0, 0, screen.getWidth(), 3,&#10;                                             &quot;=== Console Master Framework Demo ===\nWelcome to the game console!&quot;,&#10;                                             true);&#10;            header.setBorderChar('=');&#10;&#10;            // Create game area canvas&#10;            TextCanvas gameArea = new TextCanvas(2, 4, screen.getWidth() - 20, 12,&#10;                                               &quot;Game Area\n\nThis is where your\ngame content would\nbe displayed.\n\nPress any key to\ncontinue...&quot;,&#10;                                               true);&#10;            gameArea.setBorderChar('#');&#10;&#10;            // Create info panel&#10;            TextCanvas infoPanel = new TextCanvas(screen.getWidth() - 18, 4, 18, 12,&#10;                                                &quot;Info Panel\n\nScore: 1000\nLevel: 5\nLives: 3\n\nStats:\nHP: 100\nMP: 50&quot;,&#10;                                                true);&#10;            infoPanel.setBorderChar('|');&#10;&#10;            // Create footer&#10;            TextCanvas footer = new TextCanvas(0, screen.getHeight() - 3, screen.getWidth(), 3,&#10;                                             &quot;Status: Ready | Controls: WASD to move, SPACE to action&quot;,&#10;                                             true);&#10;            footer.setBorderChar('-');&#10;&#10;            // Add all canvases to the main content&#10;            mainContent.addChild(header);&#10;            mainContent.addChild(gameArea);&#10;            mainContent.addChild(infoPanel);&#10;            mainContent.addChild(footer);&#10;&#10;            // Set the content canvas&#10;            screen.setContentCanvas(mainContent);&#10;&#10;            // Render the screen&#10;            screen.render();&#10;&#10;            // Keep the application running&#10;            System.out.println(&quot;\nDemo rendered! Check your console.&quot;);&#10;//            System.out.println(&quot;Press Enter to exit...&quot;);&#10;//            System.in.read();&#10;&#10;            // Clean up&#10;            screen.close();&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error running demo: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Demo application to showcase the console framework capabilities with ANSI colors and formatting.&#10; * Creates a sample application with multiple styled canvas elements.&#10; */&#10;public class ConsoleMasterDemo {&#10;    &#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(60, 20);&#10;            &#10;            // Create a composite canvas for the main content&#10;            CompositeCanvas mainContent = new CompositeCanvas(0, 0, &#10;                                                             screen.getWidth(), &#10;                                                             screen.getHeight());&#10;            &#10;            // Create styled header canvas&#10;            Canvas header = new Canvas(0, 0, screen.getWidth(), 3) {&#10;                @Override&#10;                public void paint(Graphics graphics) {&#10;                    // Set bold yellow text on blue background for title&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_YELLOW);&#10;                    graphics.setBackgroundColor(AnsiColor.BLUE);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    &#10;                    String title = &quot;=== Console Master Framework Demo ===&quot;;&#10;                    int centerX = getWidth() / 2 - title.length() / 2;&#10;                    graphics.fillRect(0, 0, getWidth(), 1, ' '); // Fill background&#10;                    graphics.drawString(centerX, 0, title);&#10;                    &#10;                    // Reset style and draw subtitle&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.CYAN);&#10;                    graphics.setFormats(AnsiFormat.ITALIC);&#10;                    String subtitle = &quot;Welcome to the colorful game console!&quot;;&#10;                    centerX = getWidth() / 2 - subtitle.length() / 2;&#10;                    graphics.drawString(centerX, 1, subtitle);&#10;                    &#10;                    // Draw border&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawHorizontalLine(0, getWidth() - 1, 2, '=');&#10;                }&#10;            };&#10;            &#10;            // Create colorful game area canvas&#10;            Canvas gameArea = new Canvas(2, 4, screen.getWidth() - 20, 12) {&#10;                @Override&#10;                public void paint(Graphics graphics) {&#10;                    // Draw border in green&#10;                    graphics.setForegroundColor(AnsiColor.GREEN);&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;                    &#10;                    // Game title in red bold&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_RED);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(2, 1, &quot;GAME AREA&quot;);&#10;                    &#10;                    // Game content with various colors&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(2, 3, &quot;This is where your&quot;);&#10;                    &#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_GREEN);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(2, 4, &quot;AWESOME GAME&quot;);&#10;                    &#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(2, 5, &quot;content would be displayed.&quot;);&#10;                    &#10;                    // Status indicators with colors&#10;                    graphics.setForegroundColor(AnsiColor.YELLOW);&#10;                    graphics.drawString(2, 7, &quot;Status: &quot;);&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_GREEN);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(10, 7, &quot;READY&quot;);&#10;                    &#10;                    // Instructions with underline&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.CYAN);&#10;                    graphics.setFormats(AnsiFormat.UNDERLINE);&#10;                    graphics.drawString(2, 9, &quot;Press any key to continue...&quot;);&#10;                }&#10;            };&#10;            &#10;            // Create colorful info panel&#10;            Canvas infoPanel = new Canvas(screen.getWidth() - 18, 4, 18, 12) {&#10;                @Override&#10;                public void paint(Graphics graphics) {&#10;                    // Border in magenta&#10;                    graphics.setForegroundColor(AnsiColor.MAGENTA);&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '|');&#10;                    &#10;                    // Panel title&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_MAGENTA);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(2, 1, &quot;INFO PANEL&quot;);&#10;                    &#10;                    // Score in bright yellow&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_YELLOW);&#10;                    graphics.drawString(2, 3, &quot;Score: &quot;);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(9, 3, &quot;1000&quot;);&#10;                    &#10;                    // Level in bright blue&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_BLUE);&#10;                    graphics.drawString(2, 4, &quot;Level: &quot;);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(9, 4, &quot;5&quot;);&#10;                    &#10;                    // Lives in bright red&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_RED);&#10;                    graphics.drawString(2, 5, &quot;Lives: &quot;);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(9, 5, &quot;3&quot;);&#10;                    &#10;                    // Stats section&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.setFormats(AnsiFormat.UNDERLINE);&#10;                    graphics.drawString(2, 7, &quot;Stats:&quot;);&#10;                    &#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.GREEN);&#10;                    graphics.drawString(2, 8, &quot;HP: 100&quot;);&#10;                    graphics.setForegroundColor(AnsiColor.BLUE);&#10;                    graphics.drawString(2, 9, &quot;MP: 50&quot;);&#10;                }&#10;            };&#10;            &#10;            // Create styled footer&#10;            Canvas footer = new Canvas(0, screen.getHeight() - 3, screen.getWidth(), 3) {&#10;                @Override&#10;                public void paint(Graphics graphics) {&#10;                    // Top border&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawHorizontalLine(0, getWidth() - 1, 0, '-');&#10;                    &#10;                    // Status message with mixed colors&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(1, 1, &quot;Status: &quot;);&#10;                    graphics.setForegroundColor(AnsiColor.BRIGHT_GREEN);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(9, 1, &quot;Ready&quot;);&#10;                    &#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(16, 1, &quot;| Controls: &quot;);&#10;                    graphics.setForegroundColor(AnsiColor.YELLOW);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(28, 1, &quot;WASD&quot;);&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(33, 1, &quot; to move, &quot;);&#10;                    graphics.setForegroundColor(AnsiColor.YELLOW);&#10;                    graphics.setFormats(AnsiFormat.BOLD);&#10;                    graphics.drawString(43, 1, &quot;SPACE&quot;);&#10;                    graphics.resetStyle();&#10;                    graphics.setForegroundColor(AnsiColor.WHITE);&#10;                    graphics.drawString(49, 1, &quot; to action&quot;);&#10;                }&#10;            };&#10;            &#10;            // Add all canvases to the main content&#10;            mainContent.addChild(header);&#10;            mainContent.addChild(gameArea);&#10;            mainContent.addChild(infoPanel);&#10;            mainContent.addChild(footer);&#10;            &#10;            // Set the content canvas&#10;            screen.setContentCanvas(mainContent);&#10;            &#10;            // Render the screen&#10;            screen.render();&#10;            &#10;            // Keep the application running&#10;            System.out.println(&quot;\nColorful demo rendered! Check your console for ANSI colors and formatting.&quot;);&#10;            System.out.println(&quot;Press Enter to exit...&quot;);&#10;            System.in.read();&#10;            &#10;            // Clean up&#10;            screen.close();&#10;            &#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error running demo: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/Graphics.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/Graphics.java" />
              <option name="originalContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;import lombok.RequiredArgsConstructor;&#10;&#10;/**&#10; * Graphics context for drawing operations on the console.&#10; * Provides methods to draw text and simple graphics elements.&#10; */&#10;@Getter&#10;@RequiredArgsConstructor&#10;public class Graphics {&#10;&#10;    private final char[][] buffer;&#10;    private final int width;&#10;    private final int height;&#10;&#10;    /**&#10;     * Draws a character at the specified position.&#10;     *&#10;     * @param x the x-coordinate&#10;     * @param y the y-coordinate&#10;     * @param c the character to draw&#10;     */&#10;    public void drawChar(int x, int y, char c) {&#10;        if (isValid(x, y)) {&#10;            buffer[y][x] = c;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a string starting at the specified position.&#10;     *&#10;     * @param x    the x-coordinate&#10;     * @param y    the y-coordinate&#10;     * @param text the text to draw&#10;     */&#10;    public void drawString(int x, int y, String text) {&#10;        if (text == null || y &lt; 0 || y &gt;= height) {&#10;            return;&#10;        }&#10;&#10;        for (int i = 0; i &lt; text.length() &amp;&amp; x + i &lt; width; i++) {&#10;            if (x + i &gt;= 0) {&#10;                buffer[y][x + i] = text.charAt(i);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a horizontal line.&#10;     *&#10;     * @param x1 the starting x-coordinate&#10;     * @param x2 the ending x-coordinate&#10;     * @param y  the y-coordinate&#10;     * @param c  the character to use for the line&#10;     */&#10;    public void drawHorizontalLine(int x1, int x2, int y, char c) {&#10;        if (y &lt; 0 || y &gt;= height) {&#10;            return;&#10;        }&#10;&#10;        int startX = Math.max(0, Math.min(x1, x2));&#10;        int endX = Math.min(width - 1, Math.max(x1, x2));&#10;&#10;        for (int x = startX; x &lt;= endX; x++) {&#10;            buffer[y][x] = c;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a vertical line.&#10;     *&#10;     * @param x  the x-coordinate&#10;     * @param y1 the starting y-coordinate&#10;     * @param y2 the ending y-coordinate&#10;     * @param c  the character to use for the line&#10;     */&#10;    public void drawVerticalLine(int x, int y1, int y2, char c) {&#10;        if (x &lt; 0 || x &gt;= width) {&#10;            return;&#10;        }&#10;&#10;        int startY = Math.max(0, Math.min(y1, y2));&#10;        int endY = Math.min(height - 1, Math.max(y1, y2));&#10;&#10;        for (int y = startY; y &lt;= endY; y++) {&#10;            buffer[y][x] = c;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a rectangle outline.&#10;     *&#10;     * @param x      the x-coordinate of the top-left corner&#10;     * @param y      the y-coordinate of the top-left corner&#10;     * @param width  the width of the rectangle&#10;     * @param height the height of the rectangle&#10;     * @param c      the character to use for the border&#10;     */&#10;    public void drawRect(int x, int y, int width, int height, char c) {&#10;        // Top and bottom borders&#10;        drawHorizontalLine(x, x + width - 1, y, c);&#10;        drawHorizontalLine(x, x + width - 1, y + height - 1, c);&#10;&#10;        // Left and right borders&#10;        drawVerticalLine(x, y, y + height - 1, c);&#10;        drawVerticalLine(x + width - 1, y, y + height - 1, c);&#10;    }&#10;&#10;    /**&#10;     * Fills a rectangular area with the specified character.&#10;     *&#10;     * @param x      the x-coordinate of the top-left corner&#10;     * @param y      the y-coordinate of the top-left corner&#10;     * @param width  the width of the rectangle&#10;     * @param height the height of the rectangle&#10;     * @param c      the character to fill with&#10;     */&#10;    public void fillRect(int x, int y, int width, int height, char c) {&#10;        for (int row = y; row &lt; y + height &amp;&amp; row &lt; this.height; row++) {&#10;            if (row &gt;= 0) {&#10;                for (int col = x; col &lt; x + width &amp;&amp; col &lt; this.width; col++) {&#10;                    if (col &gt;= 0) {&#10;                        buffer[row][col] = c;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clears the entire graphics buffer with spaces.&#10;     */&#10;    public void clear() {&#10;        fillRect(0, 0, width, height, ' ');&#10;    }&#10;&#10;    /**&#10;     * Checks if the given coordinates are valid within the buffer.&#10;     *&#10;     * @param x the x-coordinate&#10;     * @param y the y-coordinate&#10;     * @return true if coordinates are valid, false otherwise&#10;     */&#10;    private boolean isValid(int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;&#10;/**&#10; * Graphics context for drawing operations on the console.&#10; * Provides methods to draw text and simple graphics elements with ANSI styling support.&#10; */&#10;@Getter&#10;public class Graphics {&#10;&#10;    private final StyledChar[][] buffer;&#10;    private final int width;&#10;    private final int height;&#10;&#10;    // Current drawing style&#10;    private AnsiColor currentForegroundColor;&#10;    private AnsiColor currentBackgroundColor;&#10;    private AnsiFormat[] currentFormats = new AnsiFormat[0];&#10;&#10;    /**&#10;     * Creates a Graphics context with a plain character buffer.&#10;     */&#10;    public Graphics(char[][] charBuffer, int width, int height) {&#10;        this.width = width;&#10;        this.height = height;&#10;        this.buffer = new StyledChar[height][width];&#10;&#10;        // Convert char buffer to StyledChar buffer&#10;        for (int y = 0; y &lt; height; y++) {&#10;            for (int x = 0; x &lt; width; x++) {&#10;                this.buffer[y][x] = new StyledChar(charBuffer[y][x]);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Creates a Graphics context with a StyledChar buffer.&#10;     */&#10;    public Graphics(StyledChar[][] buffer, int width, int height) {&#10;        this.buffer = buffer;&#10;        this.width = width;&#10;        this.height = height;&#10;    }&#10;&#10;    /**&#10;     * Sets the foreground color for subsequent drawing operations.&#10;     */&#10;    public void setForegroundColor(AnsiColor color) {&#10;        this.currentForegroundColor = color;&#10;    }&#10;&#10;    /**&#10;     * Sets the background color for subsequent drawing operations.&#10;     */&#10;    public void setBackgroundColor(AnsiColor color) {&#10;        this.currentBackgroundColor = color;&#10;    }&#10;&#10;    /**&#10;     * Sets the text formatting for subsequent drawing operations.&#10;     */&#10;    public void setFormats(AnsiFormat... formats) {&#10;        this.currentFormats = formats != null ? formats : new AnsiFormat[0];&#10;    }&#10;&#10;    /**&#10;     * Resets all styling to default.&#10;     */&#10;    public void resetStyle() {&#10;        this.currentForegroundColor = null;&#10;        this.currentBackgroundColor = null;&#10;        this.currentFormats = new AnsiFormat[0];&#10;    }&#10;&#10;    /**&#10;     * Draws a styled character at the specified position.&#10;     */&#10;    public void drawStyledChar(int x, int y, StyledChar styledChar) {&#10;        if (isValid(x, y)) {&#10;            buffer[y][x] = styledChar;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a character at the specified position with current styling.&#10;     */&#10;    public void drawChar(int x, int y, char c) {&#10;        if (isValid(x, y)) {&#10;            buffer[y][x] = new StyledChar(c, currentForegroundColor, currentBackgroundColor, currentFormats);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a string starting at the specified position with current styling.&#10;     */&#10;    public void drawString(int x, int y, String text) {&#10;        if (text == null || y &lt; 0 || y &gt;= height) {&#10;            return;&#10;        }&#10;&#10;        for (int i = 0; i &lt; text.length() &amp;&amp; x + i &lt; width; i++) {&#10;            if (x + i &gt;= 0) {&#10;                buffer[y][x + i] = new StyledChar(text.charAt(i), currentForegroundColor, currentBackgroundColor, currentFormats);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a string with explicit styling.&#10;     */&#10;    public void drawStyledString(int x, int y, String text, AnsiColor foregroundColor, AnsiColor backgroundColor, AnsiFormat... formats) {&#10;        if (text == null || y &lt; 0 || y &gt;= height) {&#10;            return;&#10;        }&#10;&#10;        for (int i = 0; i &lt; text.length() &amp;&amp; x + i &lt; width; i++) {&#10;            if (x + i &gt;= 0) {&#10;                buffer[y][x + i] = new StyledChar(text.charAt(i), foregroundColor, backgroundColor, formats);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a horizontal line with current styling.&#10;     */&#10;    public void drawHorizontalLine(int x1, int x2, int y, char c) {&#10;        if (y &lt; 0 || y &gt;= height) {&#10;            return;&#10;        }&#10;&#10;        int startX = Math.max(0, Math.min(x1, x2));&#10;        int endX = Math.min(width - 1, Math.max(x1, x2));&#10;&#10;        for (int x = startX; x &lt;= endX; x++) {&#10;            buffer[y][x] = new StyledChar(c, currentForegroundColor, currentBackgroundColor, currentFormats);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a vertical line with current styling.&#10;     */&#10;    public void drawVerticalLine(int x, int y1, int y2, char c) {&#10;        if (x &lt; 0 || x &gt;= width) {&#10;            return;&#10;        }&#10;&#10;        int startY = Math.max(0, Math.min(y1, y2));&#10;        int endY = Math.min(height - 1, Math.max(y1, y2));&#10;&#10;        for (int y = startY; y &lt;= endY; y++) {&#10;            buffer[y][x] = new StyledChar(c, currentForegroundColor, currentBackgroundColor, currentFormats);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Draws a rectangle outline with current styling.&#10;     */&#10;    public void drawRect(int x, int y, int width, int height, char c) {&#10;        // Top and bottom borders&#10;        drawHorizontalLine(x, x + width - 1, y, c);&#10;        drawHorizontalLine(x, x + width - 1, y + height - 1, c);&#10;&#10;        // Left and right borders&#10;        drawVerticalLine(x, y, y + height - 1, c);&#10;        drawVerticalLine(x + width - 1, y, y + height - 1, c);&#10;    }&#10;&#10;    /**&#10;     * Fills a rectangular area with the specified character and current styling.&#10;     */&#10;    public void fillRect(int x, int y, int width, int height, char c) {&#10;        for (int row = y; row &lt; y + height &amp;&amp; row &lt; this.height; row++) {&#10;            if (row &gt;= 0) {&#10;                for (int col = x; col &lt; x + width &amp;&amp; col &lt; this.width; col++) {&#10;                    if (col &gt;= 0) {&#10;                        buffer[row][col] = new StyledChar(c, currentForegroundColor, currentBackgroundColor, currentFormats);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clears the entire graphics buffer with spaces.&#10;     */&#10;    public void clear() {&#10;        fillRect(0, 0, width, height, ' ');&#10;    }&#10;&#10;    /**&#10;     * Converts the buffer to a plain character array (without styling).&#10;     */&#10;    public char[][] toCharArray() {&#10;        char[][] result = new char[height][width];&#10;        for (int y = 0; y &lt; height; y++) {&#10;            for (int x = 0; x &lt; width; x++) {&#10;                result[y][x] = buffer[y][x].getCharacter();&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Converts the buffer to an ANSI-styled string representation.&#10;     */&#10;    public String toAnsiString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int y = 0; y &lt; height; y++) {&#10;            for (int x = 0; x &lt; width; x++) {&#10;                sb.append(buffer[y][x].toAnsiString());&#10;            }&#10;            if (y &lt; height - 1) {&#10;                sb.append('\n');&#10;            }&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    /**&#10;     * Checks if the given coordinates are valid within the buffer.&#10;     */&#10;    private boolean isValid(int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/ScreenCanvas.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/ScreenCanvas.java" />
              <option name="originalContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;import org.jline.terminal.Terminal;&#10;import org.jline.terminal.TerminalBuilder;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * The main entry point canvas for the console application.&#10; * Manages the console terminal and handles minimum size requirements.&#10; */&#10;@Getter&#10;@Setter&#10;public class ScreenCanvas extends CompositeCanvas {&#10;&#10;    private static final int DEFAULT_MIN_WIDTH = 80;&#10;    private static final int DEFAULT_MIN_HEIGHT = 24;&#10;&#10;    private final Terminal terminal;&#10;    private final int minWidth;&#10;    private final int minHeight;&#10;    private Canvas warningCanvas;&#10;    private Canvas contentCanvas;&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with default minimum size requirements.&#10;     */&#10;    public ScreenCanvas() throws IOException {&#10;        this(DEFAULT_MIN_WIDTH, DEFAULT_MIN_HEIGHT);&#10;    }&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with specified minimum size requirements.&#10;     */&#10;    public ScreenCanvas(int minWidth, int minHeight) throws IOException {&#10;        super(0, 0, 0, 0);&#10;        this.minWidth = minWidth;&#10;        this.minHeight = minHeight;&#10;        this.terminal = TerminalBuilder.builder().system(true).build();&#10;&#10;        // Initialize screen dimensions&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;&#10;        // Create warning canvas&#10;        createWarningCanvas();&#10;        updateDisplay();&#10;    }&#10;&#10;    public void setContentCanvas(Canvas contentCanvas) {&#10;        if (this.contentCanvas != null) {&#10;            removeChild(this.contentCanvas);&#10;        }&#10;        this.contentCanvas = contentCanvas;&#10;        updateDisplay();&#10;    }&#10;&#10;    public void updateSize() {&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;        updateDisplay();&#10;    }&#10;&#10;    public void render() {&#10;        char[][] buffer = new char[getHeight()][getWidth()];&#10;        Graphics graphics = new Graphics(buffer, getWidth(), getHeight());&#10;        graphics.clear();&#10;        paint(graphics);&#10;&#10;        terminal.writer().print(&quot;\033[2J\033[H&quot;);&#10;        for (int y = 0; y &lt; getHeight(); y++) {&#10;            for (int x = 0; x &lt; getWidth(); x++) {&#10;                terminal.writer().print(buffer[y][x]);&#10;            }&#10;            if (y &lt; getHeight() - 1) {&#10;                terminal.writer().println();&#10;            }&#10;        }&#10;        terminal.flush();&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        terminal.close();&#10;    }&#10;&#10;    public boolean meetsMinimumSize() {&#10;        return getWidth() &gt;= minWidth &amp;&amp; getHeight() &gt;= minHeight;&#10;    }&#10;&#10;    private void createWarningCanvas() {&#10;        warningCanvas = new Canvas(0, 0, getWidth(), getHeight()) {&#10;            @Override&#10;            public void paint(Graphics graphics) {&#10;                String message = &quot;Console too small!&quot;;&#10;                String requirement = String.format(&quot;Required: %dx%d&quot;, minWidth, minHeight);&#10;                String current = String.format(&quot;Current: %dx%d&quot;, getWidth(), getHeight());&#10;&#10;                if (getWidth() &gt; 10 &amp;&amp; getHeight() &gt; 5) {&#10;                    int centerX = getWidth() / 2;&#10;                    int centerY = getHeight() / 2;&#10;&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;                    graphics.drawString(Math.max(1, centerX - message.length() / 2), centerY - 1, message);&#10;                    graphics.drawString(Math.max(1, centerX - requirement.length() / 2), centerY, requirement);&#10;                    graphics.drawString(Math.max(1, centerX - current.length() / 2), centerY + 1, current);&#10;                } else {&#10;                    graphics.fillRect(0, 0, getWidth(), getHeight(), '!');&#10;                }&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateDisplay() {&#10;        removeAllChildren();&#10;&#10;        if (warningCanvas != null) {&#10;            warningCanvas.setWidth(getWidth());&#10;            warningCanvas.setHeight(getHeight());&#10;        }&#10;&#10;        if (meetsMinimumSize() &amp;&amp; contentCanvas != null) {&#10;            addChild(contentCanvas);&#10;        } else if (warningCanvas != null) {&#10;            addChild(warningCanvas);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;import org.jline.terminal.Terminal;&#10;import org.jline.terminal.TerminalBuilder;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * The main entry point canvas for the console application.&#10; * Manages the console terminal and handles minimum size requirements.&#10; */&#10;@Getter&#10;@Setter&#10;public class ScreenCanvas extends CompositeCanvas {&#10;&#10;    private static final int DEFAULT_MIN_WIDTH = 80;&#10;    private static final int DEFAULT_MIN_HEIGHT = 24;&#10;&#10;    private final Terminal terminal;&#10;    private final int minWidth;&#10;    private final int minHeight;&#10;    private Canvas warningCanvas;&#10;    private Canvas contentCanvas;&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with default minimum size requirements.&#10;     */&#10;    public ScreenCanvas() throws IOException {&#10;        this(DEFAULT_MIN_WIDTH, DEFAULT_MIN_HEIGHT);&#10;    }&#10;&#10;    /**&#10;     * Creates a new ScreenCanvas with specified minimum size requirements.&#10;     */&#10;    public ScreenCanvas(int minWidth, int minHeight) throws IOException {&#10;        super(0, 0, 0, 0);&#10;        this.minWidth = minWidth;&#10;        this.minHeight = minHeight;&#10;        this.terminal = TerminalBuilder.builder().system(true).build();&#10;&#10;        // Initialize screen dimensions&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;&#10;        // Create warning canvas&#10;        createWarningCanvas();&#10;        updateDisplay();&#10;    }&#10;&#10;    public void setContentCanvas(Canvas contentCanvas) {&#10;        if (this.contentCanvas != null) {&#10;            removeChild(this.contentCanvas);&#10;        }&#10;        this.contentCanvas = contentCanvas;&#10;        updateDisplay();&#10;    }&#10;&#10;    public void updateSize() {&#10;        setWidth(terminal.getWidth());&#10;        setHeight(terminal.getHeight());&#10;        updateDisplay();&#10;    }&#10;&#10;    public void render() {&#10;        StyledChar[][] buffer = new StyledChar[getHeight()][getWidth()];&#10;        Graphics graphics = new Graphics(buffer, getWidth(), getHeight());&#10;        graphics.clear();&#10;        paint(graphics);&#10;&#10;        // Output ANSI-styled content to terminal&#10;        terminal.writer().print(&quot;\033[2J\033[H&quot;);&#10;        terminal.writer().print(graphics.toAnsiString());&#10;        terminal.flush();&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        terminal.close();&#10;    }&#10;&#10;    public boolean meetsMinimumSize() {&#10;        return getWidth() &gt;= minWidth &amp;&amp; getHeight() &gt;= minHeight;&#10;    }&#10;&#10;    private void createWarningCanvas() {&#10;        warningCanvas = new Canvas(0, 0, getWidth(), getHeight()) {&#10;            @Override&#10;            public void paint(Graphics graphics) {&#10;                String message = &quot;Console too small!&quot;;&#10;                String requirement = String.format(&quot;Required: %dx%d&quot;, minWidth, minHeight);&#10;                String current = String.format(&quot;Current: %dx%d&quot;, getWidth(), getHeight());&#10;&#10;                if (getWidth() &gt; 10 &amp;&amp; getHeight() &gt; 5) {&#10;                    int centerX = getWidth() / 2;&#10;                    int centerY = getHeight() / 2;&#10;&#10;                    graphics.drawRect(0, 0, getWidth(), getHeight(), '#');&#10;                    graphics.drawString(Math.max(1, centerX - message.length() / 2), centerY - 1, message);&#10;                    graphics.drawString(Math.max(1, centerX - requirement.length() / 2), centerY, requirement);&#10;                    graphics.drawString(Math.max(1, centerX - current.length() / 2), centerY + 1, current);&#10;                } else {&#10;                    graphics.fillRect(0, 0, getWidth(), getHeight(), '!');&#10;                }&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateDisplay() {&#10;        removeAllChildren();&#10;&#10;        if (warningCanvas != null) {&#10;            warningCanvas.setWidth(getWidth());&#10;            warningCanvas.setHeight(getHeight());&#10;        }&#10;&#10;        if (meetsMinimumSize() &amp;&amp; contentCanvas != null) {&#10;            addChild(contentCanvas);&#10;        } else if (warningCanvas != null) {&#10;            addChild(warningCanvas);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/consolemaster/StyledChar.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/consolemaster/StyledChar.java" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;&#10;/**&#10; * Represents a styled character with color and formatting information.&#10; */&#10;@Data&#10;@AllArgsConstructor&#10;public class StyledChar {&#10;    private char character;&#10;    private AnsiColor foregroundColor;&#10;    private AnsiColor backgroundColor;&#10;    private AnsiFormat[] formats;&#10;    &#10;    /**&#10;     * Creates a styled character with only a foreground color.&#10;     */&#10;    public StyledChar(char character, AnsiColor foregroundColor) {&#10;        this(character, foregroundColor, null, new AnsiFormat[0]);&#10;    }&#10;    &#10;    /**&#10;     * Creates a plain character without styling.&#10;     */&#10;    public StyledChar(char character) {&#10;        this(character, null, null, new AnsiFormat[0]);&#10;    }&#10;    &#10;    /**&#10;     * Converts this styled character to its ANSI representation.&#10;     */&#10;    public String toAnsiString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        &#10;        // Add formatting codes&#10;        if (formats != null) {&#10;            for (AnsiFormat format : formats) {&#10;                sb.append(format.getCode());&#10;            }&#10;        }&#10;        &#10;        // Add color codes&#10;        if (foregroundColor != null) {&#10;            sb.append(foregroundColor.getForeground());&#10;        }&#10;        if (backgroundColor != null) {&#10;            sb.append(backgroundColor.getBackground());&#10;        }&#10;        &#10;        // Add the character&#10;        sb.append(character);&#10;        &#10;        // Reset if any styling was applied&#10;        if (hasAnyStyle()) {&#10;            sb.append(AnsiColor.RESET.getForeground());&#10;        }&#10;        &#10;        return sb.toString();&#10;    }&#10;    &#10;    /**&#10;     * Checks if this character has any styling applied.&#10;     */&#10;    public boolean hasAnyStyle() {&#10;        return foregroundColor != null || backgroundColor != null || &#10;               (formats != null &amp;&amp; formats.length &gt; 0);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>