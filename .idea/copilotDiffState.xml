<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/Graphic3DDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/demo/src/main/java/com/consolemaster/Graphic3DDemo.java" />
              <option name="originalContent" value="package com.consolemaster;&#10;&#10;import com.consolemaster.graphic3d.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive 3D graphics demo showcasing the Graphic3DCanvas capabilities.&#10; * Features animated 3D objects, camera controls, and different rendering modes.&#10; */&#10;@Slf4j&#10;public class Graphic3DDemo {&#10;&#10;    private static double animationTime = 0.0;&#10;    private static boolean isAnimating = true;&#10;    private static Graphic3DCanvas.RenderMode currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static Camera3D camera;&#10;    private static Graphic3DCanvas canvas3D;&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(100, 35);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 2,&#10;                    screen.getHeight() - 2,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 3, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0, &quot;3D Graphics Demo - Interactive 3D Scene&quot;, Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setChild(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create 3D canvas&#10;            canvas3D = new Graphic3DCanvas(&quot;3D Scene&quot;, 80, 25);&#10;            canvas3D.setRenderMode(currentRenderMode);&#10;            canvas3D.setWireframeChar('*');&#10;            canvas3D.setWireframeColor(AnsiColor.CYAN);&#10;            canvas3D.setFillChar('#');&#10;            canvas3D.setFillColor(AnsiColor.GREEN);&#10;            canvas3D.setBackfaceCulling(true);&#10;&#10;            // Setup camera&#10;            camera = canvas3D.getCamera();&#10;            camera.setPosition(new Point3D(0, 2, 8));&#10;            camera.lookAt(new Point3D(0, 0, 0));&#10;&#10;            // Create initial 3D scene&#10;            createInitialScene();&#10;&#10;            // Wrap 3D canvas in a box for better presentation&#10;            Box canvas3DBox = new Box(&quot;canvas3DBox&quot;, canvas3D.getWidth() + 2, canvas3D.getHeight() + 2, new DefaultBorder());&#10;            canvas3DBox.setChild(canvas3D);&#10;            canvas3DBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Create control panel&#10;            Composite controlPanel = new Composite(&quot;controlPanel&quot;, 0, 0, new FlowLayout(2, 1));&#10;&#10;            // Render mode buttons&#10;            Box wireframeBtn = createControlButton(&quot;Wireframe\n(W)&quot;, AnsiColor.CYAN, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Wireframe&quot;;&#10;            });&#10;            controlPanel.addChild(wireframeBtn);&#10;&#10;            Box filledBtn = createControlButton(&quot;Filled\n(F)&quot;, AnsiColor.GREEN, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.FILLED;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Filled&quot;;&#10;            });&#10;            controlPanel.addChild(filledBtn);&#10;&#10;            Box bothBtn = createControlButton(&quot;Both\n(B)&quot;, AnsiColor.YELLOW, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.BOTH;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Both&quot;;&#10;            });&#10;            controlPanel.addChild(bothBtn);&#10;&#10;            Box animateBtn = createControlButton(&quot;Animation\n(SPACE)&quot;, AnsiColor.MAGENTA, () -&gt; {&#10;                isAnimating = !isAnimating;&#10;                lastAction = isAnimating ? &quot;Animation Started&quot; : &quot;Animation Paused&quot;;&#10;            });&#10;            controlPanel.addChild(animateBtn);&#10;&#10;            controlPanel.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Create status footer&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 4, new DefaultBorder());&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.CENTER);&#10;            updateStatusText(statusText);&#10;            statusBox.setChild(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(canvas3DBox);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Set content&#10;            screen.setContent(mainContainer);&#10;&#10;            // Create process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setTargetFPS(30); // 30 FPS for smooth 3D animation&#10;&#10;            // Register keyboard controls&#10;            screen.registerShortcut(&quot;Ctrl+Q&quot;, () -&gt; {&#10;                try {&#10;                    processLoop.stop();&#10;                } catch (IOException e) {&#10;                    System.err.println(&quot;Error stopping process loop: &quot; + e.getMessage());&#10;                }&#10;            });&#10;&#10;            // 3D Controls&#10;            screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Wireframe Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;F&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.FILLED;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Filled Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.BOTH;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Both Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot; &quot;, () -&gt; {&#10;                isAnimating = !isAnimating;&#10;                lastAction = isAnimating ? &quot;Animation Started&quot; : &quot;Animation Paused&quot;;&#10;            });&#10;&#10;            // Camera controls&#10;            screen.registerShortcut(&quot;Up&quot;, () -&gt; {&#10;                camera.moveForward(0.5);&#10;                lastAction = &quot;Camera Forward&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Down&quot;, () -&gt; {&#10;                camera.moveForward(-0.5);&#10;                lastAction = &quot;Camera Backward&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Left&quot;, () -&gt; {&#10;                camera.moveRight(-0.5);&#10;                lastAction = &quot;Camera Left&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Right&quot;, () -&gt; {&#10;                camera.moveRight(0.5);&#10;                lastAction = &quot;Camera Right&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;PageUp&quot;, () -&gt; {&#10;                camera.moveUp(0.5);&#10;                lastAction = &quot;Camera Up&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;PageDown&quot;, () -&gt; {&#10;                camera.moveUp(-0.5);&#10;                lastAction = &quot;Camera Down&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;                // Reset camera position&#10;                camera.setPosition(new Point3D(0, 2, 8));&#10;                camera.lookAt(new Point3D(0, 0, 0));&#10;                lastAction = &quot;Camera Reset&quot;;&#10;            });&#10;&#10;            // Animation update callback&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                if (isAnimating) {&#10;                    animationTime += 0.03; // Animation speed&#10;                    updateAnimatedScene();&#10;                }&#10;                updateStatusText((Text) statusBox.getChild(), processLoop);&#10;            });&#10;&#10;            System.out.println(&quot;Starting 3D Graphics Demo...&quot;);&#10;            System.out.println(&quot;3D Controls:&quot;);&#10;            System.out.println(&quot;- W/F/B: Switch render modes (Wireframe/Filled/Both)&quot;);&#10;            System.out.println(&quot;- SPACE: Toggle animation&quot;);&#10;            System.out.println(&quot;- Arrow Keys: Move camera (Forward/Back/Left/Right)&quot;);&#10;            System.out.println(&quot;- Page Up/Down: Move camera (Up/Down)&quot;);&#10;            System.out.println(&quot;- R: Reset camera position&quot;);&#10;            System.out.println(&quot;- ESC or Ctrl+Q: Quit&quot;);&#10;&#10;            // Start the process loop (this will block until stopped)&#10;            processLoop.start();&#10;&#10;            System.out.println(&quot;3D Graphics Demo ended.&quot;);&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error running 3D Graphics demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Creates the initial 3D scene with various objects.&#10;     */&#10;    private static void createInitialScene() {&#10;        canvas3D.clearMeshes();&#10;&#10;        // Create a cube at the origin&#10;        Mesh3D cube = Mesh3D.createCube(2.0);&#10;        canvas3D.addMesh(cube);&#10;&#10;        // Create a pyramid to the right&#10;        Mesh3D pyramid = Mesh3D.createPyramid(1.5);&#10;        Matrix4x4 pyramidTransform = Matrix4x4.translation(4, 0, 0);&#10;        Mesh3D transformedPyramid = pyramid.transform(pyramidTransform);&#10;        canvas3D.addMesh(transformedPyramid);&#10;&#10;        // Create a rotated cube to the left&#10;        Mesh3D leftCube = Mesh3D.createCube(1.0);&#10;        Matrix4x4 rotation = Matrix4x4.rotationY(Math.PI / 4).multiply(Matrix4x4.rotationX(Math.PI / 6));&#10;        Matrix4x4 translation = Matrix4x4.translation(-4, 0, 0);&#10;        Matrix4x4 leftCubeTransform = translation.multiply(rotation);&#10;        Mesh3D transformedLeftCube = leftCube.transform(leftCubeTransform);&#10;        canvas3D.addMesh(transformedLeftCube);&#10;    }&#10;&#10;    /**&#10;     * Updates the animated 3D scene.&#10;     */&#10;    private static void updateAnimatedScene() {&#10;        canvas3D.clearMeshes();&#10;&#10;        // Rotating cube at center&#10;        Mesh3D cube = Mesh3D.createCube(2.0);&#10;        Matrix4x4 cubeRotation = Matrix4x4.rotationY(animationTime)&#10;                .multiply(Matrix4x4.rotationX(animationTime * 0.7));&#10;        Mesh3D animatedCube = cube.transform(cubeRotation);&#10;        canvas3D.addMesh(animatedCube);&#10;&#10;        // Orbiting pyramid&#10;        double orbitRadius = 4.0;&#10;        double orbitX = Math.cos(animationTime * 2) * orbitRadius;&#10;        double orbitZ = Math.sin(animationTime * 2) * orbitRadius;&#10;        double orbitY = Math.sin(animationTime * 3) * 1.5;&#10;&#10;        Mesh3D pyramid = Mesh3D.createPyramid(1.5);&#10;        Matrix4x4 pyramidRotation = Matrix4x4.rotationY(-animationTime * 2);&#10;        Matrix4x4 pyramidTranslation = Matrix4x4.translation(orbitX, orbitY, orbitZ);&#10;        Matrix4x4 pyramidTransform = pyramidTranslation.multiply(pyramidRotation);&#10;        Mesh3D orbitingPyramid = pyramid.transform(pyramidTransform);&#10;        canvas3D.addMesh(orbitingPyramid);&#10;&#10;        // Oscillating cube on the left&#10;        double leftX = -4 + Math.sin(animationTime * 1.5) * 1.5;&#10;        double leftY = Math.cos(animationTime * 2) * 2;&#10;&#10;        Mesh3D leftCube = Mesh3D.createCube(1.0);&#10;        Matrix4x4 leftRotation = Matrix4x4.rotationZ(animationTime * 1.2)&#10;                .multiply(Matrix4x4.rotationX(animationTime * 0.8));&#10;        Matrix4x4 leftTranslation = Matrix4x4.translation(leftX, leftY, 0);&#10;        Matrix4x4 leftTransform = leftTranslation.multiply(leftRotation);&#10;        Mesh3D animatedLeftCube = leftCube.transform(leftTransform);&#10;        canvas3D.addMesh(animatedLeftCube);&#10;    }&#10;&#10;    /**&#10;     * Creates a control button for the demo.&#10;     */&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Box button = new Box(&quot;btn:&quot; + text, 12, 3, new DefaultBorder()) {&#10;            @Override&#10;            protected void onFocusChanged(boolean focused) {&#10;                super.onFocusChanged(focused);&#10;                updateButtonStyle(this, focused, color);&#10;            }&#10;        };&#10;&#10;        Text buttonText = new Text(&quot;text:&quot; + text, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        button.setChild(buttonText);&#10;        button.setCanFocus(true);&#10;&#10;        return button;&#10;    }&#10;&#10;    /**&#10;     * Updates button visual style based on focus state.&#10;     */&#10;    private static void updateButtonStyle(Box box, boolean focused, AnsiColor baseColor) {&#10;        Text text = (Text) box.getChild();&#10;        if (text != null) {&#10;            if (focused) {&#10;                text.setBackgroundColor(baseColor);&#10;                text.setForegroundColor(AnsiColor.BRIGHT_WHITE);&#10;            } else {&#10;                text.setBackgroundColor(null);&#10;                text.setForegroundColor(baseColor);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the status text display.&#10;     */&#10;    private static void updateStatusText(Text statusText) {&#10;        updateStatusText(statusText, null);&#10;    }&#10;&#10;    /**&#10;     * Updates the status text with current demo information.&#10;     */&#10;    private static void updateStatusText(Text statusText, ProcessLoop processLoop) {&#10;        String status = &quot;3D Graphics Demo - Interactive Scene\n&quot;;&#10;        if (processLoop != null) {&#10;            status += String.format(&quot;FPS: %d | Mode: %s | Animation: %s\n&quot;,&#10;                    processLoop.getCurrentFPS(),&#10;                    currentRenderMode.toString(),&#10;                    isAnimating ? &quot;ON&quot; : &quot;OFF&quot;);&#10;        } else {&#10;            status += &quot;Initializing...\n&quot;;&#10;        }&#10;        status += String.format(&quot;Camera: (%.1f,%.1f,%.1f) | %s\n&quot;,&#10;                camera.getPosition().getX(),&#10;                camera.getPosition().getY(),&#10;                camera.getPosition().getZ(),&#10;                lastAction);&#10;        status += &quot;Controls: W/F/B=Mode, SPACE=Animate, Arrows=Move, R=Reset, ESC=Quit&quot;;&#10;&#10;        statusText.setText(status);&#10;        statusText.setForegroundColor(AnsiColor.BRIGHT_WHITE);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster;&#10;&#10;import com.consolemaster.graphic3d.*;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Interactive 3D graphics demo showcasing the Graphic3DCanvas capabilities.&#10; * Features animated 3D objects, camera controls, and different rendering modes.&#10; */&#10;@Slf4j&#10;public class Graphic3DDemo {&#10;&#10;    private static double animationTime = 0.0;&#10;    private static boolean isAnimating = true;&#10;    private static Graphic3DCanvas.RenderMode currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;    private static String lastAction = &quot;Demo Started&quot;;&#10;    private static Camera3D camera;&#10;    private static Graphic3DCanvas canvas3D;&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Create the main screen canvas&#10;            ScreenCanvas screen = new ScreenCanvas(100, 35);&#10;&#10;            // Create main container with BorderLayout&#10;            Composite mainContainer = new Composite(&quot;mainContainer&quot;,&#10;                    screen.getWidth() - 2,&#10;                    screen.getHeight() - 2,&#10;                    new BorderLayout(1));&#10;&#10;            // Create header&#10;            Box headerBox = new Box(&quot;headerBox&quot;, 0, 3, new DefaultBorder());&#10;            Text headerText = new Text(&quot;headerText&quot;, 0, 0, &quot;3D Graphics Demo - Interactive 3D Scene&quot;, Text.Alignment.CENTER);&#10;            headerText.setForegroundColor(AnsiColor.BRIGHT_CYAN);&#10;            headerText.setBold(true);&#10;            headerBox.setChild(headerText);&#10;            headerBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.TOP_CENTER));&#10;&#10;            // Create 3D canvas&#10;            canvas3D = new Graphic3DCanvas(&quot;3D Scene&quot;, 80, 25);&#10;            canvas3D.setRenderMode(currentRenderMode);&#10;            canvas3D.setWireframeChar('*');&#10;            canvas3D.setWireframeColor(AnsiColor.CYAN);&#10;            canvas3D.setFillChar('#');&#10;            canvas3D.setFillColor(AnsiColor.GREEN);&#10;            canvas3D.setBackfaceCulling(true);&#10;&#10;            // Setup camera&#10;            camera = canvas3D.getCamera();&#10;            camera.setPosition(new Point3D(0, 0, 8)); // Y=0 statt Y=2 fÃ¼r bessere Zentrierung&#10;            camera.lookAt(new Point3D(0, 0, 0));&#10;&#10;            // Create initial 3D scene&#10;            createInitialScene();&#10;&#10;            // Wrap 3D canvas in a box for better presentation&#10;            Box canvas3DBox = new Box(&quot;canvas3DBox&quot;, canvas3D.getWidth() + 2, canvas3D.getHeight() + 2, new DefaultBorder());&#10;            canvas3DBox.setChild(canvas3D);&#10;            canvas3DBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.CENTER));&#10;&#10;            // Create control panel&#10;            Composite controlPanel = new Composite(&quot;controlPanel&quot;, 0, 0, new FlowLayout(2, 1));&#10;&#10;            // Render mode buttons&#10;            Box wireframeBtn = createControlButton(&quot;Wireframe\n(W)&quot;, AnsiColor.CYAN, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Wireframe&quot;;&#10;            });&#10;            controlPanel.addChild(wireframeBtn);&#10;&#10;            Box filledBtn = createControlButton(&quot;Filled\n(F)&quot;, AnsiColor.GREEN, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.FILLED;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Filled&quot;;&#10;            });&#10;            controlPanel.addChild(filledBtn);&#10;&#10;            Box bothBtn = createControlButton(&quot;Both\n(B)&quot;, AnsiColor.YELLOW, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.BOTH;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Switched to Both&quot;;&#10;            });&#10;            controlPanel.addChild(bothBtn);&#10;&#10;            Box animateBtn = createControlButton(&quot;Animation\n(SPACE)&quot;, AnsiColor.MAGENTA, () -&gt; {&#10;                isAnimating = !isAnimating;&#10;                lastAction = isAnimating ? &quot;Animation Started&quot; : &quot;Animation Paused&quot;;&#10;            });&#10;            controlPanel.addChild(animateBtn);&#10;&#10;            controlPanel.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Create status footer&#10;            Box statusBox = new Box(&quot;statusBox&quot;, 0, 4, new DefaultBorder());&#10;            Text statusText = new Text(&quot;statusText&quot;, 0, 0, &quot;&quot;, Text.Alignment.CENTER);&#10;            updateStatusText(statusText);&#10;            statusBox.setChild(statusText);&#10;            statusBox.setLayoutConstraint(new PositionConstraint(PositionConstraint.Position.BOTTOM_CENTER));&#10;&#10;            // Add components to main container&#10;            mainContainer.addChild(headerBox);&#10;            mainContainer.addChild(canvas3DBox);&#10;            mainContainer.addChild(statusBox);&#10;&#10;            // Set content&#10;            screen.setContent(mainContainer);&#10;&#10;            // Create process loop&#10;            ProcessLoop processLoop = new ProcessLoop(screen);&#10;            processLoop.setTargetFPS(30); // 30 FPS for smooth 3D animation&#10;&#10;            // Register keyboard controls&#10;            screen.registerShortcut(&quot;Ctrl+Q&quot;, () -&gt; {&#10;                try {&#10;                    processLoop.stop();&#10;                } catch (IOException e) {&#10;                    System.err.println(&quot;Error stopping process loop: &quot; + e.getMessage());&#10;                }&#10;            });&#10;&#10;            // 3D Controls&#10;            screen.registerShortcut(&quot;W&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.WIREFRAME;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Wireframe Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;F&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.FILLED;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Filled Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;B&quot;, () -&gt; {&#10;                currentRenderMode = Graphic3DCanvas.RenderMode.BOTH;&#10;                canvas3D.setRenderMode(currentRenderMode);&#10;                lastAction = &quot;Both Mode&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot; &quot;, () -&gt; {&#10;                isAnimating = !isAnimating;&#10;                lastAction = isAnimating ? &quot;Animation Started&quot; : &quot;Animation Paused&quot;;&#10;            });&#10;&#10;            // Camera controls&#10;            screen.registerShortcut(&quot;Up&quot;, () -&gt; {&#10;                camera.moveForward(0.5);&#10;                lastAction = &quot;Camera Forward&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Down&quot;, () -&gt; {&#10;                camera.moveForward(-0.5);&#10;                lastAction = &quot;Camera Backward&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Left&quot;, () -&gt; {&#10;                camera.moveRight(-0.5);&#10;                lastAction = &quot;Camera Left&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;Right&quot;, () -&gt; {&#10;                camera.moveRight(0.5);&#10;                lastAction = &quot;Camera Right&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;PageUp&quot;, () -&gt; {&#10;                camera.moveUp(0.5);&#10;                lastAction = &quot;Camera Up&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;PageDown&quot;, () -&gt; {&#10;                camera.moveUp(-0.5);&#10;                lastAction = &quot;Camera Down&quot;;&#10;            });&#10;&#10;            screen.registerShortcut(&quot;R&quot;, () -&gt; {&#10;                // Reset camera position&#10;                camera.setPosition(new Point3D(0, 0, 8));&#10;                camera.lookAt(new Point3D(0, 0, 0));&#10;                lastAction = &quot;Camera Reset&quot;;&#10;            });&#10;&#10;            // Animation update callback&#10;            processLoop.setUpdateCallback(() -&gt; {&#10;                if (isAnimating) {&#10;                    animationTime += 0.03; // Animation speed&#10;                    updateAnimatedScene();&#10;                }&#10;                updateStatusText((Text) statusBox.getChild(), processLoop);&#10;            });&#10;&#10;            System.out.println(&quot;Starting 3D Graphics Demo...&quot;);&#10;            System.out.println(&quot;3D Controls:&quot;);&#10;            System.out.println(&quot;- W/F/B: Switch render modes (Wireframe/Filled/Both)&quot;);&#10;            System.out.println(&quot;- SPACE: Toggle animation&quot;);&#10;            System.out.println(&quot;- Arrow Keys: Move camera (Forward/Back/Left/Right)&quot;);&#10;            System.out.println(&quot;- Page Up/Down: Move camera (Up/Down)&quot;);&#10;            System.out.println(&quot;- R: Reset camera position&quot;);&#10;            System.out.println(&quot;- ESC or Ctrl+Q: Quit&quot;);&#10;&#10;            // Start the process loop (this will block until stopped)&#10;            processLoop.start();&#10;&#10;            System.out.println(&quot;3D Graphics Demo ended.&quot;);&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error running 3D Graphics demo&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Creates the initial 3D scene with various objects.&#10;     */&#10;    private static void createInitialScene() {&#10;        canvas3D.clearMeshes();&#10;&#10;        // Create a cube at the origin&#10;        Mesh3D cube = Mesh3D.createCube(2.0);&#10;        canvas3D.addMesh(cube);&#10;&#10;        // Create a pyramid to the right&#10;        Mesh3D pyramid = Mesh3D.createPyramid(1.5);&#10;        Matrix4x4 pyramidTransform = Matrix4x4.translation(4, 0, 0);&#10;        Mesh3D transformedPyramid = pyramid.transform(pyramidTransform);&#10;        canvas3D.addMesh(transformedPyramid);&#10;&#10;        // Create a rotated cube to the left&#10;        Mesh3D leftCube = Mesh3D.createCube(1.0);&#10;        Matrix4x4 rotation = Matrix4x4.rotationY(Math.PI / 4).multiply(Matrix4x4.rotationX(Math.PI / 6));&#10;        Matrix4x4 translation = Matrix4x4.translation(-4, 0, 0);&#10;        Matrix4x4 leftCubeTransform = translation.multiply(rotation);&#10;        Mesh3D transformedLeftCube = leftCube.transform(leftCubeTransform);&#10;        canvas3D.addMesh(transformedLeftCube);&#10;    }&#10;&#10;    /**&#10;     * Updates the animated 3D scene.&#10;     */&#10;    private static void updateAnimatedScene() {&#10;        canvas3D.clearMeshes();&#10;&#10;        // Rotating cube at center&#10;        Mesh3D cube = Mesh3D.createCube(2.0);&#10;        Matrix4x4 cubeRotation = Matrix4x4.rotationY(animationTime)&#10;                .multiply(Matrix4x4.rotationX(animationTime * 0.7));&#10;        Mesh3D animatedCube = cube.transform(cubeRotation);&#10;        canvas3D.addMesh(animatedCube);&#10;&#10;        // Orbiting pyramid&#10;        double orbitRadius = 4.0;&#10;        double orbitX = Math.cos(animationTime * 2) * orbitRadius;&#10;        double orbitZ = Math.sin(animationTime * 2) * orbitRadius;&#10;        double orbitY = Math.sin(animationTime * 3) * 1.5;&#10;&#10;        Mesh3D pyramid = Mesh3D.createPyramid(1.5);&#10;        Matrix4x4 pyramidRotation = Matrix4x4.rotationY(-animationTime * 2);&#10;        Matrix4x4 pyramidTranslation = Matrix4x4.translation(orbitX, orbitY, orbitZ);&#10;        Matrix4x4 pyramidTransform = pyramidTranslation.multiply(pyramidRotation);&#10;        Mesh3D orbitingPyramid = pyramid.transform(pyramidTransform);&#10;        canvas3D.addMesh(orbitingPyramid);&#10;&#10;        // Oscillating cube on the left&#10;        double leftX = -4 + Math.sin(animationTime * 1.5) * 1.5;&#10;        double leftY = Math.cos(animationTime * 2) * 2;&#10;&#10;        Mesh3D leftCube = Mesh3D.createCube(1.0);&#10;        Matrix4x4 leftRotation = Matrix4x4.rotationZ(animationTime * 1.2)&#10;                .multiply(Matrix4x4.rotationX(animationTime * 0.8));&#10;        Matrix4x4 leftTranslation = Matrix4x4.translation(leftX, leftY, 0);&#10;        Matrix4x4 leftTransform = leftTranslation.multiply(leftRotation);&#10;        Mesh3D animatedLeftCube = leftCube.transform(leftTransform);&#10;        canvas3D.addMesh(animatedLeftCube);&#10;    }&#10;&#10;    /**&#10;     * Creates a control button for the demo.&#10;     */&#10;    private static Box createControlButton(String text, AnsiColor color, Runnable action) {&#10;        Box button = new Box(&quot;btn:&quot; + text, 12, 3, new DefaultBorder()) {&#10;            @Override&#10;            protected void onFocusChanged(boolean focused) {&#10;                super.onFocusChanged(focused);&#10;                updateButtonStyle(this, focused, color);&#10;            }&#10;        };&#10;&#10;        Text buttonText = new Text(&quot;text:&quot; + text, 0, 0, text, Text.Alignment.CENTER);&#10;        buttonText.setForegroundColor(color);&#10;        button.setChild(buttonText);&#10;        button.setCanFocus(true);&#10;&#10;        return button;&#10;    }&#10;&#10;    /**&#10;     * Updates button visual style based on focus state.&#10;     */&#10;    private static void updateButtonStyle(Box box, boolean focused, AnsiColor baseColor) {&#10;        Text text = (Text) box.getChild();&#10;        if (text != null) {&#10;            if (focused) {&#10;                text.setBackgroundColor(baseColor);&#10;                text.setForegroundColor(AnsiColor.BRIGHT_WHITE);&#10;            } else {&#10;                text.setBackgroundColor(null);&#10;                text.setForegroundColor(baseColor);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the status text display.&#10;     */&#10;    private static void updateStatusText(Text statusText) {&#10;        updateStatusText(statusText, null);&#10;    }&#10;&#10;    /**&#10;     * Updates the status text with current demo information.&#10;     */&#10;    private static void updateStatusText(Text statusText, ProcessLoop processLoop) {&#10;        String status = &quot;3D Graphics Demo - Interactive Scene\n&quot;;&#10;        if (processLoop != null) {&#10;            status += String.format(&quot;FPS: %d | Mode: %s | Animation: %s\n&quot;,&#10;                    processLoop.getCurrentFPS(),&#10;                    currentRenderMode.toString(),&#10;                    isAnimating ? &quot;ON&quot; : &quot;OFF&quot;);&#10;        } else {&#10;            status += &quot;Initializing...\n&quot;;&#10;        }&#10;        status += String.format(&quot;Camera: (%.1f,%.1f,%.1f) | %s\n&quot;,&#10;                camera.getPosition().getX(),&#10;                camera.getPosition().getY(),&#10;                camera.getPosition().getZ(),&#10;                lastAction);&#10;        status += &quot;Controls: W/F/B=Mode, SPACE=Animate, Arrows=Move, R=Reset, ESC=Quit&quot;;&#10;&#10;        statusText.setText(status);&#10;        statusText.setForegroundColor(AnsiColor.BRIGHT_WHITE);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/graphic3d/src/main/java/com/consolemaster/graphic3d/Graphic3DCanvas.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/graphic3d/src/main/java/com/consolemaster/graphic3d/Graphic3DCanvas.java" />
              <option name="originalContent" value="package com.consolemaster.graphic3d;&#10;&#10;import com.consolemaster.Canvas;&#10;import com.consolemaster.Graphics;&#10;import com.consolemaster.AnsiColor;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * A Canvas that can render 3D content using ASCII characters.&#10; * Supports wireframe and filled rendering modes.&#10; */&#10;@Getter&#10;@Setter&#10;public class Graphic3DCanvas extends Canvas {&#10;&#10;    private Camera3D camera;&#10;    private List&lt;Mesh3D&gt; meshes;&#10;    private RenderMode renderMode;&#10;    private char wireframeChar;&#10;    private char fillChar;&#10;    private AnsiColor wireframeColor;&#10;    private AnsiColor fillColor;&#10;    private boolean backfaceCulling;&#10;    private double[][] depthBuffer;&#10;&#10;    /**&#10;     * Rendering modes for 3D objects.&#10;     */&#10;    public enum RenderMode {&#10;        WIREFRAME,  // Only draw edges&#10;        FILLED,     // Fill triangles with characters&#10;        BOTH        // Draw both wireframe and fill&#10;    }&#10;&#10;    public Graphic3DCanvas(String name, int width, int height) {&#10;        super(name, width, height);&#10;        this.camera = new Camera3D();&#10;        this.meshes = new ArrayList&lt;&gt;();&#10;        this.renderMode = RenderMode.WIREFRAME;&#10;        this.wireframeChar = '*';&#10;        this.fillChar = '#';&#10;        this.wireframeColor = AnsiColor.WHITE;&#10;        this.fillColor = AnsiColor.CYAN;&#10;        this.backfaceCulling = true;&#10;        this.depthBuffer = new double[height][width];&#10;    }&#10;&#10;    /**&#10;     * Adds a mesh to the 3D scene.&#10;     */&#10;    public void addMesh(Mesh3D mesh) {&#10;        meshes.add(mesh);&#10;        requestRedraw();&#10;    }&#10;&#10;    /**&#10;     * Removes a mesh from the 3D scene.&#10;     */&#10;    public void removeMesh(Mesh3D mesh) {&#10;        meshes.remove(mesh);&#10;        requestRedraw();&#10;    }&#10;&#10;    /**&#10;     * Clears all meshes from the scene.&#10;     */&#10;    public void clearMeshes() {&#10;        meshes.clear();&#10;        requestRedraw();&#10;    }&#10;&#10;    @Override&#10;    public void paint(Graphics graphics) {&#10;        // Clear the canvas&#10;        graphics.clear();&#10;&#10;        // Initialize depth buffer&#10;        clearDepthBuffer();&#10;&#10;        // Calculate aspect ratio&#10;        double aspectRatio = (double) getWidth() / getHeight();&#10;&#10;        // Get view-projection matrix&#10;        Matrix4x4 viewProjection = camera.getViewProjectionMatrix(aspectRatio);&#10;&#10;        // Render each mesh&#10;        for (Mesh3D mesh : meshes) {&#10;            renderMesh(graphics, mesh, viewProjection);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Renders a single mesh to the graphics context.&#10;     */&#10;    private void renderMesh(Graphics graphics, Mesh3D mesh, Matrix4x4 viewProjection) {&#10;        List&lt;Point3D&gt; projectedVertices = new ArrayList&lt;&gt;();&#10;&#10;        // Project all vertices to screen space&#10;        for (Point3D vertex : mesh.getVertices()) {&#10;            Point3D projected = viewProjection.transform(vertex);&#10;&#10;            // Convert from normalized device coordinates to screen coordinates&#10;            // Center the projection in the canvas&#10;            double centerX = getWidth() / 2.0;&#10;            double centerY = getHeight() / 2.0;&#10;            &#10;            // Scale to fit canvas while maintaining aspect ratio&#10;            double scale = Math.min(getWidth(), getHeight()) / 2.0;&#10;&#10;            double screenX = centerX + projected.getX() * scale;&#10;            double screenY = centerY - projected.getY() * scale; // Flip Y for screen coordinates&#10;&#10;            projectedVertices.add(new Point3D(screenX, screenY, projected.getZ()));&#10;        }&#10;&#10;        // Render faces&#10;        for (Mesh3D.Face3D face : mesh.getFaces()) {&#10;            Point3D v1 = projectedVertices.get(face.getV1());&#10;            Point3D v2 = projectedVertices.get(face.getV2());&#10;            Point3D v3 = projectedVertices.get(face.getV3());&#10;&#10;            // Backface culling&#10;            if (backfaceCulling &amp;&amp; isBackface(v1, v2, v3)) {&#10;                continue;&#10;            }&#10;&#10;            // Check if triangle is within screen bounds&#10;            if (!isTriangleVisible(v1, v2, v3)) {&#10;                continue;&#10;            }&#10;&#10;            // Render based on mode&#10;            switch (renderMode) {&#10;                case WIREFRAME:&#10;                    drawWireframeTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;                case FILLED:&#10;                    fillTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;                case BOTH:&#10;                    fillTriangle(graphics, v1, v2, v3);&#10;                    drawWireframeTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a triangle is facing away from the camera (backface).&#10;     */&#10;    private boolean isBackface(Point3D v1, Point3D v2, Point3D v3) {&#10;        // Calculate cross product of two edges&#10;        double edge1X = v2.getX() - v1.getX();&#10;        double edge1Y = v2.getY() - v1.getY();&#10;        double edge2X = v3.getX() - v1.getX();&#10;        double edge2Y = v3.getY() - v1.getY();&#10;&#10;        double crossProduct = edge1X * edge2Y - edge1Y * edge2X;&#10;        return crossProduct &lt; 0; // Clockwise = backface&#10;    }&#10;&#10;    /**&#10;     * Checks if any part of the triangle is visible on screen.&#10;     */&#10;    private boolean isTriangleVisible(Point3D v1, Point3D v2, Point3D v3) {&#10;        // Simple bounds check&#10;        double minX = Math.min(Math.min(v1.getX(), v2.getX()), v3.getX());&#10;        double maxX = Math.max(Math.max(v1.getX(), v2.getX()), v3.getX());&#10;        double minY = Math.min(Math.min(v1.getY(), v2.getY()), v3.getY());&#10;        double maxY = Math.max(Math.max(v1.getY(), v2.getY()), v3.getY());&#10;&#10;        return maxX &gt;= 0 &amp;&amp; minX &lt; getWidth() &amp;&amp; maxY &gt;= 0 &amp;&amp; minY &lt; getHeight();&#10;    }&#10;&#10;    /**&#10;     * Draws the wireframe of a triangle.&#10;     */&#10;    private void drawWireframeTriangle(Graphics graphics, Point3D v1, Point3D v2, Point3D v3) {&#10;        graphics.setForegroundColor(wireframeColor);&#10;        drawLine(graphics, v1, v2, wireframeChar);&#10;        drawLine(graphics, v2, v3, wireframeChar);&#10;        drawLine(graphics, v3, v1, wireframeChar);&#10;    }&#10;&#10;    /**&#10;     * Fills a triangle with the fill character.&#10;     */&#10;    private void fillTriangle(Graphics graphics, Point3D v1, Point3D v2, Point3D v3) {&#10;        graphics.setForegroundColor(fillColor);&#10;&#10;        // Simple triangle filling using scanline algorithm&#10;        int minY = (int) Math.max(0, Math.min(Math.min(v1.getY(), v2.getY()), v3.getY()));&#10;        int maxY = (int) Math.min(getHeight() - 1, Math.max(Math.max(v1.getY(), v2.getY()), v3.getY()));&#10;&#10;        for (int y = minY; y &lt;= maxY; y++) {&#10;            List&lt;Double&gt; intersections = new ArrayList&lt;&gt;();&#10;&#10;            // Find intersections with triangle edges&#10;            addLineIntersection(intersections, v1, v2, y);&#10;            addLineIntersection(intersections, v2, v3, y);&#10;            addLineIntersection(intersections, v3, v1, y);&#10;&#10;            if (intersections.size() &gt;= 2) {&#10;                intersections.sort(Double::compareTo);&#10;                int startX = (int) Math.max(0, intersections.get(0));&#10;                int endX = (int) Math.min(getWidth() - 1, intersections.get(intersections.size() - 1));&#10;&#10;                for (int x = startX; x &lt;= endX; x++) {&#10;                    // Calculate depth for this pixel&#10;                    double depth = interpolateDepth(v1, v2, v3, x, y);&#10;&#10;                    // Depth test&#10;                    if (depth &lt; depthBuffer[y][x]) {&#10;                        depthBuffer[y][x] = depth;&#10;                        graphics.drawChar(x, y, fillChar);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Adds line intersection with horizontal scanline if it exists.&#10;     */&#10;    private void addLineIntersection(List&lt;Double&gt; intersections, Point3D p1, Point3D p2, int y) {&#10;        if ((p1.getY() &lt;= y &amp;&amp; p2.getY() &gt; y) || (p2.getY() &lt;= y &amp;&amp; p1.getY() &gt; y)) {&#10;            double t = (y - p1.getY()) / (p2.getY() - p1.getY());&#10;            double x = p1.getX() + t * (p2.getX() - p1.getX());&#10;            intersections.add(x);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interpolates depth value at given pixel coordinates within triangle.&#10;     */&#10;    private double interpolateDepth(Point3D v1, Point3D v2, Point3D v3, int x, int y) {&#10;        // Barycentric coordinates for depth interpolation&#10;        double denom = (v2.getY() - v3.getY()) * (v1.getX() - v3.getX()) + (v3.getX() - v2.getX()) * (v1.getY() - v3.getY());&#10;        if (Math.abs(denom) &lt; 1e-10) return v1.getZ();&#10;&#10;        double a = ((v2.getY() - v3.getY()) * (x - v3.getX()) + (v3.getX() - v2.getX()) * (y - v3.getY())) / denom;&#10;        double b = ((v3.getY() - v1.getY()) * (x - v3.getX()) + (v1.getX() - v3.getX()) * (y - v3.getY())) / denom;&#10;        double c = 1 - a - b;&#10;&#10;        return a * v1.getZ() + b * v2.getZ() + c * v3.getZ();&#10;    }&#10;&#10;    /**&#10;     * Draws a line between two points using Bresenham's algorithm.&#10;     */&#10;    private void drawLine(Graphics graphics, Point3D p1, Point3D p2, char character) {&#10;        int x1 = (int) p1.getX();&#10;        int y1 = (int) p1.getY();&#10;        int x2 = (int) p2.getX();&#10;        int y2 = (int) p2.getY();&#10;&#10;        int dx = Math.abs(x2 - x1);&#10;        int dy = Math.abs(y2 - y1);&#10;        int sx = x1 &lt; x2 ? 1 : -1;&#10;        int sy = y1 &lt; y2 ? 1 : -1;&#10;        int err = dx - dy;&#10;&#10;        int x = x1;&#10;        int y = y1;&#10;&#10;        while (true) {&#10;            if (x &gt;= 0 &amp;&amp; x &lt; getWidth() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; getHeight()) {&#10;                graphics.drawChar(x, y, character);&#10;            }&#10;&#10;            if (x == x2 &amp;&amp; y == y2) break;&#10;&#10;            int e2 = 2 * err;&#10;            if (e2 &gt; -dy) {&#10;                err -= dy;&#10;                x += sx;&#10;            }&#10;            if (e2 &lt; dx) {&#10;                err += dx;&#10;                y += sy;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clears the depth buffer.&#10;     */&#10;    private void clearDepthBuffer() {&#10;        if (depthBuffer == null || depthBuffer.length != getHeight() || depthBuffer[0].length != getWidth()) {&#10;            depthBuffer = new double[getHeight()][getWidth()];&#10;        }&#10;        for (int y = 0; y &lt; getHeight(); y++) {&#10;            for (int x = 0; x &lt; getWidth(); x++) {&#10;                depthBuffer[y][x] = Double.MAX_VALUE;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Requests a redraw of the canvas.&#10;     */&#10;    private void requestRedraw() {&#10;        // This would typically trigger a repaint in the framework&#10;        // Implementation depends on the framework's redraw mechanism&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.consolemaster.graphic3d;&#10;&#10;import com.consolemaster.Canvas;&#10;import com.consolemaster.Graphics;&#10;import com.consolemaster.AnsiColor;&#10;import lombok.Getter;&#10;import lombok.Setter;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * A Canvas that can render 3D content using ASCII characters.&#10; * Supports wireframe and filled rendering modes.&#10; */&#10;@Getter&#10;@Setter&#10;public class Graphic3DCanvas extends Canvas {&#10;&#10;    private Camera3D camera;&#10;    private List&lt;Mesh3D&gt; meshes;&#10;    private RenderMode renderMode;&#10;    private char wireframeChar;&#10;    private char fillChar;&#10;    private AnsiColor wireframeColor;&#10;    private AnsiColor fillColor;&#10;    private boolean backfaceCulling;&#10;    private double[][] depthBuffer;&#10;&#10;    /**&#10;     * Rendering modes for 3D objects.&#10;     */&#10;    public enum RenderMode {&#10;        WIREFRAME,  // Only draw edges&#10;        FILLED,     // Fill triangles with characters&#10;        BOTH        // Draw both wireframe and fill&#10;    }&#10;&#10;    public Graphic3DCanvas(String name, int width, int height) {&#10;        super(name, width, height);&#10;        this.camera = new Camera3D();&#10;        this.meshes = new ArrayList&lt;&gt;();&#10;        this.renderMode = RenderMode.WIREFRAME;&#10;        this.wireframeChar = '*';&#10;        this.fillChar = '#';&#10;        this.wireframeColor = AnsiColor.WHITE;&#10;        this.fillColor = AnsiColor.CYAN;&#10;        this.backfaceCulling = true;&#10;        this.depthBuffer = new double[height][width];&#10;    }&#10;&#10;    /**&#10;     * Adds a mesh to the 3D scene.&#10;     */&#10;    public void addMesh(Mesh3D mesh) {&#10;        meshes.add(mesh);&#10;        requestRedraw();&#10;    }&#10;&#10;    /**&#10;     * Removes a mesh from the 3D scene.&#10;     */&#10;    public void removeMesh(Mesh3D mesh) {&#10;        meshes.remove(mesh);&#10;        requestRedraw();&#10;    }&#10;&#10;    /**&#10;     * Clears all meshes from the scene.&#10;     */&#10;    public void clearMeshes() {&#10;        meshes.clear();&#10;        requestRedraw();&#10;    }&#10;&#10;    @Override&#10;    public void paint(Graphics graphics) {&#10;        // Clear the canvas&#10;        graphics.clear();&#10;&#10;        // Initialize depth buffer&#10;        clearDepthBuffer();&#10;&#10;        // Calculate aspect ratio&#10;        double aspectRatio = (double) getWidth() / getHeight();&#10;&#10;        // Get view-projection matrix&#10;        Matrix4x4 viewProjection = camera.getViewProjectionMatrix(aspectRatio);&#10;&#10;        // Render each mesh&#10;        for (Mesh3D mesh : meshes) {&#10;            renderMesh(graphics, mesh, viewProjection);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Renders a single mesh to the graphics context.&#10;     */&#10;    private void renderMesh(Graphics graphics, Mesh3D mesh, Matrix4x4 viewProjection) {&#10;        List&lt;Point3D&gt; projectedVertices = new ArrayList&lt;&gt;();&#10;&#10;        // Project all vertices to screen space&#10;        for (Point3D vertex : mesh.getVertices()) {&#10;            Point3D projected = viewProjection.transform(vertex);&#10;&#10;            // Convert from normalized device coordinates to screen coordinates&#10;            // Center the projection in the canvas&#10;            double centerX = getWidth() / 2.0;&#10;            double centerY = getHeight() / 2.0;&#10;            &#10;            // Scale to fit canvas while maintaining aspect ratio&#10;            double scale = Math.min(getWidth(), getHeight()) / 2.0;&#10;&#10;            double screenX = centerX + projected.getX() * scale;&#10;            double screenY = centerY - projected.getY() * scale; // Flip Y for screen coordinates&#10;&#10;            projectedVertices.add(new Point3D(screenX, screenY, projected.getZ()));&#10;        }&#10;&#10;        // Render faces&#10;        for (Mesh3D.Face3D face : mesh.getFaces()) {&#10;            Point3D v1 = projectedVertices.get(face.getV1());&#10;            Point3D v2 = projectedVertices.get(face.getV2());&#10;            Point3D v3 = projectedVertices.get(face.getV3());&#10;&#10;            // Backface culling&#10;            if (backfaceCulling &amp;&amp; isBackface(v1, v2, v3)) {&#10;                continue;&#10;            }&#10;&#10;            // Check if triangle is within screen bounds&#10;            if (!isTriangleVisible(v1, v2, v3)) {&#10;                continue;&#10;            }&#10;&#10;            // Render based on mode&#10;            switch (renderMode) {&#10;                case WIREFRAME:&#10;                    drawWireframeTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;                case FILLED:&#10;                    fillTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;                case BOTH:&#10;                    fillTriangle(graphics, v1, v2, v3);&#10;                    drawWireframeTriangle(graphics, v1, v2, v3);&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a triangle is facing away from the camera (backface).&#10;     */&#10;    private boolean isBackface(Point3D v1, Point3D v2, Point3D v3) {&#10;        // Calculate cross product of two edges&#10;        double edge1X = v2.getX() - v1.getX();&#10;        double edge1Y = v2.getY() - v1.getY();&#10;        double edge2X = v3.getX() - v1.getX();&#10;        double edge2Y = v3.getY() - v1.getY();&#10;&#10;        double crossProduct = edge1X * edge2Y - edge1Y * edge2X;&#10;        return crossProduct &lt; 0; // Clockwise = backface&#10;    }&#10;&#10;    /**&#10;     * Checks if any part of the triangle is visible on screen.&#10;     */&#10;    private boolean isTriangleVisible(Point3D v1, Point3D v2, Point3D v3) {&#10;        // Simple bounds check&#10;        double minX = Math.min(Math.min(v1.getX(), v2.getX()), v3.getX());&#10;        double maxX = Math.max(Math.max(v1.getX(), v2.getX()), v3.getX());&#10;        double minY = Math.min(Math.min(v1.getY(), v2.getY()), v3.getY());&#10;        double maxY = Math.max(Math.max(v1.getY(), v2.getY()), v3.getY());&#10;&#10;        return maxX &gt;= 0 &amp;&amp; minX &lt; getWidth() &amp;&amp; maxY &gt;= 0 &amp;&amp; minY &lt; getHeight();&#10;    }&#10;&#10;    /**&#10;     * Draws the wireframe of a triangle.&#10;     */&#10;    private void drawWireframeTriangle(Graphics graphics, Point3D v1, Point3D v2, Point3D v3) {&#10;        graphics.setForegroundColor(wireframeColor);&#10;        drawLine(graphics, v1, v2, wireframeChar);&#10;        drawLine(graphics, v2, v3, wireframeChar);&#10;        drawLine(graphics, v3, v1, wireframeChar);&#10;    }&#10;&#10;    /**&#10;     * Fills a triangle with the fill character.&#10;     */&#10;    private void fillTriangle(Graphics graphics, Point3D v1, Point3D v2, Point3D v3) {&#10;        graphics.setForegroundColor(fillColor);&#10;&#10;        // Simple triangle filling using scanline algorithm&#10;        int minY = (int) Math.max(0, Math.min(Math.min(v1.getY(), v2.getY()), v3.getY()));&#10;        int maxY = (int) Math.min(getHeight() - 1, Math.max(Math.max(v1.getY(), v2.getY()), v3.getY()));&#10;&#10;        for (int y = minY; y &lt;= maxY; y++) {&#10;            List&lt;Double&gt; intersections = new ArrayList&lt;&gt;();&#10;&#10;            // Find intersections with triangle edges&#10;            addLineIntersection(intersections, v1, v2, y);&#10;            addLineIntersection(intersections, v2, v3, y);&#10;            addLineIntersection(intersections, v3, v1, y);&#10;&#10;            if (intersections.size() &gt;= 2) {&#10;                intersections.sort(Double::compareTo);&#10;                int startX = (int) Math.max(0, intersections.get(0));&#10;                int endX = (int) Math.min(getWidth() - 1, intersections.get(intersections.size() - 1));&#10;&#10;                for (int x = startX; x &lt;= endX; x++) {&#10;                    // Calculate depth for this pixel&#10;                    double depth = interpolateDepth(v1, v2, v3, x, y);&#10;&#10;                    // Depth test&#10;                    if (depth &lt; depthBuffer[y][x]) {&#10;                        depthBuffer[y][x] = depth;&#10;                        graphics.drawChar(x, y, fillChar);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Adds line intersection with horizontal scanline if it exists.&#10;     */&#10;    private void addLineIntersection(List&lt;Double&gt; intersections, Point3D p1, Point3D p2, int y) {&#10;        if ((p1.getY() &lt;= y &amp;&amp; p2.getY() &gt; y) || (p2.getY() &lt;= y &amp;&amp; p1.getY() &gt; y)) {&#10;            double t = (y - p1.getY()) / (p2.getY() - p1.getY());&#10;            double x = p1.getX() + t * (p2.getX() - p1.getX());&#10;            intersections.add(x);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interpolates depth value at given pixel coordinates within triangle.&#10;     */&#10;    private double interpolateDepth(Point3D v1, Point3D v2, Point3D v3, int x, int y) {&#10;        // Barycentric coordinates for depth interpolation&#10;        double denom = (v2.getY() - v3.getY()) * (v1.getX() - v3.getX()) + (v3.getX() - v2.getX()) * (v1.getY() - v3.getY());&#10;        if (Math.abs(denom) &lt; 1e-10) return v1.getZ();&#10;&#10;        double a = ((v2.getY() - v3.getY()) * (x - v3.getX()) + (v3.getX() - v2.getX()) * (y - v3.getY())) / denom;&#10;        double b = ((v3.getY() - v1.getY()) * (x - v3.getX()) + (v1.getX() - v3.getX()) * (y - v3.getY())) / denom;&#10;        double c = 1 - a - b;&#10;&#10;        return a * v1.getZ() + b * v2.getZ() + c * v3.getZ();&#10;    }&#10;&#10;    /**&#10;     * Draws a line between two points using Bresenham's algorithm.&#10;     */&#10;    private void drawLine(Graphics graphics, Point3D p1, Point3D p2, char character) {&#10;        int x1 = (int) p1.getX();&#10;        int y1 = (int) p1.getY();&#10;        int x2 = (int) p2.getX();&#10;        int y2 = (int) p2.getY();&#10;&#10;        int dx = Math.abs(x2 - x1);&#10;        int dy = Math.abs(y2 - y1);&#10;        int sx = x1 &lt; x2 ? 1 : -1;&#10;        int sy = y1 &lt; y2 ? 1 : -1;&#10;        int err = dx - dy;&#10;&#10;        int x = x1;&#10;        int y = y1;&#10;&#10;        while (true) {&#10;            if (x &gt;= 0 &amp;&amp; x &lt; getWidth() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; getHeight()) {&#10;                graphics.drawChar(x, y, character);&#10;            }&#10;&#10;            if (x == x2 &amp;&amp; y == y2) break;&#10;&#10;            int e2 = 2 * err;&#10;            if (e2 &gt; -dy) {&#10;                err -= dy;&#10;                x += sx;&#10;            }&#10;            if (e2 &lt; dx) {&#10;                err += dx;&#10;                y += sy;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clears the depth buffer.&#10;     */&#10;    private void clearDepthBuffer() {&#10;        if (depthBuffer == null || depthBuffer.length != getHeight() || depthBuffer[0].length != getWidth()) {&#10;            depthBuffer = new double[getHeight()][getWidth()];&#10;        }&#10;        for (int y = 0; y &lt; getHeight(); y++) {&#10;            for (int x = 0; x &lt; getWidth(); x++) {&#10;                depthBuffer[y][x] = Double.MAX_VALUE;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Requests a redraw of the canvas.&#10;     */&#10;    private void requestRedraw() {&#10;        // This would typically trigger a repaint in the framework&#10;        // Implementation depends on the framework's redraw mechanism&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>